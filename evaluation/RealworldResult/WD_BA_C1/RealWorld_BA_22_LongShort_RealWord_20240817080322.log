[2024-17-08 08:03:22 INFO] **[Preprocessing]**

**ChatDev Starts** (20240817080322)

**Timestamp**: 20240817080322

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}


**project_name**: RealWorld_BA_22_LongShort

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_22_LongShort_RealWord_20240817080322.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-17-08 08:03:23 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\nimport "./interfaces/ITokenFactory.sol";\nimport "./interfaces/ISyntheticToken.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IYieldManager.sol";\nimport "./interfaces/IOracleManager.sol";\n\n/\n  visit https://float.capital \n /\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; bool) public marketExists;\n  mapping(uint32 =&gt; uint256) public assetPrice;\n  mapping(uint32 =&gt; uint256) public marketUpdateIndex;\n  mapping(uint32 =&gt; address) public paymentTokens;\n  mapping(uint32 =&gt; address) public yieldManagers;\n  mapping(uint32 =&gt; address) public oracleManagers;\n  mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18;\n\n  / ══════ Market + position (long/short) specific ══════ /\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, "only admin");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    ;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], "market doesn\'t exist");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    ;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    executeOutstandingNextPriceSettlements(user, marketIndex);\n    ;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    updateSystemStateInternal(marketIndex);\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin\'s initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test\'s arn\'t validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The initializeMarket function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Up ", syntheticName)),\n      string(abi.encodePacked("fu", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Down ", syntheticName)),\n      string(abi.encodePacked("fd", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide &gt;= 1e18,\n      "Insufficient market seed"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], "already initialized");\n    require(marketIndex &lt;= latestMarket, "index too high");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a &gt; b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token\'s lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side\'s synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side\'s synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  /\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - "Pending" - means the next price update hasn\'t happened or been enacted on by the updateSystemState function.\n        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - "Settled" - there is no more computation left for the user.\n        - "Non-existant" - user has no next price actions.\n    This function returns a calculated value only in the case of \'confirmed\' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  /\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;\n      userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited &gt; 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   /\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue &lt; shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount &gt; 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure &lt; 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange &gt; 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won\'t affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the \'staker\' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /╔════════════════════════════════╗\n    ║           DEPOSIT              ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n\n  /╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║      REDEEM POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║       SHIFT POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /╔════════════════════════════════╗\n    ║     NEXT PRICE SETTLEMENTS     ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount &gt; 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions &gt; 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /╔═══════════════════════════════════════════╗\n    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║\n    ╚═══════════════════════════════════════════╝*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket &gt; 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply &gt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply &lt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n\n  /\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:03:23 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:03:23 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-17-08 08:03:26 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:03:26 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26558
completion_tokens: 1
total_tokens: 26559
cost: $-1.000000


[2024-17-08 08:03:26 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Let's

[2024-17-08 08:03:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.3;\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "./interfaces/ITokenFactory.sol";\nimport "./interfaces/ISyntheticToken.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IYieldManager.sol";\nimport "./interfaces/IOracleManager.sol";\n/\n  visit https://float.capital \n /\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n  / ══════ Fixed-precision constants ══════ /\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n  / ══════ Global state ══════ /\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; bool) public marketExists;\n  mapping(uint32 =&gt; uint256) public assetPrice;\n  mapping(uint32 =&gt; uint256) public marketUpdateIndex;\n  mapping(uint32 =&gt; address) public paymentTokens;\n  mapping(uint32 =&gt; address) public yieldManagers;\n  mapping(uint32 =&gt; address) public oracleManagers;\n  mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18;\n  / ══════ Market + position (long/short) specific ══════ /\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken;\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, "only admin");\n  }\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    ;\n  }\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], "market doesn\'t exist");\n  }\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    ;\n  }\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    executeOutstandingNextPriceSettlements(user, marketIndex);\n    ;\n  }\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    updateSystemStateInternal(marketIndex);\n    ;\n  }\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝/\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin\'s initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test\'s arn\'t validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n  /╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝/\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The initializeMarket function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Up ", syntheticName)),\n      string(abi.encodePacked("fu", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Down ", syntheticName)),\n      string(abi.encodePacked("fd", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide &gt;= 1e18,\n      "Insufficient market seed"\n    );\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], "already initialized");\n    require(marketIndex &lt;= latestMarket, "index too high");\n    marketExists[marketIndex] = true;\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n  /╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a &gt; b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token\'s lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n  /\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side\'s synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side\'s synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  /\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n  /\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - "Pending" - means the next price update hasn\'t happened or been enacted on by the updateSystemState function.\n        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - "Settled" - there is no more computation left for the user.\n        - "Non-existant" - user has no next price actions.\n    This function returns a calculated value only in the case of \'confirmed\' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  /\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;\n      userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n      if (amountPaymentTokenDeposited &gt; 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n  /\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   /\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue &lt; shortValue;\n    uint256 imbalance;\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n  /╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n    if (marketAmount &gt; 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure &lt; 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n    if (valueChange &gt; 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n  /╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝/\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won\'t affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the \'staker\' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n  /╔════════════════════════════════╗\n    ║           DEPOSIT              ║\n    ╚════════════════════════════════╝/\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n  /╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝/\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n  /╔═══════════════════════════╗\n    ║      REDEEM POSITION      ║\n    ╚═══════════════════════════╝/\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n  /╔═══════════════════════════╗\n    ║       SHIFT POSITION      ║\n    ╚═══════════════════════════╝/\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n  /╔════════════════════════════════╗\n    ║     NEXT PRICE SETTLEMENTS     ║\n    ╚════════════════════════════════╝/\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount &gt; 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions &gt; 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n  /╔═══════════════════════════════════════════╗\n    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║\n    ╚═══════════════════════════════════════════╝/\n  /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket &gt; 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply &gt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply &lt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n  /\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.3;\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "./interfaces/ITokenFactory.sol";\nimport "./interfaces/ISyntheticToken.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IYieldManager.sol";\nimport "./interfaces/IOracleManager.sol";\n/\n  visit https://float.capital *\n /\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n  / ══════ Fixed-precision constants ══════ /\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n  / ══════ Global state ══════ /\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; bool) public marketExists;\n  mapping(uint32 =&gt; uint256) public assetPrice;\n  mapping(uint32 =&gt; uint256) public marketUpdateIndex;\n  mapping(uint32 =&gt; address) public paymentTokens;\n  mapping(uint32 =&gt; address) public yieldManagers;\n  mapping(uint32 =&gt; address) public oracleManagers;\n  mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18;\n  / ══════ Market + position (long/short) specific ══════ /\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken;\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, "only admin");\n  }\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    ;\n  }\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], "market doesn\'t exist");\n  }\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    ;\n  }\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    executeOutstandingNextPriceSettlements(user, marketIndex);\n    ;\n  }\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    updateSystemStateInternal(marketIndex);\n    ;\n  }\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝/\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin\'s initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test\'s arn\'t validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n  /╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝/\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The initializeMarket function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Up ", syntheticName)),\n      string(abi.encodePacked("fu", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Down ", syntheticName)),\n      string(abi.encodePacked("fd", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide &gt;= 1e18,\n      "Insufficient market seed"\n    );\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], "already initialized");\n    require(marketIndex &lt;= latestMarket, "index too high");\n    marketExists[marketIndex] = true;\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n  /╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a &gt; b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token\'s lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n  /\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side\'s synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side\'s synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  /\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n  /\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - "Pending" - means the next price update hasn\'t happened or been enacted on by the updateSystemState function.\n        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - "Settled" - there is no more computation left for the user.\n        - "Non-existant" - user has no next price actions.\n    This function returns a calculated value only in the case of \'confirmed\' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  /\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;\n      userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n      if (amountPaymentTokenDeposited &gt; 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n  /\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   /\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue &lt; shortValue;\n    uint256 imbalance;\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n  /╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n    if (marketAmount &gt; 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure &lt; 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n    if (valueChange &gt; 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n  /╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝/\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won\'t affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the \'staker\' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n  /╔════════════════════════════════╗\n    ║           DEPOSIT              ║\n    ╚════════════════════════════════╝/\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n  /╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝/\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n  /╔═══════════════════════════╗\n    ║      REDEEM POSITION      ║\n    ╚═══════════════════════════╝/\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n  /╔═══════════════════════════╗\n    ║       SHIFT POSITION      ║\n    ╚═══════════════════════════╝/\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n  /╔════════════════════════════════╗\n    ║     NEXT PRICE SETTLEMENTS     ║\n    ╚════════════════════════════════╝/\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount &gt; 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions &gt; 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n  /╔═══════════════════════════════════════════╗\n    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║\n    ╚═══════════════════════════════════════════╝*/\n  /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket &gt; 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply &gt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply &lt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n  /\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:03:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:03:27 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.3;
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";
/**
 **** visit https://float.capital *****
 */
/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/
  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;
  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;
  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;
  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;
  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;
  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;
  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;
  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;
  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/
  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);
  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );
  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );
  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );
  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );
  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );
  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);
  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);
  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);
  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);
  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );
  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);
  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/
  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }
  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }
  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }
  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }
  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }
  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }
  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/
  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;
    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }
  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/
  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }
  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }
  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }
  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }
  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/
  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;
    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );
    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );
    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());
    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }
  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );
    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);
    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;
    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }
  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");
    marketExists[marketIndex] = true;
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;
    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );
    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }
  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/
  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }
  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }
  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }
  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }
  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function
            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)
            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }
  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];
    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }
  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];
        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }

        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];
      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];
        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }
  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;
    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }
    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;
    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);
    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }
  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/
  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;
    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );
    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);
    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }
    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;
    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }
  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/
  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);
    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;
    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }
      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }
      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );
      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );
      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;
      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;
      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;
      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;
      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }
  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }
  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }
  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/
  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }
  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/
  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);
    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;
    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }
  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }
  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }
  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/
  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );
    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;
    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;
    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }
  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }
  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }
  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/
  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );
    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;
    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;
    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }
  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }
  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }
  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/
  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );
      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }
  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);
      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }
  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );
      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;
      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );
      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }
  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);
      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;
      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }
  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }
  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }
  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/
  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }
  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }
  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.
    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.
    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;
    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];
    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);
      batched_amountPaymentToken_deposit[marketIndex][true] = 0;
      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }
    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);
      batched_amountPaymentToken_deposit[marketIndex][false] = 0;
      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }
    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );
      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }
    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );
      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }
    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }
    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }
    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.3;
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";
/**
 **** visit https://float.capital *****
 */
/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/
  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;
  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;
  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;
  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;
  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;
  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;
  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;
  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;
  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/
  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);
  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );
  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );
  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );
  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );
  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );
  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);
  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);
  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);
  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);
  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );
  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);
  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/
  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }
  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }
  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }
  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }
  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }
  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }
  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/
  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;
    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }
  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/
  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }
  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }
  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }
  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }
  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/
  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;
    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );
    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );
    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());
    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }
  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );
    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);
    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;
    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }
  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");
    marketExists[marketIndex] = true;
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;
    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );
    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }
  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/
  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }
  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }
  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }
  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }
  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function
            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)
            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }
  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];
    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }
  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];
        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }

        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];
      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];
        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }
  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;
    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }
    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;
    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);
    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }
  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/
  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;
    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );
    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);
    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }
    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;
    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }
  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/
  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);
    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;
    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }
      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }
      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );
      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );
      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;
      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;
      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;
      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;
      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }
  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }
  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }
  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/
  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }
  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/
  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);
    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;
    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }
  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }
  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }
  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/
  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );
    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;
    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;
    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }
  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }
  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }
  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/
  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );
    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;
    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;
    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }
  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }
  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }
  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/
  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );
      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }
  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);
      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }
  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );
      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;
      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );
      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }
  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);
      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;
      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }
  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }
  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }
  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/
  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }
  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }
  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.
    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.
    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;
    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];
    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);
      batched_amountPaymentToken_deposit[marketIndex][true] = 0;
      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }
    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);
      batched_amountPaymentToken_deposit[marketIndex][false] = 0;
      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }
    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );
      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }
    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );
      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }
    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }
    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }
    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-17-08 08:03:31 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:03:31 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 39892
completion_tokens: 1
total_tokens: 39893
cost: $-1.000000


[2024-17-08 08:03:31 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Security

[2024-17-08 08:03:31 INFO] **[Seminar Conclusion]**:

 Security

[2024-17-08 08:03:31 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-17-08 08:03:31 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-17-08 08:03:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\nimport "./interfaces/ITokenFactory.sol";\nimport "./interfaces/ISyntheticToken.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IYieldManager.sol";\nimport "./interfaces/IOracleManager.sol";\n\n/\n  visit https://float.capital \n /\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; bool) public marketExists;\n  mapping(uint32 =&gt; uint256) public assetPrice;\n  mapping(uint32 =&gt; uint256) public marketUpdateIndex;\n  mapping(uint32 =&gt; address) public paymentTokens;\n  mapping(uint32 =&gt; address) public yieldManagers;\n  mapping(uint32 =&gt; address) public oracleManagers;\n  mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18;\n\n  / ══════ Market + position (long/short) specific ══════ /\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, "only admin");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    ;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], "market doesn\'t exist");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    ;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    executeOutstandingNextPriceSettlements(user, marketIndex);\n    ;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    updateSystemStateInternal(marketIndex);\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin\'s initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test\'s arn\'t validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The initializeMarket function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Up ", syntheticName)),\n      string(abi.encodePacked("fu", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Down ", syntheticName)),\n      string(abi.encodePacked("fd", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide &gt;= 1e18,\n      "Insufficient market seed"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], "already initialized");\n    require(marketIndex &lt;= latestMarket, "index too high");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a &gt; b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token\'s lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side\'s synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side\'s synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  /\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - "Pending" - means the next price update hasn\'t happened or been enacted on by the updateSystemState function.\n        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - "Settled" - there is no more computation left for the user.\n        - "Non-existant" - user has no next price actions.\n    This function returns a calculated value only in the case of \'confirmed\' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  /\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;\n      userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited &gt; 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   /\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue &lt; shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount &gt; 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure &lt; 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange &gt; 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won\'t affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the \'staker\' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /╔════════════════════════════════╗\n    ║           DEPOSIT              ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n\n  /╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║      REDEEM POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║       SHIFT POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /╔════════════════════════════════╗\n    ║     NEXT PRICE SETTLEMENTS     ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount &gt; 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions &gt; 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /╔═══════════════════════════════════════════╗\n    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║\n    ╚═══════════════════════════════════════════╝*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket &gt; 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply &gt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply &lt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n\n  /\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:03:31 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:03:31 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-17-08 08:03:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:03:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26549
completion_tokens: 1
total_tokens: 26550
cost: $-1.000000


[2024-17-08 08:03:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

###

[2024-17-08 08:03:35 INFO] **[Seminar Conclusion]**:

 ###

[2024-17-08 08:03:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-17-08 08:03:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:03:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:03:35 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-17-08 08:03:46 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:03:46 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13334
completion_tokens: 738
total_tokens: 14072
cost: $-1.000000


[2024-17-08 08:03:46 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Based on the provided smart contract code for the `LongShort` contract, here is a summary of potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Access Control Issues**:
   - The `adminOnly` modifier is used to restrict access to certain functions, but there is no mechanism to ensure that the admin address is secure or that it cannot be changed to a malicious address. If an attacker gains control of the admin address, they could manipulate the contract.

2. **Reentrancy Vulnerability**:
   - Functions that transfer tokens or call external contracts (like `IYieldManager`) could be susceptible to reentrancy attacks if not properly guarded. Although the contract uses the `executeOutstandingNextPriceSettlements` modifier to handle state updates, it does not implement a reentrancy guard.

3. **Lack of Input Validation**:
   - Several functions do not validate the input parameters thoroughly. For example, in the `createNewSyntheticMarket` function, there is no check to ensure that the provided addresses for `_paymentToken`, `_oracleManager`, and `_yieldManager` are valid contracts.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any arithmetic operations that involve external inputs could still lead to unexpected behavior if not handled correctly.

5. **Gas Limit Issues**:
   - The `updateSystemStateMulti` function iterates over an array of market indexes without any gas limit checks. If the array is too large, it could lead to out-of-gas errors.

6. **Event Emission**:
   - While the contract emits events for significant actions, there are some functions that do not emit events for state changes, which could hinder tracking and auditing of contract actions.

7. **Inadequate Error Handling**:
   - The contract relies on require statements for error handling, but it does not provide detailed error messages in some cases, making it difficult to debug issues.

8. **Market Initialization Logic**:
   - The logic for initializing markets could lead to inconsistencies if not properly managed. For instance, if `initializeMarket` is called multiple times for the same market index, it could lead to unexpected behavior.

### Comprehensive Analysis Report:

The `LongShort` contract implements a complex system for managing synthetic assets, but it is not without its vulnerabilities. The primary concerns revolve around access control, potential reentrancy attacks, and insufficient input validation. The reliance on the admin address without adequate security measures poses a significant risk, as does the lack of reentrancy guards in critical functions.

Moreover, the contract's arithmetic operations, while protected against overflow and underflow due to Solidity's version, still require careful handling to avoid unexpected behavior, especially when dealing with external inputs. The potential for gas limit issues in batch processing functions could lead to failures in execution, particularly in scenarios with a high number of market indexes.

To enhance the security posture of the contract, it is recommended to implement the following measures:
- Introduce a robust access control mechanism to secure the admin functions.
- Implement reentrancy guards on functions that interact with external contracts.
- Validate all input parameters rigorously to prevent invalid state changes.
- Ensure that all significant state changes are accompanied by appropriate event emissions for better tracking.
- Provide detailed error messages in require statements to aid in debugging.
- Consider gas limit checks in functions that iterate over arrays to prevent out-of-gas errors.

By addressing these vulnerabilities, the `LongShort` contract can significantly improve its security and reliability, ensuring a safer environment for users interacting with the synthetic asset markets.

[2024-17-08 08:03:46 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `LongShort` contract, here is a summary of potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Access Control Issues**:
   - The `adminOnly` modifier is used to restrict access to certain functions, but there is no mechanism to ensure that the admin address is secure or that it cannot be changed to a malicious address. If an attacker gains control of the admin address, they could manipulate the contract.

2. **Reentrancy Vulnerability**:
   - Functions that transfer tokens or call external contracts (like `IYieldManager`) could be susceptible to reentrancy attacks if not properly guarded. Although the contract uses the `executeOutstandingNextPriceSettlements` modifier to handle state updates, it does not implement a reentrancy guard.

3. **Lack of Input Validation**:
   - Several functions do not validate the input parameters thoroughly. For example, in the `createNewSyntheticMarket` function, there is no check to ensure that the provided addresses for `_paymentToken`, `_oracleManager`, and `_yieldManager` are valid contracts.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any arithmetic operations that involve external inputs could still lead to unexpected behavior if not handled correctly.

5. **Gas Limit Issues**:
   - The `updateSystemStateMulti` function iterates over an array of market indexes without any gas limit checks. If the array is too large, it could lead to out-of-gas errors.

6. **Event Emission**:
   - While the contract emits events for significant actions, there are some functions that do not emit events for state changes, which could hinder tracking and auditing of contract actions.

7. **Inadequate Error Handling**:
   - The contract relies on require statements for error handling, but it does not provide detailed error messages in some cases, making it difficult to debug issues.

8. **Market Initialization Logic**:
   - The logic for initializing markets could lead to inconsistencies if not properly managed. For instance, if `initializeMarket` is called multiple times for the same market index, it could lead to unexpected behavior.

### Comprehensive Analysis Report:

The `LongShort` contract implements a complex system for managing synthetic assets, but it is not without its vulnerabilities. The primary concerns revolve around access control, potential reentrancy attacks, and insufficient input validation. The reliance on the admin address without adequate security measures poses a significant risk, as does the lack of reentrancy guards in critical functions.

Moreover, the contract's arithmetic operations, while protected against overflow and underflow due to Solidity's version, still require careful handling to avoid unexpected behavior, especially when dealing with external inputs. The potential for gas limit issues in batch processing functions could lead to failures in execution, particularly in scenarios with a high number of market indexes.

To enhance the security posture of the contract, it is recommended to implement the following measures:
- Introduce a robust access control mechanism to secure the admin functions.
- Implement reentrancy guards on functions that interact with external contracts.
- Validate all input parameters rigorously to prevent invalid state changes.
- Ensure that all significant state changes are accompanied by appropriate event emissions for better tracking.
- Provide detailed error messages in require statements to aid in debugging.
- Consider gas limit checks in functions that iterate over arrays to prevent out-of-gas errors.

By addressing these vulnerabilities, the `LongShort` contract can significantly improve its security and reliability, ensuring a safer environment for users interacting with the synthetic asset markets.

[2024-17-08 08:03:46 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-17-08 08:03:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\nimport "./interfaces/ITokenFactory.sol";\nimport "./interfaces/ISyntheticToken.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IYieldManager.sol";\nimport "./interfaces/IOracleManager.sol";\n\n/\n  visit https://float.capital \n /\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; bool) public marketExists;\n  mapping(uint32 =&gt; uint256) public assetPrice;\n  mapping(uint32 =&gt; uint256) public marketUpdateIndex;\n  mapping(uint32 =&gt; address) public paymentTokens;\n  mapping(uint32 =&gt; address) public yieldManagers;\n  mapping(uint32 =&gt; address) public oracleManagers;\n  mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18;\n\n  / ══════ Market + position (long/short) specific ══════ /\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, "only admin");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    ;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], "market doesn\'t exist");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    ;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    executeOutstandingNextPriceSettlements(user, marketIndex);\n    ;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    updateSystemStateInternal(marketIndex);\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin\'s initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test\'s arn\'t validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The initializeMarket function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Up ", syntheticName)),\n      string(abi.encodePacked("fu", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Down ", syntheticName)),\n      string(abi.encodePacked("fd", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide &gt;= 1e18,\n      "Insufficient market seed"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], "already initialized");\n    require(marketIndex &lt;= latestMarket, "index too high");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a &gt; b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token\'s lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side\'s synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side\'s synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  /\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - "Pending" - means the next price update hasn\'t happened or been enacted on by the updateSystemState function.\n        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - "Settled" - there is no more computation left for the user.\n        - "Non-existant" - user has no next price actions.\n    This function returns a calculated value only in the case of \'confirmed\' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  /\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;\n      userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited &gt; 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   /\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue &lt; shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount &gt; 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure &lt; 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange &gt; 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won\'t affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the \'staker\' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /╔════════════════════════════════╗\n    ║           DEPOSIT              ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n\n  /╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║      REDEEM POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║       SHIFT POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /╔════════════════════════════════╗\n    ║     NEXT PRICE SETTLEMENTS     ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount &gt; 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions &gt; 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /╔═══════════════════════════════════════════╗\n    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║\n    ╚═══════════════════════════════════════════╝*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket &gt; 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply &gt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply &lt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n\n  /\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:03:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:03:46 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-17-08 08:03:50 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:03:50 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26549
completion_tokens: 1
total_tokens: 26550
cost: $-1.000000


[2024-17-08 08:03:50 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

###

[2024-17-08 08:03:50 INFO] **[Seminar Conclusion]**:

 ###

[2024-17-08 08:03:50 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-17-08 08:03:50 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:03:50 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:03:50 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-17-08 08:04:04 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:04:04 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13334
completion_tokens: 812
total_tokens: 14146
cost: $-1.000000


[2024-17-08 08:04:04 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Based on the provided Solidity smart contract code for the `LongShort` contract, here is a summary of potential security vulnerabilities and issues identified:

### Summary of Security Vulnerabilities:

1. **Access Control Issues**:
   - The contract relies on the `admin` address for critical administrative functions (e.g., changing the admin, treasury, and oracle). If the admin key is compromised, an attacker could take control of the contract.
   - There are no mechanisms for revoking or rotating the admin address, which could lead to centralization risks.

2. **Reentrancy Vulnerabilities**:
   - Functions that transfer tokens or call external contracts (e.g., `_transferPaymentTokensFromUserToYieldManager`, `_executeOutstandingNextPriceRedeems`) could be susceptible to reentrancy attacks if not properly guarded. Although the use of the `executeOutstandingNextPriceSettlements` modifier helps mitigate this risk, it is essential to ensure that all external calls are made after state changes.

3. **Lack of Input Validation**:
   - Some functions do not validate the input parameters thoroughly. For example, in `createNewSyntheticMarket`, there is no check to ensure that the provided addresses for `_paymentToken`, `_oracleManager`, and `_yieldManager` are valid contracts.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, it is crucial to ensure that all arithmetic operations are safe, especially when dealing with user inputs and financial calculations.

5. **Gas Limit Issues**:
   - Functions that involve loops or multiple state updates (e.g., `updateSystemStateMulti`) could exceed gas limits if called with a large number of market indexes, leading to failed transactions.

6. **Event Emission**:
   - While the contract emits events for significant state changes, it is essential to ensure that all critical actions are logged appropriately to maintain transparency and facilitate auditing.

7. **Oracle Dependency**:
   - The contract relies heavily on external oracles for price updates. If the oracle is compromised or provides incorrect data, it could lead to significant financial losses.

8. **Market Initialization Risks**:
   - The `initializeMarket` function allows for the creation of new markets, but there are no checks to prevent duplicate market creation or to ensure that the market is adequately funded before being activated.

### Comprehensive Analysis Report:

The `LongShort` contract implements a complex financial system that allows users to mint synthetic assets based on underlying asset prices. While the contract is designed with several safety features, it does present multiple security vulnerabilities that need to be addressed to ensure the integrity and safety of user funds.

1. **Access Control**: The reliance on a single admin address poses a significant risk. Implementing a multi-signature wallet or a decentralized governance mechanism could enhance security.

2. **Reentrancy Protection**: Although some measures are in place, further precautions should be taken to ensure that all external calls are made after state changes, and consider using the Checks-Effects-Interactions pattern consistently.

3. **Input Validation**: Comprehensive checks should be added to validate all inputs, especially addresses and amounts, to prevent unexpected behavior and potential exploits.

4. **Gas Limit Considerations**: Functions that could potentially consume a lot of gas should be optimized or broken down into smaller, more manageable calls to prevent transaction failures.

5. **Oracle Reliability**: The contract's reliance on external oracles necessitates a robust mechanism for ensuring the integrity and reliability of the data provided. Consider implementing fallback mechanisms or using multiple oracles for price feeds.

6. **Market Management**: Additional checks should be implemented to prevent duplicate market creation and ensure that markets are adequately funded before activation.

In conclusion, while the `LongShort` contract has a solid foundation, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the protocol. A thorough audit and continuous monitoring of the contract post-deployment will be essential to mitigate risks and protect user assets.

[2024-17-08 08:04:04 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `LongShort` contract, here is a summary of potential security vulnerabilities and issues identified:

### Summary of Security Vulnerabilities:

1. **Access Control Issues**:
   - The contract relies on the `admin` address for critical administrative functions (e.g., changing the admin, treasury, and oracle). If the admin key is compromised, an attacker could take control of the contract.
   - There are no mechanisms for revoking or rotating the admin address, which could lead to centralization risks.

2. **Reentrancy Vulnerabilities**:
   - Functions that transfer tokens or call external contracts (e.g., `_transferPaymentTokensFromUserToYieldManager`, `_executeOutstandingNextPriceRedeems`) could be susceptible to reentrancy attacks if not properly guarded. Although the use of the `executeOutstandingNextPriceSettlements` modifier helps mitigate this risk, it is essential to ensure that all external calls are made after state changes.

3. **Lack of Input Validation**:
   - Some functions do not validate the input parameters thoroughly. For example, in `createNewSyntheticMarket`, there is no check to ensure that the provided addresses for `_paymentToken`, `_oracleManager`, and `_yieldManager` are valid contracts.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, it is crucial to ensure that all arithmetic operations are safe, especially when dealing with user inputs and financial calculations.

5. **Gas Limit Issues**:
   - Functions that involve loops or multiple state updates (e.g., `updateSystemStateMulti`) could exceed gas limits if called with a large number of market indexes, leading to failed transactions.

6. **Event Emission**:
   - While the contract emits events for significant state changes, it is essential to ensure that all critical actions are logged appropriately to maintain transparency and facilitate auditing.

7. **Oracle Dependency**:
   - The contract relies heavily on external oracles for price updates. If the oracle is compromised or provides incorrect data, it could lead to significant financial losses.

8. **Market Initialization Risks**:
   - The `initializeMarket` function allows for the creation of new markets, but there are no checks to prevent duplicate market creation or to ensure that the market is adequately funded before being activated.

### Comprehensive Analysis Report:

The `LongShort` contract implements a complex financial system that allows users to mint synthetic assets based on underlying asset prices. While the contract is designed with several safety features, it does present multiple security vulnerabilities that need to be addressed to ensure the integrity and safety of user funds.

1. **Access Control**: The reliance on a single admin address poses a significant risk. Implementing a multi-signature wallet or a decentralized governance mechanism could enhance security.

2. **Reentrancy Protection**: Although some measures are in place, further precautions should be taken to ensure that all external calls are made after state changes, and consider using the Checks-Effects-Interactions pattern consistently.

3. **Input Validation**: Comprehensive checks should be added to validate all inputs, especially addresses and amounts, to prevent unexpected behavior and potential exploits.

4. **Gas Limit Considerations**: Functions that could potentially consume a lot of gas should be optimized or broken down into smaller, more manageable calls to prevent transaction failures.

5. **Oracle Reliability**: The contract's reliance on external oracles necessitates a robust mechanism for ensuring the integrity and reliability of the data provided. Consider implementing fallback mechanisms or using multiple oracles for price feeds.

6. **Market Management**: Additional checks should be implemented to prevent duplicate market creation and ensure that markets are adequately funded before activation.

In conclusion, while the `LongShort` contract has a solid foundation, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the protocol. A thorough audit and continuous monitoring of the contract post-deployment will be essential to mitigate risks and protect user assets.

[2024-17-08 08:04:04 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-17-08 08:04:04 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\nimport "./interfaces/ITokenFactory.sol";\nimport "./interfaces/ISyntheticToken.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IYieldManager.sol";\nimport "./interfaces/IOracleManager.sol";\n\n/\n  visit https://float.capital \n /\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; bool) public marketExists;\n  mapping(uint32 =&gt; uint256) public assetPrice;\n  mapping(uint32 =&gt; uint256) public marketUpdateIndex;\n  mapping(uint32 =&gt; address) public paymentTokens;\n  mapping(uint32 =&gt; address) public yieldManagers;\n  mapping(uint32 =&gt; address) public oracleManagers;\n  mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18;\n\n  / ══════ Market + position (long/short) specific ══════ /\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, "only admin");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    ;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], "market doesn\'t exist");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    ;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    executeOutstandingNextPriceSettlements(user, marketIndex);\n    ;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    updateSystemStateInternal(marketIndex);\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin\'s initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test\'s arn\'t validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The initializeMarket function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Up ", syntheticName)),\n      string(abi.encodePacked("fu", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Down ", syntheticName)),\n      string(abi.encodePacked("fd", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide &gt;= 1e18,\n      "Insufficient market seed"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], "already initialized");\n    require(marketIndex &lt;= latestMarket, "index too high");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a &gt; b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token\'s lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side\'s synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side\'s synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  /\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - "Pending" - means the next price update hasn\'t happened or been enacted on by the updateSystemState function.\n        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - "Settled" - there is no more computation left for the user.\n        - "Non-existant" - user has no next price actions.\n    This function returns a calculated value only in the case of \'confirmed\' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  /\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;\n      userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited &gt; 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   /\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue &lt; shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount &gt; 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure &lt; 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange &gt; 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won\'t affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the \'staker\' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /╔════════════════════════════════╗\n    ║           DEPOSIT              ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n\n  /╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║      REDEEM POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║       SHIFT POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /╔════════════════════════════════╗\n    ║     NEXT PRICE SETTLEMENTS     ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount &gt; 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions &gt; 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /╔═══════════════════════════════════════════╗\n    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║\n    ╚═══════════════════════════════════════════╝*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket &gt; 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply &gt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply &lt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n\n  /\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:04:04 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:04:04 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-17-08 08:04:07 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:04:07 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26549
completion_tokens: 1
total_tokens: 26550
cost: $-1.000000


[2024-17-08 08:04:07 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

###

[2024-17-08 08:04:07 INFO] **[Seminar Conclusion]**:

 ###

[2024-17-08 08:04:07 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-17-08 08:04:07 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:04:07 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:04:07 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-17-08 08:04:17 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:04:17 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13334
completion_tokens: 705
total_tokens: 14039
cost: $-1.000000


[2024-17-08 08:04:17 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Based on the provided smart contract code for the `LongShort` contract, here is a summary of potential security vulnerabilities identified within the code:

### Summary of Security Vulnerabilities

1. **Access Control Issues**:
   - The contract relies on a single `admin` address for critical functions. If the admin key is compromised, an attacker could change the treasury, update oracles, and manipulate market parameters.

2. **Reentrancy Vulnerabilities**:
   - Functions that transfer tokens (e.g., `_transferPaymentTokensFromUserToYieldManager`, `_executeOutstandingNextPriceRedeems`) do not implement checks-effects-interactions pattern, making them susceptible to reentrancy attacks.

3. **Lack of Input Validation**:
   - Some functions do not validate the input parameters thoroughly. For example, in `createNewSyntheticMarket`, there is no check to ensure that the provided addresses for `_paymentToken`, `_oracleManager`, and `_yieldManager` are valid contracts.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow checks, there are still areas where arithmetic operations could lead to unexpected behavior if not handled correctly, especially in calculations involving user balances and market values.

5. **Gas Limit Issues**:
   - The use of loops in functions like `updateSystemStateMulti` could lead to gas limit issues if the number of markets is large, potentially causing transactions to fail.

6. **Oracle Manipulation Risks**:
   - The contract relies on external oracles for price feeds. If the oracle is compromised or provides incorrect data, it could lead to significant financial losses for users.

7. **Lack of Emergency Mechanisms**:
   - There are no mechanisms in place to pause or halt operations in case of a detected vulnerability or exploit, which could lead to prolonged exposure to risks.

8. **Insufficient Event Logging**:
   - While there are events emitted for significant actions, there may be insufficient logging for all state changes, making it difficult to audit the contract's behavior post-deployment.

### Comprehensive Analysis Report

The `LongShort` contract presents a sophisticated framework for managing synthetic assets, but it is not without its vulnerabilities. The reliance on a single admin for critical operations poses a significant risk, as any compromise of the admin key could lead to catastrophic changes within the contract. 

The absence of reentrancy protection in functions that handle token transfers could allow attackers to exploit the contract during state changes, leading to potential financial losses. Furthermore, the lack of thorough input validation and checks on external contract addresses can introduce risks if invalid or malicious contracts are interacted with.

While Solidity's built-in protections against overflow and underflow are beneficial, developers should still be cautious with arithmetic operations to avoid unexpected behaviors. The potential for gas limit issues in batch operations could hinder usability, especially as the number of markets grows.

The reliance on external oracles introduces risks associated with data integrity and accuracy, which could be exploited if the oracle is compromised. Additionally, the absence of emergency stop mechanisms limits the ability to respond to vulnerabilities swiftly, leaving the contract exposed to risks for extended periods.

In conclusion, while the `LongShort` contract is designed with advanced features for synthetic asset management, it requires enhancements in security measures, particularly in access control, reentrancy protection, input validation, and emergency protocols. Addressing these vulnerabilities will significantly improve the contract's resilience against potential attacks and ensure a safer environment for users.

[2024-17-08 08:04:17 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `LongShort` contract, here is a summary of potential security vulnerabilities identified within the code:

### Summary of Security Vulnerabilities

1. **Access Control Issues**:
   - The contract relies on a single `admin` address for critical functions. If the admin key is compromised, an attacker could change the treasury, update oracles, and manipulate market parameters.

2. **Reentrancy Vulnerabilities**:
   - Functions that transfer tokens (e.g., `_transferPaymentTokensFromUserToYieldManager`, `_executeOutstandingNextPriceRedeems`) do not implement checks-effects-interactions pattern, making them susceptible to reentrancy attacks.

3. **Lack of Input Validation**:
   - Some functions do not validate the input parameters thoroughly. For example, in `createNewSyntheticMarket`, there is no check to ensure that the provided addresses for `_paymentToken`, `_oracleManager`, and `_yieldManager` are valid contracts.

4. **Potential Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow checks, there are still areas where arithmetic operations could lead to unexpected behavior if not handled correctly, especially in calculations involving user balances and market values.

5. **Gas Limit Issues**:
   - The use of loops in functions like `updateSystemStateMulti` could lead to gas limit issues if the number of markets is large, potentially causing transactions to fail.

6. **Oracle Manipulation Risks**:
   - The contract relies on external oracles for price feeds. If the oracle is compromised or provides incorrect data, it could lead to significant financial losses for users.

7. **Lack of Emergency Mechanisms**:
   - There are no mechanisms in place to pause or halt operations in case of a detected vulnerability or exploit, which could lead to prolonged exposure to risks.

8. **Insufficient Event Logging**:
   - While there are events emitted for significant actions, there may be insufficient logging for all state changes, making it difficult to audit the contract's behavior post-deployment.

### Comprehensive Analysis Report

The `LongShort` contract presents a sophisticated framework for managing synthetic assets, but it is not without its vulnerabilities. The reliance on a single admin for critical operations poses a significant risk, as any compromise of the admin key could lead to catastrophic changes within the contract. 

The absence of reentrancy protection in functions that handle token transfers could allow attackers to exploit the contract during state changes, leading to potential financial losses. Furthermore, the lack of thorough input validation and checks on external contract addresses can introduce risks if invalid or malicious contracts are interacted with.

While Solidity's built-in protections against overflow and underflow are beneficial, developers should still be cautious with arithmetic operations to avoid unexpected behaviors. The potential for gas limit issues in batch operations could hinder usability, especially as the number of markets grows.

The reliance on external oracles introduces risks associated with data integrity and accuracy, which could be exploited if the oracle is compromised. Additionally, the absence of emergency stop mechanisms limits the ability to respond to vulnerabilities swiftly, leaving the contract exposed to risks for extended periods.

In conclusion, while the `LongShort` contract is designed with advanced features for synthetic asset management, it requires enhancements in security measures, particularly in access control, reentrancy protection, input validation, and emergency protocols. Addressing these vulnerabilities will significantly improve the contract's resilience against potential attacks and ensure a safer environment for users.

[2024-17-08 08:04:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n\nimport "./interfaces/ITokenFactory.sol";\nimport "./interfaces/ISyntheticToken.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IYieldManager.sol";\nimport "./interfaces/IOracleManager.sol";\n\n/\n  visit https://float.capital \n /\n\n/// @title Core logic of Float Protocal markets\n/// @author float.capital\n/// @notice visit https://float.capital for more info\n/// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance.\n/// It is merely for convenince when unit testing.\n/// @custom:auditors This contract balances long and short sides.\ncontract LongShort is ILongShort, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  /// @notice this is the address that permanently locked initial liquidity for markets is held by.\n  /// These tokens will never move so market can never have zero liquidity on a side.\n  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.\n  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;\n\n  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:\n  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361\n  uint256[45] private __constantsGap;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public treasury;\n  uint32 public latestMarket;\n\n  address public staker;\n  address public tokenFactory;\n  uint256[45] private __globalStateGap;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; bool) public marketExists;\n  mapping(uint32 =&gt; uint256) public assetPrice;\n  mapping(uint32 =&gt; uint256) public marketUpdateIndex;\n  mapping(uint32 =&gt; address) public paymentTokens;\n  mapping(uint32 =&gt; address) public yieldManagers;\n  mapping(uint32 =&gt; address) public oracleManagers;\n  mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18;\n\n  / ══════ Market + position (long/short) specific ══════ /\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken;\n\n  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;\n  mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;\n  mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))\n    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);\n\n  event SystemStateUpdated(\n    uint32 marketIndex,\n    uint256 updateIndex,\n    int256 underlyingAssetPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 longPrice,\n    uint256 shortPrice\n  );\n\n  event SyntheticMarketCreated(\n    uint32 marketIndex,\n    address longTokenAddress,\n    address shortTokenAddress,\n    address paymentToken,\n    uint256 initialAssetPrice,\n    string name,\n    string symbol,\n    address oracleAddress,\n    address yieldManagerAddress\n  );\n\n  event NextPriceRedeem(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 synthRedeemed,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceSyntheticPositionShift(\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 synthShifted,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event NextPriceDeposit(\n    uint32 marketIndex,\n    bool isLong,\n    uint256 depositAdded,\n    address user,\n    uint256 oracleUpdateIndex\n  );\n\n  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);\n\n  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);\n\n  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);\n\n  event ExecuteNextPriceMarketSideShiftSettlementUser(\n    address user,\n    uint32 marketIndex,\n    bool isShiftFromLong,\n    uint256 amount\n  );\n\n  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function adminOnlyModifierLogic() internal virtual {\n    require(msg.sender == admin, "only admin");\n  }\n\n  modifier adminOnly() {\n    adminOnlyModifierLogic();\n    ;\n  }\n\n  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {\n    require(marketExists[marketIndex], "market doesn\'t exist");\n  }\n\n  modifier requireMarketExists(uint32 marketIndex) {\n    requireMarketExistsModifierLogic(marketIndex);\n    ;\n  }\n\n  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {\n    executeOutstandingNextPriceSettlements(user, marketIndex);\n    ;\n  }\n\n  modifier updateSystemStateMarket(uint32 marketIndex) {\n    updateSystemStateInternal(marketIndex);\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Initializes the contract.\n  /// @dev Calls OpenZeppelin\'s initializer modifier.\n  /// @param _admin Address of the admin role.\n  /// @param _treasury Address of the treasury.\n  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.\n  /// @param _staker Address of the contract which handles synthetic asset stakes.\n  function initialize(\n    address _admin,\n    address _treasury,\n    address _tokenFactory,\n    address _staker\n  ) external virtual initializer {\n    admin = _admin;\n    treasury = _treasury;\n    tokenFactory = _tokenFactory;\n    staker = _staker;\n\n    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  /// @notice Changes the admin address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _admin Address of the new admin.\n  function changeAdmin(address _admin) external adminOnly {\n    admin = _admin;\n  }\n\n  /// @notice Changes the treasury contract address for this contract.\n  /// @dev Can only be called by the current admin.\n  /// @param _treasury Address of the treasury contract\n  function changeTreasury(address _treasury) external adminOnly {\n    treasury = _treasury;\n  }\n\n  /// @notice Update oracle for a market\n  /// @dev Can only be called by the current admin.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param _newOracleManager Address of the replacement oracle manager.\n  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {\n    // If not a oracle contract this would break things.. Test\'s arn\'t validating this\n    // Ie require isOracle interface - ERC165\n    address previousOracleManager = oracleManagers[marketIndex];\n    oracleManagers[marketIndex] = _newOracleManager;\n    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);\n  }\n\n  /// @notice changes the gradient of the line for determining the yield split between market and treasury.\n  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)\n    external\n    adminOnly\n  {\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n  }\n\n  /╔═════════════════════════════╗\n    ║       MARKET CREATION       ║\n    ╚═════════════════════════════╝/\n\n  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.\n  ///  Make sure the synthetic names/symbols are unique.\n  /// @dev This does not make the market active.\n  /// The initializeMarket function was split out separately to this function to reduce costs.\n  /// @param syntheticName Name of the synthetic asset\n  /// @param syntheticSymbol Symbol for the synthetic asset\n  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset\n  /// this will likely always be DAI\n  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market\n  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol\n  function createNewSyntheticMarket(\n    string calldata syntheticName,\n    string calldata syntheticSymbol,\n    address _paymentToken,\n    address _oracleManager,\n    address _yieldManager\n  ) external adminOnly {\n    latestMarket++;\n\n    // Create new synthetic long token.\n    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Up ", syntheticName)),\n      string(abi.encodePacked("fu", syntheticSymbol)),\n      staker,\n      latestMarket,\n      true\n    );\n\n    // Create new synthetic short token.\n    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(\n      string(abi.encodePacked("Float Down ", syntheticName)),\n      string(abi.encodePacked("fd", syntheticSymbol)),\n      staker,\n      latestMarket,\n      false\n    );\n\n    // Initial market state.\n    paymentTokens[latestMarket] = _paymentToken;\n    yieldManagers[latestMarket] = _yieldManager;\n    oracleManagers[latestMarket] = _oracleManager;\n    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());\n\n    emit SyntheticMarketCreated(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      _paymentToken,\n      assetPrice[latestMarket],\n      syntheticName,\n      syntheticSymbol,\n      _oracleManager,\n      _yieldManager\n    );\n  }\n\n  /// @notice Seeds a new market with initial capital.\n  /// @dev Only called when initializing a market.\n  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n    require(\n      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.\n      initialMarketSeedForEachMarketSide &gt;= 1e18,\n      "Insufficient market seed"\n    );\n\n    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);\n    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);\n\n    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(\n      PERMANENT_INITIAL_LIQUIDITY_HOLDER,\n      initialMarketSeedForEachMarketSide\n    );\n\n    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;\n    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;\n\n    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);\n  }\n\n  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.\n  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.\n  /// @param marketIndex An int32 which uniquely identifies the market.\n  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.\n  /// @param kPeriod Time which kInitialMultiplier will last\n  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.\n  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs\n  /// for market sides in unbalanced markets. See Staker.sol\n  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets\n  /// when Float token issuance should differ for market sides. See Staker.sol\n  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.\n  function initializeMarket(\n    uint32 marketIndex,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 initialMarketSeedForEachMarketSide,\n    uint256 balanceIncentiveCurve_exponent,\n    int256 balanceIncentiveCurve_equilibriumOffset,\n    uint256 _marketTreasurySplitGradient_e18\n  ) external adminOnly {\n    require(!marketExists[marketIndex], "already initialized");\n    require(marketIndex &lt;= latestMarket, "index too high");\n\n    marketExists[marketIndex] = true;\n\n    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    marketUpdateIndex[marketIndex] = 1;\n\n    // Add new staker funds with fresh synthetic tokens.\n    IStaker(staker).addNewStakingFund(\n      latestMarket,\n      syntheticTokens[latestMarket][true],\n      syntheticTokens[latestMarket][false],\n      kInitialMultiplier,\n      kPeriod,\n      unstakeFee_e18,\n      balanceIncentiveCurve_exponent,\n      balanceIncentiveCurve_equilibriumOffset\n    );\n\n    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);\n  }\n\n  /╔══════════════════════════════╗\n    ║       GETTER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.\n  /// @param a Any uint256\n  /// @param b Any uint256\n  /// @return min The minimum of the 2 parameters.\n  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {\n    if (a &gt; b) {\n      return b;\n    } else {\n      return a;\n    }\n  }\n\n  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.\n  /// @dev Synth tokens have a fixed 18 decimals.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.\n  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)\n    internal\n    pure\n    virtual\n    returns (uint256 syntheticTokenPrice)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;\n  }\n\n  /// @notice Converts synth token amounts to payment token amounts at a synth token price.\n  /// @dev Price assumed base 1e18.\n  /// @param amountSyntheticToken Amount of synth token in wei.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountPaymentToken The calculated amount of payment tokens in token\'s lowest denomination.\n  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountPaymentToken)\n  {\n    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;\n  }\n\n  /// @notice Converts payment token amounts to synth token amounts at a synth token price.\n  /// @dev  Price assumed base 1e18.\n  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token\'s lowest denomination.\n  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.\n  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.\n  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)\n    internal\n    pure\n    virtual\n    returns (uint256 amountSyntheticToken)\n  {\n    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;\n  }\n\n  /\n  @notice Calculate the amount of target side synthetic tokens that are worth the same\n          amount of payment tokens as X many synthetic tokens on origin side.\n          The resulting equation comes from simplifying this function\n\n            _getAmountSyntheticToken(\n              _getAmountPaymentToken(\n                amountOriginSynth,\n                priceOriginSynth\n              ),\n              priceTargetSynth)\n\n            Unpacking the function we get:\n            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth\n              And simplifying this we get:\n            (amountOriginSynth * priceOriginSynth) / priceTargetSynth\n  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side\n  @param syntheticTokenPrice_originSide Price of origin side\'s synthetic token\n  @param syntheticTokenPrice_targetSide Price of target side\'s synthetic token\n  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side\n  /\n  function _getEquivalentAmountSyntheticTokensOnTargetSide(\n    uint256 amountSyntheticTokens_originSide,\n    uint256 syntheticTokenPrice_originSide,\n    uint256 syntheticTokenPrice_targetSide\n  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {\n    equivalentAmountSyntheticTokensOnTargetSide =\n      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /\n      syntheticTokenPrice_targetSide;\n  }\n\n  /// @notice Given an executed next price shift from tokens on one market side to the other,\n  /// determines how many other side tokens the shift was worth.\n  /// @dev Intended for use primarily by Staker.sol\n  /// @param marketIndex An uint32 which uniquely identifies a market.\n  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  /// @param priceSnapshotIndex Index which identifies which synth prices to use.\n  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.\n  function getAmountSyntheticTokenToMintOnTargetSide(\n    uint32 marketIndex,\n    uint256 amountSyntheticToken_redeemOnOriginSide,\n    bool isShiftFromLong,\n    uint256 priceSnapshotIndex\n  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {\n    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][\n      priceSnapshotIndex\n    ];\n    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][\n      priceSnapshotIndex\n    ];\n\n    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(\n      amountSyntheticToken_redeemOnOriginSide,\n      syntheticTokenPriceOnOriginSide,\n      syntheticTokenPriceOnTargetSide\n    );\n  }\n\n  /\n  @notice The amount of a synth token a user is owed following a batch execution.\n    4 possible states for next price actions:\n        - "Pending" - means the next price update hasn\'t happened or been enacted on by the updateSystemState function.\n        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still\n        -               outstanding (lazy) computation that needs to be executed per user in the batch.\n        - "Settled" - there is no more computation left for the user.\n        - "Non-existant" - user has no next price actions.\n    This function returns a calculated value only in the case of \'confirmed\' next price actions.\n    It should return zero for all other types of next price actions.\n  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.\n  @param user The address of the user for whom to execute the function for.\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.\n  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.\n  /\n  function getUsersConfirmedButNotSettledSynthBalance(\n    address user,\n    uint32 marketIndex,\n    bool isLong\n  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {\n    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];\n    if (\n      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;\n      userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex\n    ) {\n      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n\n      if (amountPaymentTokenDeposited &gt; 0) {\n        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];\n\n        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);\n      }\n\n\n        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide\n       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];\n\n      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {\n        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][\n          currentMarketUpdateIndex\n        ];\n        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][\n          currentMarketUpdateIndex\n        ];\n\n        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountSyntheticTokensToBeShiftedAwayFromOriginSide,\n          syntheticTokenPriceOnOriginSide,\n          syntheticTokenPriceOnTargetSide\n        );\n      }\n    }\n  }\n\n  /\n   @notice Calculates the percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   @dev For gas considerations also returns whether the long side is imbalanced.\n   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function\n   calling this function has pre calculated the value\n   @param longValue The current total payment token value of the long side of the market.\n   @param shortValue The current total payment token value of the short side of the market.\n   @param totalValueLockedInMarket Total payment token value of both sides of the market.\n   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.\n   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield\n   for a market should be allocated to treasury.\n   /\n  function _getYieldSplit(\n    uint32 marketIndex,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 totalValueLockedInMarket\n  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {\n    isLongSideUnderbalanced = longValue &lt; shortValue;\n    uint256 imbalance;\n\n    if (isLongSideUnderbalanced) {\n      imbalance = shortValue - longValue;\n    } else {\n      imbalance = longValue - shortValue;\n    }\n\n    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given\n    // to the market at a desired rate e.g. if a market tends to become imbalanced\n    // frequently then the gradient can be increased to funnel yield to the market\n    // quicker.\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x\n    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b\n    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /\n      totalValueLockedInMarket;\n\n    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);\n\n    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;\n  }\n\n  /╔══════════════════════════════╗\n    ║       HELPER FUNCTIONS       ║\n    ╚══════════════════════════════╝/\n\n  /// @notice First gets yield from the yield manager and allocates it to market and treasury.\n  /// It then allocates the full market yield portion to the underbalanced side of the market.\n  /// NB this function also adjusts the value of the long and short side based on the latest\n  /// price of the underlying asset received from the oracle. This function should ideally be\n  /// called everytime there is an price update from the oracle. We have built a bot that does this.\n  /// The system is still perectly safe if not called every price update, the synthetic will just\n  /// less closely track the underlying asset.\n  /// @dev In one function as yield should be allocated before rebalancing.\n  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.\n  /// @param marketIndex The market for which to execute the function for.\n  /// @param newAssetPrice The new asset price.\n  /// @param oldAssetPrice The old asset price.\n  /// @return longValue The value of the long side after rebalancing.\n  /// @return shortValue The value of the short side after rebalancing.\n  function _claimAndDistributeYieldThenRebalanceMarket(\n    uint32 marketIndex,\n    int256 newAssetPrice,\n    int256 oldAssetPrice\n  ) internal virtual returns (uint256 longValue, uint256 shortValue) {\n    // Claiming and distributing the yield\n    longValue = marketSideValueInPaymentToken[marketIndex][true];\n    shortValue = marketSideValueInPaymentToken[marketIndex][false];\n    uint256 totalValueLockedInMarket = longValue + shortValue;\n\n    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(\n      marketIndex,\n      longValue,\n      shortValue,\n      totalValueLockedInMarket\n    );\n\n    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])\n    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);\n\n    if (marketAmount &gt; 0) {\n      if (isLongSideUnderbalanced) {\n        longValue += marketAmount;\n      } else {\n        shortValue += marketAmount;\n      }\n    }\n\n    // Adjusting value of long and short pool based on price movement\n    // The side/position with less liquidity has 100% percent exposure to the price movement.\n    // The side/position with more liquidity will have exposure &lt; 100% to the price movement.\n    // I.e. Imagine $100 in longValue and $50 shortValue\n    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.\n    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then\n    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.\n    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));\n\n    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE\n    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq\n    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;\n\n    if (valueChange &gt; 0) {\n      longValue += uint256(valueChange);\n      shortValue -= uint256(valueChange);\n    } else {\n      longValue -= uint256(-valueChange);\n      shortValue += uint256(-valueChange);\n    }\n  }\n\n  /╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝/\n\n  /// @notice Updates the value of the long and short sides to account for latest oracle price updates\n  /// and batches all next price actions.\n  /// @dev To prevent front-running only executes on price change from an oracle.\n  /// We assume the function will be called for each market at least once per price update.\n  /// Note Even if not called on every price update, this won\'t affect security, it will only affect how closely\n  /// the synthetic asset actually tracks the underlying asset.\n  /// @param marketIndex The market index for which to update.\n  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n    // If a negative int is return this should fail.\n    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n    int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n\n    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n    if (assetPriceHasChanged || msg.sender == staker) {\n      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ];\n      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ];\n      // if there is a price change and the \'staker\' contract has pending updates, push the stakers price snapshot index to the staker\n      // (so the staker can handle its internal accounting)\n      if (\n        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;\n        assetPriceHasChanged\n      ) {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)\n          userNextPrice_currentUpdateIndex[marketIndex][staker]\n        );\n      } else {\n        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n          marketIndex,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short,\n          marketSideValueInPaymentToken[marketIndex][true],\n          marketSideValueInPaymentToken[marketIndex][false],\n          0\n        );\n      }\n\n      // function will return here if the staker called this simply for the\n      // purpose of adding a state point required in staker.sol for our rewards calculation\n      if (!assetPriceHasChanged) {\n        return;\n      }\n\n      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(\n        marketIndex,\n        newAssetPrice,\n        oldAssetPrice\n      );\n\n      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(\n        newLongPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()\n      );\n      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(\n        newShortPoolValue,\n        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()\n      );\n\n      assetPrice[marketIndex] = uint256(newAssetPrice);\n      marketUpdateIndex[marketIndex] += 1;\n\n      syntheticToken_priceSnapshot[marketIndex][true][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_long;\n\n      syntheticToken_priceSnapshot[marketIndex][false][\n        marketUpdateIndex[marketIndex]\n      ] = syntheticTokenPrice_inPaymentTokens_short;\n\n      (\n        int256 long_changeInMarketValue_inPaymentToken,\n        int256 short_changeInMarketValue_inPaymentToken\n      ) = _batchConfirmOutstandingPendingActions(\n        marketIndex,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n\n      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);\n      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);\n      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;\n      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;\n\n      emit SystemStateUpdated(\n        marketIndex,\n        marketUpdateIndex[marketIndex],\n        newAssetPrice,\n        newLongPoolValue,\n        newShortPoolValue,\n        syntheticTokenPrice_inPaymentTokens_long,\n        syntheticTokenPrice_inPaymentTokens_short\n      );\n    }\n  }\n\n  /// @notice Updates the state of a market to account for the latest oracle price update.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function updateSystemState(uint32 marketIndex) external override {\n    _updateSystemStateInternal(marketIndex);\n  }\n\n  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.\n  /// @param marketIndexes An array of int32s which uniquely identify markets.\n  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _updateSystemStateInternal(marketIndexes[i]);\n    }\n  }\n\n  /╔════════════════════════════════╗\n    ║           DEPOSIT              ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers payment tokens for a market from msg.sender to this contract.\n  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.\n  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationto deposit.\n  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {\n    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));\n  }\n\n  /╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  /// @param isLong Whether the mint is for a long or short synth.\n  function _mintNextPrice(\n    uint32 marketIndex,\n    uint256 amount,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);\n\n    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;\n    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, true);\n  }\n\n  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amount Amount of payment tokens in that token\'s lowest denominationfor which to mint synthetic assets at next price.\n  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {\n    _mintNextPrice(marketIndex, amount, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║      REDEEM POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem.\n  /// @param isLong Whether this redeem is for a long or short synth.\n  function _redeemNextPrice(\n    uint32 marketIndex,\n    uint256 tokens_redeem,\n    bool isLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)\n    );\n\n    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;\n\n    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);\n  }\n\n  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, true);\n  }\n\n  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.\n  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {\n    _redeemNextPrice(marketIndex, tokens_redeem, false);\n  }\n\n  /╔═══════════════════════════╗\n    ║       SHIFT POSITION      ║\n    ╚═══════════════════════════╝/\n\n  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.\n  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).\n  function _shiftPositionNextPrice(\n    uint32 marketIndex,\n    uint256 amountSyntheticTokensToShift,\n    bool isShiftFromLong\n  )\n    internal\n    virtual\n    updateSystemStateMarket(marketIndex)\n    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)\n  {\n    require(\n      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(\n        msg.sender,\n        address(this),\n        amountSyntheticTokensToShift\n      )\n    );\n\n    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][\n      msg.sender\n    ] += amountSyntheticTokensToShift;\n    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;\n\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      isShiftFromLong\n    ] += amountSyntheticTokensToShift;\n\n    emit NextPriceSyntheticPositionShift(\n      marketIndex,\n      isShiftFromLong,\n      amountSyntheticTokensToShift,\n      msg.sender,\n      marketUpdateIndex[marketIndex] + 1\n    );\n  }\n\n  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.\n  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);\n  }\n\n  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.\n  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {\n    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);\n  }\n\n  /╔════════════════════════════════╗\n    ║     NEXT PRICE SETTLEMENTS     ║\n    ╚════════════════════════════════╝/\n\n  /// @notice Transfers outstanding synth tokens from a next price mint to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceMints(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];\n    if (currentPaymentTokenDepositAmount &gt; 0) {\n      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;\n      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(\n        currentPaymentTokenDepositAmount,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)\n      );\n\n      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);\n    }\n  }\n\n  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isLong Whether this is for the long or short synth for the market.\n  function _executeOutstandingNextPriceRedeems(\n    uint32 marketIndex,\n    address user,\n    bool isLong\n  ) internal virtual {\n    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];\n    if (currentSyntheticTokenRedemptions &gt; 0) {\n      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;\n      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(\n        currentSyntheticTokenRedemptions,\n        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]\n      );\n\n      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);\n\n      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);\n    }\n  }\n\n  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.\n  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).\n  function _executeOutstandingNextPriceTokenShifts(\n    uint32 marketIndex,\n    address user,\n    bool isShiftFromLong\n  ) internal virtual {\n    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[\n      marketIndex\n    ][isShiftFromLong][user];\n    if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {\n      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(\n        marketIndex,\n        syntheticToken_toShiftAwayFrom_marketSide,\n        isShiftFromLong,\n        userNextPrice_currentUpdateIndex[marketIndex][user]\n      );\n\n      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;\n\n      require(\n        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(\n          user,\n          syntheticToken_toShiftTowardsTargetSide\n        )\n      );\n\n      emit ExecuteNextPriceMarketSideShiftSettlementUser(\n        user,\n        marketIndex,\n        isShiftFromLong,\n        syntheticToken_toShiftTowardsTargetSide\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n    if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {\n      _executeOutstandingNextPriceMints(marketIndex, user, true);\n      _executeOutstandingNextPriceMints(marketIndex, user, false);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n      _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n\n      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;\n\n      emit ExecuteNextPriceSettlementsUser(user, marketIndex);\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {\n    _executeOutstandingNextPriceSettlements(user, marketIndex);\n  }\n\n  /// @notice Executes outstanding next price settlements for a user for multiple markets.\n  /// @param user The address of the user for whom to execute the function for.\n  /// @param marketIndexes An array of int32s which each uniquely identify a market.\n  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);\n    }\n  }\n\n  /╔═══════════════════════════════════════════╗\n    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║\n    ╚═══════════════════════════════════════════╝*/\n\n  /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,\n  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.\n  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.\n  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n    uint32 marketIndex,\n    int256 totalPaymentTokenValueChangeForMarket\n  ) internal virtual {\n    if (totalPaymentTokenValueChangeForMarket &gt; 0) {\n      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));\n    } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {\n      // NB there will be issues here if not enough liquidity exists to withdraw\n      // Boolean should be returned from yield manager and think how to appropriately handle this\n      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(\n        uint256(-totalPaymentTokenValueChangeForMarket)\n      );\n    }\n  }\n\n  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.\n  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.\n  /// @param marketIndex An int32 which uniquely identifies a market.\n  /// @param isLong Whether this function should execute for the long or short synth for the market.\n  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.\n  function _handleChangeInSyntheticTokensTotalSupply(\n    uint32 marketIndex,\n    bool isLong,\n    int256 changeInSyntheticTokensTotalSupply\n  ) internal virtual {\n    if (changeInSyntheticTokensTotalSupply &gt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(\n        address(this),\n        uint256(changeInSyntheticTokensTotalSupply)\n      );\n    } else if (changeInSyntheticTokensTotalSupply &lt; 0) {\n      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));\n    }\n  }\n\n  /\n  @notice Performs all batched next price actions on an oracle price update.\n  @dev Mints or burns all synthetic tokens for this contract.\n\n    After this function is executed all user actions in that batch are confirmed and can be settled individually by\n      calling _executeOutstandingNexPriceSettlements for a given user.\n\n    The maths here is safe from rounding errors since it always over estimates on the batch with division.\n      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)\n  @param marketIndex An int32 which uniquely identifies a market.\n  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.\n  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.\n  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.\n  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.\n  */\n  function _batchConfirmOutstandingPendingActions(\n    uint32 marketIndex,\n    uint256 syntheticTokenPrice_inPaymentTokens_long,\n    uint256 syntheticTokenPrice_inPaymentTokens_short\n  )\n    internal\n    virtual\n    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)\n  {\n    int256 changeInSupply_syntheticToken_long;\n    int256 changeInSupply_syntheticToken_short;\n\n    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage\n    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];\n\n    // Handle batched deposits LONG\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][true] = 0;\n\n      changeInSupply_syntheticToken_long = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n    }\n\n    // Handle batched deposits SHORT\n    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);\n\n      batched_amountPaymentToken_deposit[marketIndex][false] = 0;\n\n      changeInSupply_syntheticToken_short = int256(\n        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n    }\n\n    // Handle shift tokens from LONG to SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToShort = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n\n      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;\n      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;\n\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_short += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_long,\n          syntheticTokenPrice_inPaymentTokens_short\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle shift tokens from SHORT to LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][\n      false\n    ];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      int256 paymentTokenValueChangeForShiftToLong = int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n\n      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;\n      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;\n\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n      changeInSupply_syntheticToken_long += int256(\n        _getEquivalentAmountSyntheticTokensOnTargetSide(\n          amountForCurrentAction_workingVariable,\n          syntheticTokenPrice_inPaymentTokens_short,\n          syntheticTokenPrice_inPaymentTokens_long\n        )\n      );\n\n      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems LONG\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      long_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)\n      );\n      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;\n    }\n\n    // Handle batched redeems SHORT\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];\n    if (amountForCurrentAction_workingVariable &gt; 0) {\n      short_changeInMarketValue_inPaymentToken -= int256(\n        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)\n      );\n      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);\n\n      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;\n    }\n\n    // Batch settle payment tokens\n    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(\n      marketIndex,\n      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken\n    );\n    // Batch settle synthetic tokens\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);\n    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);\n  }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-17-08 08:04:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "./interfaces/ITokenFactory.sol"; import "./interfaces/ISyntheticToken.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IYieldManager.sol"; import "./interfaces/IOracleManager.sol"; /   visit https://float.capital **  / /// @title Core logic of Float Protocal markets /// @author float.capital /// @notice visit https://float.capital for more info /// @dev All functions in this file are currently virtual. This is NOT to encourage inheritance. /// It is merely for convenince when unit testing. /// @custom:auditors This contract balances long and short sides. contract LongShort is ILongShort, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   /// @notice this is the address that permanently locked initial liquidity for markets is held by.   /// These tokens will never move so market can never have zero liquidity on a side.   /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.   address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7; /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:   ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361   uint256[45] private __constantsGap; / ══════ Global state ══════ /   address public admin;   address public treasury;   uint32 public latestMarket; address public staker;   address public tokenFactory;   uint256[45] private __globalStateGap; / ══════ Market specific ══════ /   mapping(uint32 =&gt; bool) public marketExists;   mapping(uint32 =&gt; uint256) public assetPrice;   mapping(uint32 =&gt; uint256) public marketUpdateIndex;   mapping(uint32 =&gt; address) public paymentTokens;   mapping(uint32 =&gt; address) public yieldManagers;   mapping(uint32 =&gt; address) public oracleManagers;   mapping(uint32 =&gt; uint256) public marketTreasurySplitGradient_e18; / ══════ Market + position (long/short) specific ══════ /   mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public marketSideValueInPaymentToken; /// @notice synthetic token prices of a given market of a (long/short) at every previous price update   mapping(uint32 =&gt; mapping(bool =&gt; mapping(uint256 =&gt; uint256))) public syntheticToken_priceSnapshot; mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountPaymentToken_deposit;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_redeem;   mapping(uint32 =&gt; mapping(bool =&gt; uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide; / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_currentUpdateIndex; mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_paymentToken_depositAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256))) public userNextPrice_syntheticToken_redeemAmount;   mapping(uint32 =&gt; mapping(bool =&gt; mapping(address =&gt; uint256)))     public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event LongShortV1(address admin, address treasury, address tokenFactory, address staker); event SystemStateUpdated(     uint32 marketIndex,     uint256 updateIndex,     int256 underlyingAssetPrice,     uint256 longValue,     uint256 shortValue,     uint256 longPrice,     uint256 shortPrice   ); event SyntheticMarketCreated(     uint32 marketIndex,     address longTokenAddress,     address shortTokenAddress,     address paymentToken,     uint256 initialAssetPrice,     string name,     string symbol,     address oracleAddress,     address yieldManagerAddress   ); event NextPriceRedeem(     uint32 marketIndex,     bool isLong,     uint256 synthRedeemed,     address user,     uint256 oracleUpdateIndex   ); event NextPriceSyntheticPositionShift(     uint32 marketIndex,     bool isShiftFromLong,     uint256 synthShifted,     address user,     uint256 oracleUpdateIndex   ); event NextPriceDeposit(     uint32 marketIndex,     bool isLong,     uint256 depositAdded,     address user,     uint256 oracleUpdateIndex   ); event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress); event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed); event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount); event ExecuteNextPriceMarketSideShiftSettlementUser(     address user,     uint32 marketIndex,     bool isShiftFromLong,     uint256 amount   ); event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function adminOnlyModifierLogic() internal virtual {     require(msg.sender == admin, "only admin");   } modifier adminOnly() {     adminOnlyModifierLogic();     _;   } function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {     require(marketExists[marketIndex], "market doesn't exist");   } modifier requireMarketExists(uint32 marketIndex) {     requireMarketExistsModifierLogic(marketIndex);     _;   } modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {     executeOutstandingNextPriceSettlements(user, marketIndex);     ;   } modifier updateSystemStateMarket(uint32 marketIndex) {     updateSystemStateInternal(marketIndex);     ;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /// @notice Initializes the contract.   /// @dev Calls OpenZeppelin's initializer modifier.   /// @param _admin Address of the admin role.   /// @param _treasury Address of the treasury.   /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.   /// @param _staker Address of the contract which handles synthetic asset stakes.   function initialize(     address _admin,     address _treasury,     address _tokenFactory,     address _staker   ) external virtual initializer {     admin = _admin;     treasury = _treasury;     tokenFactory = _tokenFactory;     staker = _staker; emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /// @notice Changes the admin address for this contract.   /// @dev Can only be called by the current admin.   /// @param _admin Address of the new admin.   function changeAdmin(address _admin) external adminOnly {     admin = _admin;   } /// @notice Changes the treasury contract address for this contract.   /// @dev Can only be called by the current admin.   /// @param _treasury Address of the treasury contract   function changeTreasury(address _treasury) external adminOnly {     treasury = _treasury;   } /// @notice Update oracle for a market   /// @dev Can only be called by the current admin.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param _newOracleManager Address of the replacement oracle manager.   function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {     // If not a oracle contract this would break things.. Test's arn't validating this     // Ie require isOracle interface - ERC165     address previousOracleManager = oracleManagers[marketIndex];     oracleManagers[marketIndex] = _newOracleManager;     emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);   } /// @notice changes the gradient of the line for determining the yield split between market and treasury.   function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)     external     adminOnly   {     marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;   } /╔═════════════════════════════╗     ║       MARKET CREATION       ║     ╚═════════════════════════════╝/ /// @notice Creates an entirely new long/short market tracking an underlying oracle price.   ///  Make sure the synthetic names/symbols are unique.   /// @dev This does not make the market active.   /// The initializeMarket function was split out separately to this function to reduce costs.   /// @param syntheticName Name of the synthetic asset   /// @param syntheticSymbol Symbol for the synthetic asset   /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset   /// this will likely always be DAI   /// @param _oracleManager The address of the oracle manager that provides the price feed for this market   /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol   function createNewSyntheticMarket(     string calldata syntheticName,     string calldata syntheticSymbol,     address _paymentToken,     address _oracleManager,     address _yieldManager   ) external adminOnly {     latestMarket++; // Create new synthetic long token. syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Up ", syntheticName)),   string(abi.encodePacked("fu", syntheticSymbol)),   staker,   latestMarket,   true );  // Create new synthetic short token. syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(   string(abi.encodePacked("Float Down ", syntheticName)),   string(abi.encodePacked("fd", syntheticSymbol)),   staker,   latestMarket,   false );  // Initial market state. paymentTokens[latestMarket] = _paymentToken; yieldManagers[latestMarket] = _yieldManager; oracleManagers[latestMarket] = _oracleManager; assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());  emit SyntheticMarketCreated(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   _paymentToken,   assetPrice[latestMarket],   syntheticName,   syntheticSymbol,   _oracleManager,   _yieldManager );  } /// @notice Seeds a new market with initial capital.   /// @dev Only called when initializing a market.   /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.   /// @param marketIndex An int32 which uniquely identifies a market.   function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {     require(       // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.       initialMarketSeedForEachMarketSide &gt;= 1e18,       "Insufficient market seed"     ); uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2; _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager); IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide ); ISyntheticToken(syntheticTokens[latestMarket][false]).mint(   PERMANENT_INITIAL_LIQUIDITY_HOLDER,   initialMarketSeedForEachMarketSide );  marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide; marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;  emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);  } /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.   /// @dev Seperated from createNewSyntheticMarket due to gas considerations.   /// @param marketIndex An int32 which uniquely identifies the market.   /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.   /// @param kPeriod Time which kInitialMultiplier will last   /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.   /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs   /// for market sides in unbalanced markets. See Staker.sol   /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets   /// when Float token issuance should differ for market sides. See Staker.sol   /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.   function initializeMarket(     uint32 marketIndex,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 initialMarketSeedForEachMarketSide,     uint256 balanceIncentiveCurve_exponent,     int256 balanceIncentiveCurve_equilibriumOffset,     uint256 _marketTreasurySplitGradient_e18   ) external adminOnly {     require(!marketExists[marketIndex], "already initialized");     require(marketIndex &lt;= latestMarket, "index too high"); marketExists[marketIndex] = true;  marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;  // Set this value to one initially - 0 is a null value and thus potentially bug prone. marketUpdateIndex[marketIndex] = 1;  // Add new staker funds with fresh synthetic tokens. IStaker(staker).addNewStakingFund(   latestMarket,   syntheticTokens[latestMarket][true],   syntheticTokens[latestMarket][false],   kInitialMultiplier,   kPeriod,   unstakeFee_e18,   balanceIncentiveCurve_exponent,   balanceIncentiveCurve_equilibriumOffset );  _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);  } /╔══════════════════════════════╗     ║       GETTER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.   /// @param a Any uint256   /// @param b Any uint256   /// @return min The minimum of the 2 parameters.   function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {     if (a &gt; b) {       return b;     } else {       return a;     }   } /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.   /// @dev Synth tokens have a fixed 18 decimals.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.   function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)     internal     pure     virtual     returns (uint256 syntheticTokenPrice)   {     return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;   } /// @notice Converts synth token amounts to payment token amounts at a synth token price.   /// @dev Price assumed base 1e18.   /// @param amountSyntheticToken Amount of synth token in wei.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.   function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountPaymentToken)   {     return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;   } /// @notice Converts payment token amounts to synth token amounts at a synth token price.   /// @dev  Price assumed base 1e18.   /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.   /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.   /// @return amountSyntheticToken The calculated amount of synthetic token in wei.   function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)     internal     pure     virtual     returns (uint256 amountSyntheticToken)   {     return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;   } /**   @notice Calculate the amount of target side synthetic tokens that are worth the same           amount of payment tokens as X many synthetic tokens on origin side.           The resulting equation comes from simplifying this function         _getAmountSyntheticToken(           _getAmountPaymentToken(             amountOriginSynth,             priceOriginSynth           ),           priceTargetSynth)          Unpacking the function we get:         ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth           And simplifying this we get:         (amountOriginSynth * priceOriginSynth) / priceTargetSynth  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side   @param syntheticTokenPrice_originSide Price of origin side's synthetic token   @param syntheticTokenPrice_targetSide Price of target side's synthetic token   @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side   */   function _getEquivalentAmountSyntheticTokensOnTargetSide(     uint256 amountSyntheticTokens_originSide,     uint256 syntheticTokenPrice_originSide,     uint256 syntheticTokenPrice_targetSide   ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {     equivalentAmountSyntheticTokensOnTargetSide =       (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /       syntheticTokenPrice_targetSide;   } /// @notice Given an executed next price shift from tokens on one market side to the other,   /// determines how many other side tokens the shift was worth.   /// @dev Intended for use primarily by Staker.sol   /// @param marketIndex An uint32 which uniquely identifies a market.   /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   /// @param priceSnapshotIndex Index which identifies which synth prices to use.   /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.   function getAmountSyntheticTokenToMintOnTargetSide(     uint32 marketIndex,     uint256 amountSyntheticToken_redeemOnOriginSide,     bool isShiftFromLong,     uint256 priceSnapshotIndex   ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][       priceSnapshotIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][       priceSnapshotIndex     ]; amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(   amountSyntheticToken_redeemOnOriginSide,   syntheticTokenPriceOnOriginSide,   syntheticTokenPriceOnTargetSide );  } /*   @notice The amount of a synth token a user is owed following a batch execution.     4 possible states for next price actions:         - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.         - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still         -               outstanding (lazy) computation that needs to be executed per user in the batch.         - "Settled" - there is no more computation left for the user.         - "Non-existant" - user has no next price actions.     This function returns a calculated value only in the case of 'confirmed' next price actions.     It should return zero for all other types of next price actions.   @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.   @param user The address of the user for whom to execute the function for.   @param marketIndex An int32 which uniquely identifies a market.   @param isLong Whether it is for the long synthetic asset or the short synthetic asset.   @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.   /   function getUsersConfirmedButNotSettledSynthBalance(     address user,     uint32 marketIndex,     bool isLong   ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {     uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];     if (       userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &amp;&amp;       userNextPrice_currentUpdateIndex[marketIndex][user] &lt;= currentMarketUpdateIndex     ) {       uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];   if (amountPaymentTokenDeposited &gt; 0) {     uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];      confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);   }       uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide    = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];    if (amountSyntheticTokensToBeShiftedAwayFromOriginSide &gt; 0) {     uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][       currentMarketUpdateIndex     ];     uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][       currentMarketUpdateIndex     ];      confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(       amountSyntheticTokensToBeShiftedAwayFromOriginSide,       syntheticTokenPriceOnOriginSide,       syntheticTokenPriceOnTargetSide     );   } }  } /*    @notice Calculates the percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    @dev For gas considerations also returns whether the long side is imbalanced.    @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function    calling this function has pre calculated the value    @param longValue The current total payment token value of the long side of the market.    @param shortValue The current total payment token value of the short side of the market.    @param totalValueLockedInMarket Total payment token value of both sides of the market.    @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.    @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield    for a market should be allocated to treasury.    /   function _getYieldSplit(     uint32 marketIndex,     uint256 longValue,     uint256 shortValue,     uint256 totalValueLockedInMarket   ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {     isLongSideUnderbalanced = longValue &lt; shortValue;     uint256 imbalance; if (isLongSideUnderbalanced) {   imbalance = shortValue - longValue; } else {   imbalance = longValue - shortValue; }  // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given // to the market at a desired rate e.g. if a market tends to become imbalanced // frequently then the gradient can be increased to funnel yield to the market // quicker. // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /   totalValueLockedInMarket;  uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);  treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;  } /╔══════════════════════════════╗     ║       HELPER FUNCTIONS       ║     ╚══════════════════════════════╝/ /// @notice First gets yield from the yield manager and allocates it to market and treasury.   /// It then allocates the full market yield portion to the underbalanced side of the market.   /// NB this function also adjusts the value of the long and short side based on the latest   /// price of the underlying asset received from the oracle. This function should ideally be   /// called everytime there is an price update from the oracle. We have built a bot that does this.   /// The system is still perectly safe if not called every price update, the synthetic will just   /// less closely track the underlying asset.   /// @dev In one function as yield should be allocated before rebalancing.   /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.   /// @param marketIndex The market for which to execute the function for.   /// @param newAssetPrice The new asset price.   /// @param oldAssetPrice The old asset price.   /// @return longValue The value of the long side after rebalancing.   /// @return shortValue The value of the short side after rebalancing.   function _claimAndDistributeYieldThenRebalanceMarket(     uint32 marketIndex,     int256 newAssetPrice,     int256 oldAssetPrice   ) internal virtual returns (uint256 longValue, uint256 shortValue) {     // Claiming and distributing the yield     longValue = marketSideValueInPaymentToken[marketIndex][true];     shortValue = marketSideValueInPaymentToken[marketIndex][false];     uint256 totalValueLockedInMarket = longValue + shortValue; (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(   marketIndex,   longValue,   shortValue,   totalValueLockedInMarket );  uint256 marketAmount = IYieldManager(yieldManagers[marketIndex]) .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);  if (marketAmount &gt; 0) {   if (isLongSideUnderbalanced) {     longValue += marketAmount;   } else {     shortValue += marketAmount;   } }  // Adjusting value of long and short pool based on price movement // The side/position with less liquidity has 100% percent exposure to the price movement. // The side/position with more liquidity will have exposure &lt; 100% to the price movement. // I.e. Imagine $100 in longValue and $50 shortValue // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance. // min(longValue, shortValue) = $50 , therefore if the price change was -10% then // $50 * 10% = $5 gained for short side and conversely $5 lost for long side. int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));  // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;  if (valueChange &gt; 0) {   longValue += uint256(valueChange);   shortValue -= uint256(valueChange); } else {   longValue -= uint256(-valueChange);   shortValue += uint256(-valueChange); }  } /╔═══════════════════════════════╗     ║     UPDATING SYSTEM STATE     ║     ╚═══════════════════════════════╝/ /// @notice Updates the value of the long and short sides to account for latest oracle price updates   /// and batches all next price actions.   /// @dev To prevent front-running only executes on price change from an oracle.   /// We assume the function will be called for each market at least once per price update.   /// Note Even if not called on every price update, this won't affect security, it will only affect how closely   /// the synthetic asset actually tracks the underlying asset.   /// @param marketIndex The market index for which to update.   function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {     // If a negative int is return this should fail.     int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();     int256 oldAssetPrice = int256(assetPrice[marketIndex]); bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;  if (assetPriceHasChanged || msg.sender == staker) {   uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ];   uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ];   // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker   // (so the staker can handle its internal accounting)   if (     userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &amp;&amp;     assetPriceHasChanged   ) {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)       userNextPrice_currentUpdateIndex[marketIndex][staker]     );   } else {     IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(       marketIndex,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short,       marketSideValueInPaymentToken[marketIndex][true],       marketSideValueInPaymentToken[marketIndex][false],       0     );   }    // function will return here if the staker called this simply for the   // purpose of adding a state point required in staker.sol for our rewards calculation   if (!assetPriceHasChanged) {     return;   }    (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(     marketIndex,     newAssetPrice,     oldAssetPrice   );    syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(     newLongPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()   );   syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(     newShortPoolValue,     ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()   );    assetPrice[marketIndex] = uint256(newAssetPrice);   marketUpdateIndex[marketIndex] += 1;    syntheticToken_priceSnapshot[marketIndex][true][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_long;    syntheticToken_priceSnapshot[marketIndex][false][     marketUpdateIndex[marketIndex]   ] = syntheticTokenPrice_inPaymentTokens_short;    (     int256 long_changeInMarketValue_inPaymentToken,     int256 short_changeInMarketValue_inPaymentToken   ) = _batchConfirmOutstandingPendingActions(     marketIndex,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   );    newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);   newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);   marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;   marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;    emit SystemStateUpdated(     marketIndex,     marketUpdateIndex[marketIndex],     newAssetPrice,     newLongPoolValue,     newShortPoolValue,     syntheticTokenPrice_inPaymentTokens_long,     syntheticTokenPrice_inPaymentTokens_short   ); }  } /// @notice Updates the state of a market to account for the latest oracle price update.   /// @param marketIndex An int32 which uniquely identifies a market.   function updateSystemState(uint32 marketIndex) external override {     _updateSystemStateInternal(marketIndex);   } /// @notice Updates the state of multiples markets to account for their latest oracle price updates.   /// @param marketIndexes An array of int32s which uniquely identify markets.   function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _updateSystemStateInternal(marketIndexes[i]);     }   } /╔════════════════════════════════╗     ║           DEPOSIT              ║     ╚════════════════════════════════╝/ /// @notice Transfers payment tokens for a market from msg.sender to this contract.   /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.   ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.   function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {     require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));   } /╔═══════════════════════════╗     ║       MINT POSITION       ║     ╚═══════════════════════════╝/ /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   /// @param isLong Whether the mint is for a long or short synth.   function _mintNextPrice(     uint32 marketIndex,     uint256 amount,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     _transferPaymentTokensFromUserToYieldManager(marketIndex, amount); batched_amountPaymentToken_deposit[marketIndex][isLong] += amount; userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, true);   } /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.   function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {     _mintNextPrice(marketIndex, amount, false);   } /╔═══════════════════════════╗     ║      REDEEM POSITION      ║     ╚═══════════════════════════╝/ /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem.   /// @param isLong Whether this redeem is for a long or short synth.   function _redeemNextPrice(     uint32 marketIndex,     uint256 tokens_redeem,     bool isLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)     ); userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;  emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);  } /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, true);   } /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.   function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {     _redeemNextPrice(marketIndex, tokens_redeem, false);   } /╔═══════════════════════════╗     ║       SHIFT POSITION      ║     ╚═══════════════════════════╝/ /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.   /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).   function _shiftPositionNextPrice(     uint32 marketIndex,     uint256 amountSyntheticTokensToShift,     bool isShiftFromLong   )     internal     virtual     updateSystemStateMarket(marketIndex)     executeOutstandingNextPriceSettlements(msg.sender, marketIndex)   {     require(       ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(         msg.sender,         address(this),         amountSyntheticTokensToShift       )     ); userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][   msg.sender ] += amountSyntheticTokensToShift; userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;  batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   isShiftFromLong ] += amountSyntheticTokensToShift;  emit NextPriceSyntheticPositionShift(   marketIndex,   isShiftFromLong,   amountSyntheticTokensToShift,   msg.sender,   marketUpdateIndex[marketIndex] + 1 );  } /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.   function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);   } /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.   function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {     _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);   } /╔════════════════════════════════╗     ║     NEXT PRICE SETTLEMENTS     ║     ╚════════════════════════════════╝/ /// @notice Transfers outstanding synth tokens from a next price mint to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceMints(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];     if (currentPaymentTokenDepositAmount &gt; 0) {       userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;       uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(         currentPaymentTokenDepositAmount,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );       require(         ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)       );   emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser); }  } /// @notice Transfers outstanding payment tokens from a next price redemption to the user.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isLong Whether this is for the long or short synth for the market.   function _executeOutstandingNextPriceRedeems(     uint32 marketIndex,     address user,     bool isLong   ) internal virtual {     uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];     if (currentSyntheticTokenRedemptions &gt; 0) {       userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;       uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(         currentSyntheticTokenRedemptions,         syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]       );   IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);    emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem); }  } /// @notice Transfers outstanding synth tokens from a next price position shift to the user.   /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param user The address of the user for whom to execute the function for.   /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).   function _executeOutstandingNextPriceTokenShifts(     uint32 marketIndex,     address user,     bool isShiftFromLong   ) internal virtual {     uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[       marketIndex     ][isShiftFromLong][user];     if (syntheticToken_toShiftAwayFrom_marketSide &gt; 0) {       uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(         marketIndex,         syntheticToken_toShiftAwayFrom_marketSide,         isShiftFromLong,         userNextPrice_currentUpdateIndex[marketIndex][user]       );   userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;    require(     ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(       user,       syntheticToken_toShiftTowardsTargetSide     )   );    emit ExecuteNextPriceMarketSideShiftSettlementUser(     user,     marketIndex,     isShiftFromLong,     syntheticToken_toShiftTowardsTargetSide   ); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {     uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];     if (userCurrentUpdateIndex != 0 &amp;&amp; userCurrentUpdateIndex &lt;= marketUpdateIndex[marketIndex]) {       _executeOutstandingNextPriceMints(marketIndex, user, true);       _executeOutstandingNextPriceMints(marketIndex, user, false);       _executeOutstandingNextPriceRedeems(marketIndex, user, true);       _executeOutstandingNextPriceRedeems(marketIndex, user, false);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);       _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);   userNextPrice_currentUpdateIndex[marketIndex][user] = 0;    emit ExecuteNextPriceSettlementsUser(user, marketIndex); }  } /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndex An int32 which uniquely identifies a market.   function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {     _executeOutstandingNextPriceSettlements(user, marketIndex);   } /// @notice Executes outstanding next price settlements for a user for multiple markets.   /// @param user The address of the user for whom to execute the function for.   /// @param marketIndexes An array of int32s which each uniquely identify a market.   function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);     }   } /╔═══════════════════════════════════════════╗     ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║     ╚═══════════════════════════════════════════╝/ /// @notice Either transfers funds from the yield manager to this contract if redeems &gt; deposits,   /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.   /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.   function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(     uint32 marketIndex,     int256 totalPaymentTokenValueChangeForMarket   ) internal virtual {     if (totalPaymentTokenValueChangeForMarket &gt; 0) {       IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));     } else if (totalPaymentTokenValueChangeForMarket &lt; 0) {       // NB there will be issues here if not enough liquidity exists to withdraw       // Boolean should be returned from yield manager and think how to appropriately handle this       IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(         uint256(-totalPaymentTokenValueChangeForMarket)       );     }   } /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.   /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.   /// @param marketIndex An int32 which uniquely identifies a market.   /// @param isLong Whether this function should execute for the long or short synth for the market.   /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.   function _handleChangeInSyntheticTokensTotalSupply(     uint32 marketIndex,     bool isLong,     int256 changeInSyntheticTokensTotalSupply   ) internal virtual {     if (changeInSyntheticTokensTotalSupply &gt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(         address(this),         uint256(changeInSyntheticTokensTotalSupply)       );     } else if (changeInSyntheticTokensTotalSupply &lt; 0) {       ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));     }   } /**   @notice Performs all batched next price actions on an oracle price update.   @dev Mints or burns all synthetic tokens for this contract. After this function is executed all user actions in that batch are confirmed and can be settled individually by   calling _executeOutstandingNexPriceSettlements for a given user.  The maths here is safe from rounding errors since it always over estimates on the batch with division.   (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)  @param marketIndex An int32 which uniquely identifies a market.   @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.   @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.   @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.   @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.   */   function _batchConfirmOutstandingPendingActions(     uint32 marketIndex,     uint256 syntheticTokenPrice_inPaymentTokens_long,     uint256 syntheticTokenPrice_inPaymentTokens_short   )     internal     virtual     returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)   {     int256 changeInSupply_syntheticToken_long;     int256 changeInSupply_syntheticToken_short; // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];  // Handle batched deposits LONG if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][true] = 0;    changeInSupply_syntheticToken_long = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   ); }  // Handle batched deposits SHORT amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);    batched_amountPaymentToken_deposit[marketIndex][false] = 0;    changeInSupply_syntheticToken_short = int256(     _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   ); }  // Handle shift tokens from LONG to SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToShort = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );    long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;   short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;    changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_short += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_long,       syntheticTokenPrice_inPaymentTokens_short     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle shift tokens from SHORT to LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][   false ]; if (amountForCurrentAction_workingVariable &gt; 0) {   int256 paymentTokenValueChangeForShiftToLong = int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );    short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;   long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;    changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);   changeInSupply_syntheticToken_long += int256(     _getEquivalentAmountSyntheticTokensOnTargetSide(       amountForCurrentAction_workingVariable,       syntheticTokenPrice_inPaymentTokens_short,       syntheticTokenPrice_inPaymentTokens_long     )   );    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; }  // Handle batched redeems LONG amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true]; if (amountForCurrentAction_workingVariable &gt; 0) {   long_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)   );   changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][true] = 0; }  // Handle batched redeems SHORT amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false]; if (amountForCurrentAction_workingVariable &gt; 0) {   short_changeInMarketValue_inPaymentToken -= int256(     _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)   );   changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);    batched_amountSyntheticToken_redeem[marketIndex][false] = 0; }  // Batch settle payment tokens _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(   marketIndex,   long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken ); // Batch settle synthetic tokens _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long); _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);  } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:04:20 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "./interfaces/ITokenFactory.sol";
import "./interfaces/ISyntheticToken.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IYieldManager.sol";
import "./interfaces/IOracleManager.sol";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, "only admin");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], "market doesn't exist");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Up ", syntheticName)),
      string(abi.encodePacked("fu", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked("Float Down ", syntheticName)),
      string(abi.encodePacked("fd", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      "Insufficient market seed"
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], "already initialized");
    require(marketIndex <= latestMarket, "index too high");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - "Pending" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - "Confirmed" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - "Settled" - there is no more computation left for the user.
        - "Non-existant" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

