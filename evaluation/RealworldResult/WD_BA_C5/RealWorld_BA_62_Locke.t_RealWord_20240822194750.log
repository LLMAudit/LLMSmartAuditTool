[2024-22-08 19:47:50 INFO] **[Preprocessing]**

**ChatDev Starts** (20240822194750)

**Timestamp**: 20240822194750

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}

**project_name**: RealWorld_BA_62_Locke.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_62_Locke.t_RealWord_20240822194750.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-22-08 19:47:50 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport "./utils/LockeTest.sol";\n\n\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint112 amt = 1337;\n        emit log_named_uint("blocktime", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n\n            // === Failures ===\n            bytes4 sig = sigs("fundStream(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                "time"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n\n            \n\n\n            // === No Fees ===\n\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream2", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n\n        alice.doExit(stream); \n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        testTokenB.approve(address(stream), type(uint256).max);\n\n        {\n            // Failures\n            bytes4 sig = sigs("stake(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "!stream"\n            );\n            hevm.warp(startTime - minStreamDuration);\n\n            write_balanceOf(address(testTokenB), address(stream), 2112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "erc"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n\n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n\n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n            hevm.warp(startTime + (2minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        bytes4 sig = sigs("createIncentive(address,uint112)");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            "inc"\n        );\n\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "lock"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "claimed"\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!creator"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_claimFees() public {\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n\n            bob.failClaimFees(stream);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs("claimFees(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, ""),\n                "erc"\n            );\n            \n\n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                "f4"\n            );\n\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                "f1"\n            );\n\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                "stream"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), ""),\n                "inc"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), ""),\n                "erc"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                "erc"\n            );\n        }\n    }\n\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\n\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        {\n            // Fails\n            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "past"\n            );\n\n            if (minStreamDuration &gt; 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    "stream"\n                );\n            }\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "stream"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "lock"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "reward"\n            );\n        }\n        // ===   ===\n        \n\n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 0);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 0");\n            assertEq(stream.symbol(), "lockeTTB0");\n\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 1);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 1");\n            assertEq(stream.symbol(), "lockeTTB1");\n\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "fee"\n        );\n\n        newParams.feePercent = 137;\n\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 19:47:50 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:47:50 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-22-08 19:47:54 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 19:47:54 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17505
completion_tokens: 1
total_tokens: 17506
cost: $-1.000000


[2024-22-08 19:47:54 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Let's

[2024-22-08 19:47:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport "./utils/LockeTest.sol";\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint112 amt = 1337;\n        emit log_named_uint("blocktime", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n            // === Failures ===\n            bytes4 sig = sigs("fundStream(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                "time"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n            \n\n            // === No Fees ===\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream2", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n        alice.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n        alice.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n        alice.doExit(stream); \n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n        testTokenB.approve(address(stream), type(uint256).max);\n        {\n            // Failures\n            bytes4 sig = sigs("stake(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "!stream"\n            );\n            hevm.warp(startTime - minStreamDuration);\n            write_balanceOf(address(testTokenB), address(stream), 2112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "erc"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n            hevm.warp(startTime + (2minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n        bytes4 sig = sigs("createIncentive(address,uint112)");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            "inc"\n        );\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "sale"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "lock"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!sale"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "claimed"\n            );\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!creator"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n    function test_claimFees() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            bob.failClaimFees(stream);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs("claimFees(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, ""),\n                "erc"\n            );\n            \n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                "f4"\n            );\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                "f1"\n            );\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                "stream"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), ""),\n                "inc"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), ""),\n                "erc"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            testTokenC.transfer(address(stream), 100);\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            testTokenC.transfer(address(stream), 100);\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                "erc"\n            );\n        }\n    }\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        {\n            // Fails\n            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "past"\n            );\n            if (minStreamDuration &gt; 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    "stream"\n                );\n            }\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "stream"\n            );\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "lock"\n            );\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "reward"\n            );\n        }\n        // ===   ===\n        \n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n            // id\n            assertEq(stream.streamId(), 0);\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 0");\n            assertEq(stream.symbol(), "lockeTTB0");\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n            // id\n            assertEq(stream.streamId(), 1);\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 1");\n            assertEq(stream.symbol(), "lockeTTB1");\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "fee"\n        );\n        newParams.feePercent = 137;\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\nimport "./utils/LockeTest.sol";\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint112 amt = 1337;\n        emit log_named_uint("blocktime", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n            // === Failures ===\n            bytes4 sig = sigs("fundStream(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                "time"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n            \n\n            // === No Fees ===\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream2", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n        alice.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n        alice.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n        alice.doExit(stream); \n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n        testTokenB.approve(address(stream), type(uint256).max);\n        {\n            // Failures\n            bytes4 sig = sigs("stake(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "!stream"\n            );\n            hevm.warp(startTime - minStreamDuration);\n            write_balanceOf(address(testTokenB), address(stream), 2112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "erc"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n            hevm.warp(startTime + (2minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n        bytes4 sig = sigs("createIncentive(address,uint112)");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            "inc"\n        );\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "sale"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "lock"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!sale"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "claimed"\n            );\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!creator"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n    function test_claimFees() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            bob.failClaimFees(stream);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs("claimFees(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, ""),\n                "erc"\n            );\n            \n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                "f4"\n            );\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                "f1"\n            );\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                "stream"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        uint32 startTime = uint32(block.timestamp + 10);\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), ""),\n                "inc"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), ""),\n                "erc"\n            );\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            testTokenC.transfer(address(stream), 100);\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            testTokenC.transfer(address(stream), 100);\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                "erc"\n            );\n        }\n    }\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        {\n            // Fails\n            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "past"\n            );\n            if (minStreamDuration &gt; 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    "stream"\n                );\n            }\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "stream"\n            );\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "lock"\n            );\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "reward"\n            );\n        }\n        // ===   ===\n        \n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n            // id\n            assertEq(stream.streamId(), 0);\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 0");\n            assertEq(stream.symbol(), "lockeTTB0");\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n            // id\n            assertEq(stream.streamId(), 1);\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 1");\n            assertEq(stream.symbol(), "lockeTTB1");\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "fee"\n        );\n        newParams.feePercent = 137;\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 19:47:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:47:54 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import "./utils/LockeTest.sol";

contract StreamTest is LockeTest {
    bool enteredFlashloan = false;
    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===

            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===
            

            // === No Fees ===
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }

        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            testTokenA.approve(address(stream), type(uint256).max);
            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }
    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );
        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);
        alice.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);
        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream
        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }
    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );
        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);
        alice.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);
        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);
        alice.doExit(stream); 
        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }
    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );
        testTokenB.approve(address(stream), type(uint256).max);
        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);
            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }
        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);
            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            
            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            
            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            
        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);
            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }
    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );
        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );
        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);
        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }

    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }
    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }
    function test_claimFees() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            bob.failClaimFees(stream);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }
        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }
    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            
            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );
            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );
            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }

    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);
            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }
    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            testTokenC.transfer(address(stream), 100);
            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            testTokenC.transfer(address(stream), 100);
            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }
    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }
    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}

contract StreamFactoryTest is LockeTest {
    function test_createStream() public {
        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );
            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        
        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();
            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);
            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));
            // address
            // assertEq(address(uint160(uint(hash))), address(stream));
            // id
            assertEq(stream.streamId(), 0);
            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);
            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");
            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();
            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);
            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));
            // address
            // assertEq(address(uint160(uint(hash))), address(stream));
            // id
            assertEq(stream.streamId(), 1);
            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);
            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");
            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }

    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );
        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }
    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );
        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );
        newParams.feePercent = 137;
        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import "./utils/LockeTest.sol";

contract StreamTest is LockeTest {
    bool enteredFlashloan = false;
    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===

            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===
            

            // === No Fees ===
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }

        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            testTokenA.approve(address(stream), type(uint256).max);
            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }
    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );
        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);
        alice.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);
        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream
        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }
    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );
        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);
        alice.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);
        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);
        alice.doExit(stream); 
        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }
    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );
        testTokenB.approve(address(stream), type(uint256).max);
        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);
            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }
        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);
            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            
            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            
            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            
        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);
            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }
    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );
        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );
        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);
        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }

    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }
    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }
    function test_claimFees() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            bob.failClaimFees(stream);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }
        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }
    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            
            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );
            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );
            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }

    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);
            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }
    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        uint32 startTime = uint32(block.timestamp + 10);
        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            testTokenC.transfer(address(stream), 100);
            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            testTokenC.transfer(address(stream), 100);
            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);
            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }
    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }
    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}

contract StreamFactoryTest is LockeTest {
    function test_createStream() public {
        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );
            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        
        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();
            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);
            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));
            // address
            // assertEq(address(uint160(uint(hash))), address(stream));
            // id
            assertEq(stream.streamId(), 0);
            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);
            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");
            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );
            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();
            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);
            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));
            // address
            // assertEq(address(uint160(uint(hash))), address(stream));
            // id
            assertEq(stream.streamId(), 1);
            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);
            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");
            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }

    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );
        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }
    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );
        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );
        newParams.feePercent = 137;
        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-22-08 19:47:57 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 19:47:57 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 26309
completion_tokens: 1
total_tokens: 26310
cost: $-1.000000


[2024-22-08 19:47:57 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Security

[2024-22-08 19:47:57 INFO] **[Seminar Conclusion]**:

 Security

[2024-22-08 19:47:57 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-22-08 19:47:57 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-22-08 19:47:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport "./utils/LockeTest.sol";\n\n\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint112 amt = 1337;\n        emit log_named_uint("blocktime", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n\n            // === Failures ===\n            bytes4 sig = sigs("fundStream(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                "time"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n\n            \n\n\n            // === No Fees ===\n\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream2", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n\n        alice.doExit(stream); \n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        testTokenB.approve(address(stream), type(uint256).max);\n\n        {\n            // Failures\n            bytes4 sig = sigs("stake(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "!stream"\n            );\n            hevm.warp(startTime - minStreamDuration);\n\n            write_balanceOf(address(testTokenB), address(stream), 2112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "erc"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n\n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n\n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n            hevm.warp(startTime + (2minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        bytes4 sig = sigs("createIncentive(address,uint112)");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            "inc"\n        );\n\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "lock"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "claimed"\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!creator"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_claimFees() public {\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n\n            bob.failClaimFees(stream);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs("claimFees(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, ""),\n                "erc"\n            );\n            \n\n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                "f4"\n            );\n\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                "f1"\n            );\n\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                "stream"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), ""),\n                "inc"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), ""),\n                "erc"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                "erc"\n            );\n        }\n    }\n\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\n\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        {\n            // Fails\n            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "past"\n            );\n\n            if (minStreamDuration &gt; 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    "stream"\n                );\n            }\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "stream"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "lock"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "reward"\n            );\n        }\n        // ===   ===\n        \n\n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 0);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 0");\n            assertEq(stream.symbol(), "lockeTTB0");\n\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 1);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 1");\n            assertEq(stream.symbol(), "lockeTTB1");\n\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "fee"\n        );\n\n        newParams.feePercent = 137;\n\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 19:47:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:47:57 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 19:48:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 19:48:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17496
completion_tokens: 1
total_tokens: 17497
cost: $-1.000000


[2024-22-08 19:48:01 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

###

[2024-22-08 19:48:01 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 19:48:01 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-22-08 19:48:01 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 19:48:01 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:48:01 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 19:48:13 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 19:48:13 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8807
completion_tokens: 771
total_tokens: 9578
cost: $-1.000000


[2024-22-08 19:48:13 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Based on the provided smart contract code and analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract does not adequately protect against reentrancy attacks, particularly in functions that transfer tokens or modify state variables after external calls. This could allow malicious actors to exploit the contract by recursively calling functions before the state is updated.

2. **Timestamp Dependence**:
   - The contract relies on `block.timestamp` for critical logic, which can be manipulated by miners. This could lead to unintended consequences, such as bypassing time-based restrictions or conditions.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 introduced built-in overflow/underflow checks, there are still areas where arithmetic operations could lead to unexpected results if not handled properly, especially in older versions or if the code is modified.

4. **Improper Access Control**:
   - Certain functions lack proper access control mechanisms, allowing unauthorized users to execute sensitive operations. This could lead to privilege escalation or unauthorized fund withdrawals.

5. **Gas Limit and Loops**:
   - Functions that involve loops may exceed the gas limit, leading to transaction failures. This is particularly concerning in functions that process multiple user inputs or state changes.

6. **Insufficient Input Validation**:
   - The contract does not thoroughly validate user inputs, which could lead to unexpected behavior or state corruption. For example, functions that accept token amounts should ensure that the amounts are greater than zero.

7. **Lack of Event Emission**:
   - Some critical state changes do not emit events, making it difficult to track contract activity and state changes. This could hinder debugging and transparency.

8. **Potential for Front-Running**:
   - The contract may be susceptible to front-running attacks, where malicious actors can observe pending transactions and exploit them for profit before they are confirmed.

### Comprehensive Analysis Report

The smart contract exhibits several security vulnerabilities that could be exploited by malicious actors, potentially leading to significant financial losses or contract manipulation. The most critical issues include reentrancy vulnerabilities, which could allow attackers to drain funds, and timestamp dependence, which could be exploited to bypass time-based restrictions.

Improper access control is another significant concern, as it could allow unauthorized users to execute sensitive functions. Additionally, the lack of thorough input validation can lead to unexpected behavior, while insufficient event emissions can obscure contract activity, complicating audits and debugging efforts.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

1. **Reentrancy Guards**: Utilize the Checks-Effects-Interactions pattern and consider using a reentrancy guard modifier to protect critical functions.

2. **Use of SafeMath Libraries**: Although Solidity 0.8.0 has built-in checks, ensure that arithmetic operations are handled safely, especially if modifications are made to the code.

3. **Access Control Mechanisms**: Implement robust access control mechanisms, such as OpenZeppelin's Ownable or Roles contracts, to restrict access to sensitive functions.

4. **Input Validation**: Ensure that all user inputs are validated to prevent unexpected behavior and state corruption.

5. **Event Emission**: Emit events for all critical state changes to enhance transparency and facilitate tracking of contract activity.

6. **Gas Optimization**: Review functions for potential gas limit issues, particularly those involving loops, and optimize them accordingly.

7. **Front-Running Mitigation**: Consider implementing measures to mitigate front-running risks, such as transaction ordering or commit-reveal schemes.

By addressing these vulnerabilities, the contract can be made significantly more secure, reducing the risk of exploitation and enhancing overall reliability. Regular audits and updates should also be conducted to adapt to evolving security threats in the blockchain ecosystem.

[2024-22-08 19:48:13 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code and analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract does not adequately protect against reentrancy attacks, particularly in functions that transfer tokens or modify state variables after external calls. This could allow malicious actors to exploit the contract by recursively calling functions before the state is updated.

2. **Timestamp Dependence**:
   - The contract relies on `block.timestamp` for critical logic, which can be manipulated by miners. This could lead to unintended consequences, such as bypassing time-based restrictions or conditions.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 introduced built-in overflow/underflow checks, there are still areas where arithmetic operations could lead to unexpected results if not handled properly, especially in older versions or if the code is modified.

4. **Improper Access Control**:
   - Certain functions lack proper access control mechanisms, allowing unauthorized users to execute sensitive operations. This could lead to privilege escalation or unauthorized fund withdrawals.

5. **Gas Limit and Loops**:
   - Functions that involve loops may exceed the gas limit, leading to transaction failures. This is particularly concerning in functions that process multiple user inputs or state changes.

6. **Insufficient Input Validation**:
   - The contract does not thoroughly validate user inputs, which could lead to unexpected behavior or state corruption. For example, functions that accept token amounts should ensure that the amounts are greater than zero.

7. **Lack of Event Emission**:
   - Some critical state changes do not emit events, making it difficult to track contract activity and state changes. This could hinder debugging and transparency.

8. **Potential for Front-Running**:
   - The contract may be susceptible to front-running attacks, where malicious actors can observe pending transactions and exploit them for profit before they are confirmed.

### Comprehensive Analysis Report

The smart contract exhibits several security vulnerabilities that could be exploited by malicious actors, potentially leading to significant financial losses or contract manipulation. The most critical issues include reentrancy vulnerabilities, which could allow attackers to drain funds, and timestamp dependence, which could be exploited to bypass time-based restrictions.

Improper access control is another significant concern, as it could allow unauthorized users to execute sensitive functions. Additionally, the lack of thorough input validation can lead to unexpected behavior, while insufficient event emissions can obscure contract activity, complicating audits and debugging efforts.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

1. **Reentrancy Guards**: Utilize the Checks-Effects-Interactions pattern and consider using a reentrancy guard modifier to protect critical functions.

2. **Use of SafeMath Libraries**: Although Solidity 0.8.0 has built-in checks, ensure that arithmetic operations are handled safely, especially if modifications are made to the code.

3. **Access Control Mechanisms**: Implement robust access control mechanisms, such as OpenZeppelin's Ownable or Roles contracts, to restrict access to sensitive functions.

4. **Input Validation**: Ensure that all user inputs are validated to prevent unexpected behavior and state corruption.

5. **Event Emission**: Emit events for all critical state changes to enhance transparency and facilitate tracking of contract activity.

6. **Gas Optimization**: Review functions for potential gas limit issues, particularly those involving loops, and optimize them accordingly.

7. **Front-Running Mitigation**: Consider implementing measures to mitigate front-running risks, such as transaction ordering or commit-reveal schemes.

By addressing these vulnerabilities, the contract can be made significantly more secure, reducing the risk of exploitation and enhancing overall reliability. Regular audits and updates should also be conducted to adapt to evolving security threats in the blockchain ecosystem.

[2024-22-08 19:48:13 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-22-08 19:48:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport "./utils/LockeTest.sol";\n\n\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint112 amt = 1337;\n        emit log_named_uint("blocktime", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n\n            // === Failures ===\n            bytes4 sig = sigs("fundStream(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                "time"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n\n            \n\n\n            // === No Fees ===\n\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream2", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n\n        alice.doExit(stream); \n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        testTokenB.approve(address(stream), type(uint256).max);\n\n        {\n            // Failures\n            bytes4 sig = sigs("stake(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "!stream"\n            );\n            hevm.warp(startTime - minStreamDuration);\n\n            write_balanceOf(address(testTokenB), address(stream), 2112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "erc"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n\n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n\n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n            hevm.warp(startTime + (2minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        bytes4 sig = sigs("createIncentive(address,uint112)");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            "inc"\n        );\n\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "lock"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "claimed"\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!creator"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_claimFees() public {\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n\n            bob.failClaimFees(stream);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs("claimFees(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, ""),\n                "erc"\n            );\n            \n\n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                "f4"\n            );\n\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                "f1"\n            );\n\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                "stream"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), ""),\n                "inc"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), ""),\n                "erc"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                "erc"\n            );\n        }\n    }\n\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\n\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        {\n            // Fails\n            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "past"\n            );\n\n            if (minStreamDuration &gt; 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    "stream"\n                );\n            }\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "stream"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "lock"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "reward"\n            );\n        }\n        // ===   ===\n        \n\n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 0);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 0");\n            assertEq(stream.symbol(), "lockeTTB0");\n\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 1);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 1");\n            assertEq(stream.symbol(), "lockeTTB1");\n\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "fee"\n        );\n\n        newParams.feePercent = 137;\n\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 19:48:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:48:13 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 19:48:16 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 19:48:16 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17496
completion_tokens: 1
total_tokens: 17497
cost: $-1.000000


[2024-22-08 19:48:16 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

###

[2024-22-08 19:48:16 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 19:48:16 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-22-08 19:48:16 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 19:48:16 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:48:16 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 19:48:27 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 19:48:27 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8807
completion_tokens: 815
total_tokens: 9622
cost: $-1.000000


[2024-22-08 19:48:27 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Based on the provided Solidity smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract does not implement checks to prevent reentrancy attacks, especially in functions that involve transferring tokens or changing state variables after external calls.

2. **Timestamp Dependence**:
   - The contract relies on `block.timestamp` for critical logic, which can be manipulated by miners. This could lead to unexpected behavior in time-sensitive functions.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 has built-in overflow and underflow checks, any manual arithmetic operations should be carefully reviewed to ensure they do not lead to unexpected results.

4. **Improper Access Control**:
   - Certain functions that modify state or transfer tokens do not have adequate access control mechanisms, allowing unauthorized users to invoke them.

5. **Gas Limit and Loops**:
   - Functions that involve loops over dynamic arrays or mappings may run into gas limit issues if the size of the data grows too large, potentially leading to failed transactions.

6. **Lack of Input Validation**:
   - Functions that accept user inputs do not sufficiently validate the inputs, which could lead to unexpected behavior or exploitation.

7. **Unprotected State Changes**:
   - State variables can be altered without proper checks or conditions, which may lead to inconsistent contract states.

8. **Token Recovery Logic**:
   - The logic for recovering tokens may allow for unintended token transfers, especially if the conditions for recovery are not strictly enforced.

9. **Flashloan Vulnerability**:
   - The contract allows for flashloans without adequate checks, which could be exploited to manipulate the contract's state or drain funds.

10. **Incentive Mechanism Flaws**:
    - The incentive creation and claiming mechanisms lack proper checks, which could lead to abuse or unintended rewards distribution.

### Comprehensive Analysis Report

The analysis of the provided smart contract code reveals several critical security vulnerabilities that could be exploited by malicious actors. The reliance on `block.timestamp` for key functionalities poses a significant risk, as it can be manipulated by miners, leading to potential exploitation. Additionally, the absence of reentrancy guards in functions that involve external calls increases the risk of reentrancy attacks, which have historically led to significant losses in the DeFi space.

Improper access control mechanisms allow unauthorized users to invoke sensitive functions, potentially leading to unauthorized fund transfers or state changes. Furthermore, the lack of input validation can result in unexpected behaviors, making the contract susceptible to various forms of attacks.

The contract's design also raises concerns regarding gas limit issues due to loops over dynamic data structures, which could lead to transaction failures as the data grows. The token recovery logic, while intended to safeguard funds, may inadvertently allow for unintended transfers if not properly secured.

Lastly, the flashloan functionality, while a powerful feature, is not adequately protected against potential abuse, which could lead to significant financial losses.

### Recommendations

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin's library to protect critical functions from reentrancy attacks.

2. **Avoid Timestamp Dependence**: Consider using block numbers or other mechanisms to avoid reliance on `block.timestamp`.

3. **Enhance Access Control**: Implement role-based access control to ensure that only authorized users can invoke sensitive functions.

4. **Validate Inputs**: Add thorough input validation to all functions that accept user inputs to prevent unexpected behaviors.

5. **Review Token Recovery Logic**: Ensure that the logic for recovering tokens is strictly enforced and does not allow for unintended transfers.

6. **Conduct Regular Audits**: Regularly audit the contract code to identify and address any emerging vulnerabilities, especially after significant changes.

By addressing these vulnerabilities and implementing the recommended best practices, the security posture of the smart contract can be significantly improved, reducing the risk of exploitation and enhancing user trust.

[2024-22-08 19:48:27 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract does not implement checks to prevent reentrancy attacks, especially in functions that involve transferring tokens or changing state variables after external calls.

2. **Timestamp Dependence**:
   - The contract relies on `block.timestamp` for critical logic, which can be manipulated by miners. This could lead to unexpected behavior in time-sensitive functions.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 has built-in overflow and underflow checks, any manual arithmetic operations should be carefully reviewed to ensure they do not lead to unexpected results.

4. **Improper Access Control**:
   - Certain functions that modify state or transfer tokens do not have adequate access control mechanisms, allowing unauthorized users to invoke them.

5. **Gas Limit and Loops**:
   - Functions that involve loops over dynamic arrays or mappings may run into gas limit issues if the size of the data grows too large, potentially leading to failed transactions.

6. **Lack of Input Validation**:
   - Functions that accept user inputs do not sufficiently validate the inputs, which could lead to unexpected behavior or exploitation.

7. **Unprotected State Changes**:
   - State variables can be altered without proper checks or conditions, which may lead to inconsistent contract states.

8. **Token Recovery Logic**:
   - The logic for recovering tokens may allow for unintended token transfers, especially if the conditions for recovery are not strictly enforced.

9. **Flashloan Vulnerability**:
   - The contract allows for flashloans without adequate checks, which could be exploited to manipulate the contract's state or drain funds.

10. **Incentive Mechanism Flaws**:
    - The incentive creation and claiming mechanisms lack proper checks, which could lead to abuse or unintended rewards distribution.

### Comprehensive Analysis Report

The analysis of the provided smart contract code reveals several critical security vulnerabilities that could be exploited by malicious actors. The reliance on `block.timestamp` for key functionalities poses a significant risk, as it can be manipulated by miners, leading to potential exploitation. Additionally, the absence of reentrancy guards in functions that involve external calls increases the risk of reentrancy attacks, which have historically led to significant losses in the DeFi space.

Improper access control mechanisms allow unauthorized users to invoke sensitive functions, potentially leading to unauthorized fund transfers or state changes. Furthermore, the lack of input validation can result in unexpected behaviors, making the contract susceptible to various forms of attacks.

The contract's design also raises concerns regarding gas limit issues due to loops over dynamic data structures, which could lead to transaction failures as the data grows. The token recovery logic, while intended to safeguard funds, may inadvertently allow for unintended transfers if not properly secured.

Lastly, the flashloan functionality, while a powerful feature, is not adequately protected against potential abuse, which could lead to significant financial losses.

### Recommendations

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin's library to protect critical functions from reentrancy attacks.

2. **Avoid Timestamp Dependence**: Consider using block numbers or other mechanisms to avoid reliance on `block.timestamp`.

3. **Enhance Access Control**: Implement role-based access control to ensure that only authorized users can invoke sensitive functions.

4. **Validate Inputs**: Add thorough input validation to all functions that accept user inputs to prevent unexpected behaviors.

5. **Review Token Recovery Logic**: Ensure that the logic for recovering tokens is strictly enforced and does not allow for unintended transfers.

6. **Conduct Regular Audits**: Regularly audit the contract code to identify and address any emerging vulnerabilities, especially after significant changes.

By addressing these vulnerabilities and implementing the recommended best practices, the security posture of the smart contract can be significantly improved, reducing the risk of exploitation and enhancing user trust.

[2024-22-08 19:48:27 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-22-08 19:48:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport "./utils/LockeTest.sol";\n\n\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint112 amt = 1337;\n        emit log_named_uint("blocktime", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n\n            // === Failures ===\n            bytes4 sig = sigs("fundStream(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                "time"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n\n            \n\n\n            // === No Fees ===\n\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream2", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n\n        alice.doExit(stream); \n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        testTokenB.approve(address(stream), type(uint256).max);\n\n        {\n            // Failures\n            bytes4 sig = sigs("stake(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "!stream"\n            );\n            hevm.warp(startTime - minStreamDuration);\n\n            write_balanceOf(address(testTokenB), address(stream), 2112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "erc"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n\n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n\n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n            hevm.warp(startTime + (2minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        bytes4 sig = sigs("createIncentive(address,uint112)");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            "inc"\n        );\n\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "lock"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "claimed"\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!creator"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_claimFees() public {\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n\n            bob.failClaimFees(stream);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs("claimFees(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, ""),\n                "erc"\n            );\n            \n\n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                "f4"\n            );\n\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                "f1"\n            );\n\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                "stream"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), ""),\n                "inc"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), ""),\n                "erc"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                "erc"\n            );\n        }\n    }\n\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\n\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        {\n            // Fails\n            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "past"\n            );\n\n            if (minStreamDuration &gt; 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    "stream"\n                );\n            }\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "stream"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "lock"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "reward"\n            );\n        }\n        // ===   ===\n        \n\n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 0);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 0");\n            assertEq(stream.symbol(), "lockeTTB0");\n\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 1);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 1");\n            assertEq(stream.symbol(), "lockeTTB1");\n\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "fee"\n        );\n\n        newParams.feePercent = 137;\n\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 19:48:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:48:27 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 19:48:30 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 19:48:30 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17496
completion_tokens: 1
total_tokens: 17497
cost: $-1.000000


[2024-22-08 19:48:30 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

###

[2024-22-08 19:48:30 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 19:48:30 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-22-08 19:48:30 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 19:48:30 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:48:30 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 19:48:39 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 19:48:39 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8807
completion_tokens: 712
total_tokens: 9519
cost: $-1.000000


[2024-22-08 19:48:39 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Based on the provided Solidity smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not adequately protect against reentrancy attacks, particularly in functions that involve transferring tokens or changing state variables after external calls. This could allow an attacker to exploit the contract by recursively calling functions before the state is updated.

2. **Timestamp Dependence**:
   - The contract relies on `block.timestamp` for critical logic, which can be manipulated by miners. This could lead to unintended consequences, such as bypassing time-based restrictions or conditions.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 and above has built-in overflow/underflow protection, any arithmetic operations that do not account for edge cases could still lead to unexpected behavior if the code is later modified or if the contract is deployed on an earlier version.

4. **Improper Access Control**:
   - Certain functions lack proper access control mechanisms, allowing unauthorized users to execute sensitive operations. For example, functions that update parameters or manage funds should be restricted to specific roles (e.g., owner or admin).

5. **Gas Limit and Loops**:
   - The contract may contain functions that involve loops over dynamic arrays or mappings, which could exceed the gas limit and cause transactions to fail. This could be exploited to deny service or manipulate contract behavior.

6. **Lack of Input Validation**:
   - Functions that accept user input do not sufficiently validate the input parameters. This could lead to unexpected behavior or allow for malicious inputs that exploit the contract's logic.

7. **Token Recovery Risks**:
   - The `recoverTokens` function does not adequately check if the tokens being recovered are indeed recoverable or if they are part of an ongoing stream, potentially allowing for the loss of tokens.

8. **Flash Loan Risks**:
   - The implementation of flash loans lacks proper checks and balances, which could lead to exploitation if an attacker can manipulate the loan process to their advantage.

### Comprehensive Analysis Report:

The smart contract exhibits several security vulnerabilities that could be exploited by malicious actors. The most critical issues include reentrancy vulnerabilities, which could allow attackers to drain funds, and timestamp dependence, which could lead to manipulation of time-sensitive logic. Additionally, improper access control and lack of input validation expose the contract to unauthorized access and potential exploits.

To mitigate these vulnerabilities, it is recommended to implement the following best practices:

- **Reentrancy Guards**: Use the Checks-Effects-Interactions pattern and implement reentrancy guards to prevent recursive calls.
- **Use of SafeMath**: Although Solidity 0.8.0 has built-in overflow checks, ensure that all arithmetic operations are safe and consider using libraries like SafeMath for clarity.
- **Access Control**: Implement role-based access control to restrict sensitive functions to authorized users only.
- **Input Validation**: Rigorously validate all inputs to functions to prevent unexpected behavior.
- **Gas Optimization**: Avoid loops that could exceed gas limits and consider alternative designs for handling dynamic data.
- **Thorough Testing**: Conduct extensive testing, including unit tests and integration tests, to identify and fix vulnerabilities before deployment.

In conclusion, while the contract has potential, it requires significant improvements in security practices to ensure the safety and integrity of user funds and contract operations. A thorough audit and continuous monitoring post-deployment are essential to maintain security.

[2024-22-08 19:48:39 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not adequately protect against reentrancy attacks, particularly in functions that involve transferring tokens or changing state variables after external calls. This could allow an attacker to exploit the contract by recursively calling functions before the state is updated.

2. **Timestamp Dependence**:
   - The contract relies on `block.timestamp` for critical logic, which can be manipulated by miners. This could lead to unintended consequences, such as bypassing time-based restrictions or conditions.

3. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.0 and above has built-in overflow/underflow protection, any arithmetic operations that do not account for edge cases could still lead to unexpected behavior if the code is later modified or if the contract is deployed on an earlier version.

4. **Improper Access Control**:
   - Certain functions lack proper access control mechanisms, allowing unauthorized users to execute sensitive operations. For example, functions that update parameters or manage funds should be restricted to specific roles (e.g., owner or admin).

5. **Gas Limit and Loops**:
   - The contract may contain functions that involve loops over dynamic arrays or mappings, which could exceed the gas limit and cause transactions to fail. This could be exploited to deny service or manipulate contract behavior.

6. **Lack of Input Validation**:
   - Functions that accept user input do not sufficiently validate the input parameters. This could lead to unexpected behavior or allow for malicious inputs that exploit the contract's logic.

7. **Token Recovery Risks**:
   - The `recoverTokens` function does not adequately check if the tokens being recovered are indeed recoverable or if they are part of an ongoing stream, potentially allowing for the loss of tokens.

8. **Flash Loan Risks**:
   - The implementation of flash loans lacks proper checks and balances, which could lead to exploitation if an attacker can manipulate the loan process to their advantage.

### Comprehensive Analysis Report:

The smart contract exhibits several security vulnerabilities that could be exploited by malicious actors. The most critical issues include reentrancy vulnerabilities, which could allow attackers to drain funds, and timestamp dependence, which could lead to manipulation of time-sensitive logic. Additionally, improper access control and lack of input validation expose the contract to unauthorized access and potential exploits.

To mitigate these vulnerabilities, it is recommended to implement the following best practices:

- **Reentrancy Guards**: Use the Checks-Effects-Interactions pattern and implement reentrancy guards to prevent recursive calls.
- **Use of SafeMath**: Although Solidity 0.8.0 has built-in overflow checks, ensure that all arithmetic operations are safe and consider using libraries like SafeMath for clarity.
- **Access Control**: Implement role-based access control to restrict sensitive functions to authorized users only.
- **Input Validation**: Rigorously validate all inputs to functions to prevent unexpected behavior.
- **Gas Optimization**: Avoid loops that could exceed gas limits and consider alternative designs for handling dynamic data.
- **Thorough Testing**: Conduct extensive testing, including unit tests and integration tests, to identify and fix vulnerabilities before deployment.

In conclusion, while the contract has potential, it requires significant improvements in security practices to ensure the safety and integrity of user funds and contract operations. A thorough audit and continuous monitoring post-deployment are essential to maintain security.

[2024-22-08 19:48:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport "./utils/LockeTest.sol";\n\n\n\ncontract StreamTest is LockeTest {\n    bool enteredFlashloan = false;\n\n    function test_fundStream() public {\n        // === Setup ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint112 amt = 1337;\n        emit log_named_uint("blocktime", block.timestamp);\n        {\n            uint64 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            // ===   ===\n\n\n            // === Failures ===\n            bytes4 sig = sigs("fundStream(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n            hevm.warp(block.timestamp + 11);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(amt),\n                "time"\n            );\n            hevm.warp(block.timestamp - 11);\n            // ===   ===\n\n            \n\n\n            // === No Fees ===\n\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt);\n            assertEq(rewardTokenFeeAmount, 0);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n            // ===    ===\n        }\n\n\n        {\n            // === Fees Enabled ====\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            uint256 nextStream = defaultStreamFactory.currStreamId();\n            emit log_named_uint("nextStream2", nextStream);\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n\n            uint112 feeAmt = 13; // expected fee amt\n            uint256 gas_left = gasleft();\n            stream.fundStream(amt);\n            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());\n            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(rewardTokenAmount, amt - feeAmt);\n            assertEq(rewardTokenFeeAmount, feeAmt);\n            assertEq(testTokenA.balanceOf(address(stream)), 1337);\n        }\n    }\n\n    function test_multiUserStake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 666);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 333);\n    }\n\n    function test_multiUserStakeWithWithdraw() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false\n            // bytes32(0)\n        );\n\n        testTokenA.approve(address(stream), type(uint256).max);\n        stream.fundStream(1000);\n\n        alice.doStake(stream, address(testTokenB), 100);\n\n\n        hevm.warp(startTime + minStreamDuration / 2); // move to half done\n        \n        bob.doStake(stream, address(testTokenB), 100);\n\n        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\n\n        alice.doExit(stream); \n\n        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\n\n\n        alice.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(alice)), 533);\n        bob.doClaimReward(stream);\n        assertEq(testTokenA.balanceOf(address(bob)), 466);\n    }\n\n    function test_stake() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        testTokenB.approve(address(stream), type(uint256).max);\n\n        {\n            // Failures\n            bytes4 sig = sigs("stake(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n\n            // fast forward minStreamDuration\n            hevm.warp(startTime + minStreamDuration);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "!stream"\n            );\n            hevm.warp(startTime - minStreamDuration);\n\n            write_balanceOf(address(testTokenB), address(stream), 2112 + 1);\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "erc"\n            );\n            write_balanceOf(address(testTokenB), address(stream), 0);\n        }\n\n        {\n            // Successes\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            assertEq(asLERC.balanceOf(address(this)), 100);\n\n            {\n                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n                assertEq(depositTokenAmount, 100);\n            }\n            \n\n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 100);\n            }\n            \n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, 0);\n                assertEq(virtualBalance, 100);\n                assertEq(tokens, 100);\n                assertEq(lu, startTime);\n            }\n            \n\n            // move forward 1/10th of sd\n            // round up to next second\n            hevm.warp(startTime + minStreamDuration / 10 + 1);\n            uint256 rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 91);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 101);\n                assertEq(tokens, 91);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n            hevm.warp(startTime + (2minStreamDuration) / 10 + 1);\n            rewardPerToken = stream.rewardPerToken();\n            stream.stake(1);\n            \n            {\n                uint112 unstreamed = stream.unstreamed();\n                assertEq(unstreamed, 82);\n            }\n\n            {\n                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n                assertEq(lastCumulativeRewardPerToken, rewardPerToken);\n                assertEq(virtualBalance, 102);\n                assertEq(tokens, 82);\n                assertEq(lu, block.timestamp);\n            }\n            \n\n        }\n        {\n            hevm.warp(1609459200); // jan 1, 2021          \n            // Sale test\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n            testTokenB.approve(address(stream), type(uint256).max);\n            stream.stake(100);\n            LockeERC20 asLERC = LockeERC20(stream);\n            // no tokens wen sale\n            assertEq(asLERC.balanceOf(address(this)), 0);\n\n            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();\n            assertEq(depositTokenAmount, 100);\n            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));\n            assertEq(tokens, 100);\n        }\n    }\n\n    function test_createIncentive() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n        Stream stream = defaultStreamFactory.createStream(\n            address(testTokenA),\n            address(testTokenB),\n            startTime,\n            minStreamDuration,\n            maxDepositLockDuration,\n            0,\n            false\n            // false,\n            // bytes32(0)\n        );\n\n        bytes4 sig = sigs("createIncentive(address,uint112)");\n        expect_revert_with(\n            address(stream),\n            sig,\n            abi.encode(address(testTokenA), 0),\n            "inc"\n        );\n\n        uint256 bal = testTokenC.balanceOf(address(this));\n        testTokenC.approve(address(stream), type(uint256).max);\n        stream.createIncentive(address(testTokenC), 100);\n        assertEq(stream.incentives(address(testTokenC)), 100);\n\n        hevm.warp(startTime + minStreamDuration);\n        stream.claimIncentive(address(testTokenC));\n        assertEq(testTokenC.balanceOf(address(this)), bal);\n    }\n\n\n    function test_claimDeposit() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(0),\n                "amt"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(100),\n                "lock"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock);\n            bytes4 sig = sigs("claimDepositTokens(uint112)");\n            expect_revert(\n                address(stream),\n                sig,\n                abi.encode(101)\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n\n            hevm.warp(endDepositLock + 1);\n            stream.claimDepositTokens(100);\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n        }\n    }\n\n    function test_creatorClaimTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!sale"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "claimed"\n            );\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = alice.doCreateStream(defaultStreamFactory, true);\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "!creator"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            bytes4 sig = sigs("creatorClaimSoldTokens(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                true\n                // false,\n                // bytes32(0)\n            );\n\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.approve(address(stream), type(uint256).max);\n\n            stream.stake(100);\n            hevm.warp(endStream);\n            stream.creatorClaimSoldTokens(address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_claimFees() public {\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n\n            bob.failClaimFees(stream);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            bytes4 sig = sigs("claimFees(address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this)),\n                "stream"\n            );\n        }\n\n        {\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000);\n            \n            uint256 feeAmt = 1000100/10000;\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);\n        }\n    }\n\n    function test_flashloan() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this), 0, ""),\n                "erc"\n            );\n            \n\n            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));\n            (,,uint112 rewardFee,) = stream.tokenAmounts();\n            assertEq(rewardFee, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),\n                "f4"\n            );\n\n            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));\n            (,,,uint112 depositFlFees) = stream.tokenAmounts();\n            assertEq(depositFlFees, 1000000 * 10 / 10000);\n            assertTrue(enteredFlashloan);\n            enteredFlashloan = false;\n\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),\n                "f1"\n            );\n\n            uint256 balA = testTokenA.balanceOf(address(this));\n            uint256 balB = testTokenB.balanceOf(address(this));\n            hevm.warp(endStream);\n            stream.claimFees(address(this));\n            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);\n            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);\n        }\n    }\n\n\n    function test_recoverTokens() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenB), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenB.balanceOf(address(this));\n            testTokenB.transfer(address(stream), 100);\n            hevm.warp(endDepositLock + 1);\n            stream.recoverTokens(address(testTokenB), address(this));\n            assertEq(testTokenB.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), address(this)),\n                "time"\n            );\n            uint256 bal = testTokenA.balanceOf(address(this));\n            testTokenA.transfer(address(stream), 100);\n            hevm.warp(endRewardLock + 1);\n            stream.recoverTokens(address(testTokenA), address(this));\n            assertEq(testTokenA.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("recoverTokens(address,address)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), address(this)),\n                "stream"\n            );\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream + 1);\n            stream.recoverTokens(address(testTokenC), address(this));\n            uint256 newbal = testTokenC.balanceOf(address(this));\n            assertEq(newbal, bal);\n            stream.claimIncentive(address(testTokenC));\n            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);\n            hevm.warp(startTime - 10);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenC.transfer(address(stream), 100);\n            hevm.warp(endStream);\n            stream.recoverTokens(address(testTokenC), address(this));\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n            hevm.warp(startTime - 10);\n        }\n    }\n\n    function test_arbitraryCall() public {\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        uint32 startTime = uint32(block.timestamp + 10);\n\n        uint32 endStream = startTime + minStreamDuration;\n        uint32 endDepositLock = endStream + maxDepositLockDuration;\n        uint32 endRewardLock = endStream + 0;\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.approve(address(stream), type(uint256).max);\n            stream.createIncentive(address(testTokenC), 100);\n\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenC), ""),\n                "inc"\n            );\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(testTokenA), ""),\n                "erc"\n            );\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            testTokenC.transfer(address(stream), 100);\n\n            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));\n            stream.arbitraryCall(address(testTokenC), data);\n            assertEq(testTokenC.balanceOf(address(this)), bal);\n        }\n\n        {\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                startTime,\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n            );\n\n            uint256 bal = testTokenC.balanceOf(address(this));\n            testTokenA.approve(address(stream), type(uint256).max);\n            stream.fundStream(1000000);\n            bob.doStake(stream, address(testTokenB), 1000000);\n\n            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));\n            bytes4 sig = sigs("arbitraryCall(address,bytes)");\n            expect_revert_with(\n                address(stream),\n                sig,\n                abi.encode(address(this), data),\n                "erc"\n            );\n        }\n    }\n\n    function manualBurn(address token, address who) public {\n        uint256 curBal = ERC20(token).balanceOf(who);\n        write_balanceOf_ts(token, who, curBal - 10);\n    }\n\n    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {\n        Stream stream = Stream(msg.sender);\n        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));\n        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);\n        if (sendBackFee) {\n            ERC20(token).transfer(msg.sender, amount * 10 / 10000);\n        }\n        ERC20(token).transfer(msg.sender, amount);\n        enteredFlashloan = true;\n        return;\n    }\n}\n\n\n\ncontract StreamFactoryTest is LockeTest {\n    function test_createStream() public {\n\n        // ===  EXPECTED FAILURES ===\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n\n        {\n            // Fails\n            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp - 10,\n                    0,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "past"\n            );\n\n            if (minStreamDuration &gt; 0) {\n                expect_revert_with(\n                    address(defaultStreamFactory),\n                    sig,\n                    abi.encode(\n                        address(0),\n                        address(0),\n                        block.timestamp,\n                        minStreamDuration - 1,\n                        0,\n                        0,\n                        false\n                        // false,\n                        // bytes32(0)\n                    ),\n                    "stream"\n                );\n            }\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    maxStreamDuration + 1,\n                    0,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "stream"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration + 1,\n                    0,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "lock"\n            );\n\n            expect_revert_with(\n                address(defaultStreamFactory),\n                sig,\n                abi.encode(\n                    address(0),\n                    address(0),\n                    block.timestamp,\n                    minStreamDuration,\n                    maxDepositLockDuration,\n                    maxRewardLockDuration + 1,\n                    false\n                    // false,\n                    // bytes32(0)\n                ),\n                "reward"\n            );\n        }\n        // ===   ===\n        \n\n        // === Successful ===\n        {\n            // No Fees\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 0);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 1);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 0");\n            assertEq(stream.symbol(), "lockeTTB0");\n\n            // others\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 0);\n            assertTrue(!feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        \n        {\n            // With Fees\n            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({\n                feePercent: 100,\n                feeEnabled: true\n            }));\n            Stream stream = defaultStreamFactory.createStream(\n                address(testTokenA),\n                address(testTokenB),\n                uint32(block.timestamp + 10), // 10 seconds in future\n                minStreamDuration,\n                maxDepositLockDuration,\n                0,\n                false\n                // false,\n                // bytes32(0)\n            );\n\n            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();\n\n            // time stuff\n            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();\n            assertEq(startTime, block.timestamp + 10);\n            assertEq(streamDuration, minStreamDuration);\n            assertEq(depositLockDuration, maxDepositLockDuration);\n            assertEq(rewardLockDuration, 0);\n\n            // tokens\n            assertEq(stream.rewardToken(), address(testTokenA));\n            assertEq(stream.depositToken(), address(testTokenB));\n\n            // address\n            // assertEq(address(uint160(uint(hash))), address(stream));\n\n            // id\n            assertEq(stream.streamId(), 1);\n\n            // factory\n            assertEq(defaultStreamFactory.currStreamId(), 2);\n\n            // token\n            assertEq(stream.name(), "lockeTest Token B: 1");\n            assertEq(stream.symbol(), "lockeTTB1");\n\n            // other\n            (feePercent, feeEnabled) = stream.feeParams();\n            assertEq(feePercent, 100);\n            assertTrue(feeEnabled);\n            assertTrue(!stream.isSale());\n        }\n        // ===   ===\n    }\n\n\n    function test_updateStreamParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({\n            maxDepositLockDuration: 1337 weeks,\n            maxRewardLockDuration: 1337 weeks,\n            maxStreamDuration: 1337 weeks,\n            minStreamDuration: 1337 hours\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        defaultStreamFactory.updateStreamParams(newParams);\n\n        (\n            uint32 maxDepositLockDuration,\n            uint32 maxRewardLockDuration,\n            uint32 maxStreamDuration,\n            uint32 minStreamDuration\n        ) = defaultStreamFactory.streamParams();\n        assertEq(maxDepositLockDuration, 1337 weeks);\n        assertEq(maxRewardLockDuration, 1337 weeks);\n        assertEq(maxStreamDuration, 1337 weeks);\n        assertEq(minStreamDuration, 1337 hours);\n    }\n\n    function test_updateFeeParams() public {\n        // set the gov to none\n        write_flat(address(defaultStreamFactory), "gov()", address(0));\n        \n        uint16 max = 500;\n        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({\n            feePercent: max + 1,\n            feeEnabled: true\n        });\n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "!gov"\n        );\n\n        // get back gov and set and check\n        write_flat(address(defaultStreamFactory), "gov()", address(this));\n        \n        expect_revert_with(\n            address(defaultStreamFactory),\n            sigs("updateFeeParams((uint16,bool))"),\n            abi.encode(newParams),\n            "fee"\n        );\n\n        newParams.feePercent = 137;\n\n        defaultStreamFactory.updateFeeParams(newParams);\n        (\n            uint16 feePercent,\n            bool feeEnabled\n        ) = defaultStreamFactory.feeParams();\n        assertEq(feePercent, 137);\n        assertTrue(feeEnabled);\n    }\n}', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-22-08 19:48:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; import "./utils/LockeTest.sol"; contract StreamTest is LockeTest {     bool enteredFlashloan = false; function test_fundStream() public {     // === Setup ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint112 amt = 1337;     emit log_named_uint("blocktime", block.timestamp);     {         uint64 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);         // ===   ===           // === Failures ===         bytes4 sig = sigs("fundStream(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );         hevm.warp(block.timestamp + 11);         expect_revert_with(             address(stream),             sig,             abi.encode(amt),             "time"         );         hevm.warp(block.timestamp - 11);         // ===   ===             // === No Fees ===          uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt);         assertEq(rewardTokenFeeAmount, 0);         assertEq(testTokenA.balanceOf(address(stream)), 1337);         // ===    ===     }       {         // === Fees Enabled ====         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         uint256 nextStream = defaultStreamFactory.currStreamId();         emit log_named_uint("nextStream2", nextStream);         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenA.approve(address(stream), type(uint256).max);          uint112 feeAmt = 13; // expected fee amt         uint256 gas_left = gasleft();         stream.fundStream(amt);         emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());         (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(rewardTokenAmount, amt - feeAmt);         assertEq(rewardTokenFeeAmount, feeAmt);         assertEq(testTokenA.balanceOf(address(stream)), 1337);     } }  function test_multiUserStake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream      alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 666);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 333); }  function test_multiUserStakeWithWithdraw() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false         // bytes32(0)     );      testTokenA.approve(address(stream), type(uint256).max);     stream.fundStream(1000);      alice.doStake(stream, address(testTokenB), 100);       hevm.warp(startTime + minStreamDuration / 2); // move to half done      bob.doStake(stream, address(testTokenB), 100);      hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);      alice.doExit(stream);      hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream       alice.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(alice)), 533);     bob.doClaimReward(stream);     assertEq(testTokenA.balanceOf(address(bob)), 466); }  function test_stake() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      testTokenB.approve(address(stream), type(uint256).max);      {         // Failures         bytes4 sig = sigs("stake(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );          // fast forward minStreamDuration         hevm.warp(startTime + minStreamDuration);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "!stream"         );         hevm.warp(startTime - minStreamDuration);          write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "erc"         );         write_balanceOf(address(testTokenB), address(stream), 0);     }      {         // Successes         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         assertEq(asLERC.balanceOf(address(this)), 100);          {             (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();             assertEq(depositTokenAmount, 100);         }           {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 100);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, 0);             assertEq(virtualBalance, 100);             assertEq(tokens, 100);             assertEq(lu, startTime);         }           // move forward 1/10th of sd         // round up to next second         hevm.warp(startTime + minStreamDuration / 10 + 1);         uint256 rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 91);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 101);             assertEq(tokens, 91);             assertEq(lu, block.timestamp);         }           hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);         rewardPerToken = stream.rewardPerToken();         stream.stake(1);          {             uint112 unstreamed = stream.unstreamed();             assertEq(unstreamed, 82);         }          {             (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));             assertEq(lastCumulativeRewardPerToken, rewardPerToken);             assertEq(virtualBalance, 102);             assertEq(tokens, 82);             assertEq(lu, block.timestamp);         }       }     {         hevm.warp(1609459200); // jan 1, 2021                   // Sale test         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );         testTokenB.approve(address(stream), type(uint256).max);         stream.stake(100);         LockeERC20 asLERC = LockeERC20(stream);         // no tokens wen sale         assertEq(asLERC.balanceOf(address(this)), 0);          (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();         assertEq(depositTokenAmount, 100);         (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));         assertEq(tokens, 100);     } }  function test_createIncentive() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);     Stream stream = defaultStreamFactory.createStream(         address(testTokenA),         address(testTokenB),         startTime,         minStreamDuration,         maxDepositLockDuration,         0,         false         // false,         // bytes32(0)     );      bytes4 sig = sigs("createIncentive(address,uint112)");     expect_revert_with(         address(stream),         sig,         abi.encode(address(testTokenA), 0),         "inc"     );      uint256 bal = testTokenC.balanceOf(address(this));     testTokenC.approve(address(stream), type(uint256).max);     stream.createIncentive(address(testTokenC), 100);     assertEq(stream.incentives(address(testTokenC)), 100);      hevm.warp(startTime + minStreamDuration);     stream.claimIncentive(address(testTokenC));     assertEq(testTokenC.balanceOf(address(this)), bal); }   function test_claimDeposit() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(0),             "amt"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert_with(             address(stream),             sig,             abi.encode(100),             "lock"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock);         bytes4 sig = sigs("claimDepositTokens(uint112)");         expect_revert(             address(stream),             sig,             abi.encode(101)         );         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);          hevm.warp(endDepositLock + 1);         stream.claimDepositTokens(100);         assertEq(testTokenB.balanceOf(address(this)), bal);     } }  function test_creatorClaimTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!sale"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "claimed"         );         hevm.warp(startTime - 10);     }      {         Stream stream = alice.doCreateStream(defaultStreamFactory, true);          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "!creator"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         bytes4 sig = sigs("creatorClaimSoldTokens(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             true             // false,             // bytes32(0)         );          uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.approve(address(stream), type(uint256).max);          stream.stake(100);         hevm.warp(endStream);         stream.creatorClaimSoldTokens(address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_claimFees() public {      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bob.failClaimFees(stream);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          bytes4 sig = sigs("claimFees(address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this)),             "stream"         );     }      {         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));          Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000);          uint256 feeAmt = 1000*100/10000;         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);     } }  function test_flashloan() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this), 0, ""),             "erc"         );           stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));         (,,uint112 rewardFee,) = stream.tokenAmounts();         assertEq(rewardFee, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),             "f4"         );          stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));         (,,,uint112 depositFlFees) = stream.tokenAmounts();         assertEq(depositFlFees, 1000000 * 10 / 10000);         assertTrue(enteredFlashloan);         enteredFlashloan = false;          expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),             "f1"         );          uint256 balA = testTokenA.balanceOf(address(this));         uint256 balB = testTokenB.balanceOf(address(this));         hevm.warp(endStream);         stream.claimFees(address(this));         assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);         assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);     } }   function test_recoverTokens() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenB), address(this)),             "time"         );         uint256 bal = testTokenB.balanceOf(address(this));         testTokenB.transfer(address(stream), 100);         hevm.warp(endDepositLock + 1);         stream.recoverTokens(address(testTokenB), address(this));         assertEq(testTokenB.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), address(this)),             "time"         );         uint256 bal = testTokenA.balanceOf(address(this));         testTokenA.transfer(address(stream), 100);         hevm.warp(endRewardLock + 1);         stream.recoverTokens(address(testTokenA), address(this));         assertEq(testTokenA.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);           testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("recoverTokens(address,address)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), address(this)),             "stream"         );         uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream + 1);         stream.recoverTokens(address(testTokenC), address(this));         uint256 newbal = testTokenC.balanceOf(address(this));         assertEq(newbal, bal);         stream.claimIncentive(address(testTokenC));         assertEq(testTokenC.balanceOf(address(this)), newbal + 100);         hevm.warp(startTime - 10);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          uint256 bal = testTokenC.balanceOf(address(this));         testTokenC.transfer(address(stream), 100);         hevm.warp(endStream);         stream.recoverTokens(address(testTokenC), address(this));         assertEq(testTokenC.balanceOf(address(this)), bal);         hevm.warp(startTime - 10);     } }  function test_arbitraryCall() public {     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      uint32 startTime = uint32(block.timestamp + 10);      uint32 endStream = startTime + minStreamDuration;     uint32 endDepositLock = endStream + maxDepositLockDuration;     uint32 endRewardLock = endStream + 0;     {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.approve(address(stream), type(uint256).max);         stream.createIncentive(address(testTokenC), 100);          bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenC), ""),             "inc"         );         expect_revert_with(             address(stream),             sig,             abi.encode(address(testTokenA), ""),             "erc"         );     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          testTokenC.transfer(address(stream), 100);          bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));         stream.arbitraryCall(address(testTokenC), data);         assertEq(testTokenC.balanceOf(address(this)), bal);     }      {         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             startTime,             minStreamDuration,             maxDepositLockDuration,             0,             false         );          uint256 bal = testTokenC.balanceOf(address(this));         testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1000000);         bob.doStake(stream, address(testTokenB), 1000000);          bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));         bytes4 sig = sigs("arbitraryCall(address,bytes)");         expect_revert_with(             address(stream),             sig,             abi.encode(address(this), data),             "erc"         );     } }  function manualBurn(address token, address who) public {     uint256 curBal = ERC20(token).balanceOf(who);     write_balanceOf_ts(token, who, curBal - 10); }  function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {     Stream stream = Stream(msg.sender);     (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));     assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);     if (sendBackFee) {         ERC20(token).transfer(msg.sender, amount * 10 / 10000);     }     ERC20(token).transfer(msg.sender, amount);     enteredFlashloan = true;     return; }  } contract StreamFactoryTest is LockeTest {     function test_createStream() public {     // ===  EXPECTED FAILURES ===     (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();      {         // Fails         bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");         expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp - 10,                 0,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "past"         );          if (minStreamDuration &gt; 0) {             expect_revert_with(                 address(defaultStreamFactory),                 sig,                 abi.encode(                     address(0),                     address(0),                     block.timestamp,                     minStreamDuration - 1,                     0,                     0,                     false                     // false,                     // bytes32(0)                 ),                 "stream"             );         }          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 maxStreamDuration + 1,                 0,                 0,                 false                 // false,                 // bytes32(0)             ),             "stream"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration + 1,                 0,                 false                 // false,                 // bytes32(0)             ),             "lock"         );          expect_revert_with(             address(defaultStreamFactory),             sig,             abi.encode(                 address(0),                 address(0),                 block.timestamp,                 minStreamDuration,                 maxDepositLockDuration,                 maxRewardLockDuration + 1,                 false                 // false,                 // bytes32(0)             ),             "reward"         );     }     // ===   ===       // === Successful ===     {         // No Fees         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 0);          // factory         assertEq(defaultStreamFactory.currStreamId(), 1);          // token         assertEq(stream.name(), "lockeTest Token B: 0");         assertEq(stream.symbol(), "lockeTTB0");          // others         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 0);         assertTrue(!feeEnabled);         assertTrue(!stream.isSale());     }      {         // With Fees         defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({             feePercent: 100,             feeEnabled: true         }));         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10), // 10 seconds in future             minStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );          (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();          // time stuff         (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();         assertEq(startTime, block.timestamp + 10);         assertEq(streamDuration, minStreamDuration);         assertEq(depositLockDuration, maxDepositLockDuration);         assertEq(rewardLockDuration, 0);          // tokens         assertEq(stream.rewardToken(), address(testTokenA));         assertEq(stream.depositToken(), address(testTokenB));          // address         // assertEq(address(uint160(uint(hash))), address(stream));          // id         assertEq(stream.streamId(), 1);          // factory         assertEq(defaultStreamFactory.currStreamId(), 2);          // token         assertEq(stream.name(), "lockeTest Token B: 1");         assertEq(stream.symbol(), "lockeTTB1");          // other         (feePercent, feeEnabled) = stream.feeParams();         assertEq(feePercent, 100);         assertTrue(feeEnabled);         assertTrue(!stream.isSale());     }     // ===   === }   function test_updateStreamParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));     StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({         maxDepositLockDuration: 1337 weeks,         maxRewardLockDuration: 1337 weeks,         maxStreamDuration: 1337 weeks,         minStreamDuration: 1337 hours     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));     defaultStreamFactory.updateStreamParams(newParams);      (         uint32 maxDepositLockDuration,         uint32 maxRewardLockDuration,         uint32 maxStreamDuration,         uint32 minStreamDuration     ) = defaultStreamFactory.streamParams();     assertEq(maxDepositLockDuration, 1337 weeks);     assertEq(maxRewardLockDuration, 1337 weeks);     assertEq(maxStreamDuration, 1337 weeks);     assertEq(minStreamDuration, 1337 hours); }  function test_updateFeeParams() public {     // set the gov to none     write_flat(address(defaultStreamFactory), "gov()", address(0));      uint16 max = 500;     StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({         feePercent: max + 1,         feeEnabled: true     });     expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "!gov"     );      // get back gov and set and check     write_flat(address(defaultStreamFactory), "gov()", address(this));      expect_revert_with(         address(defaultStreamFactory),         sigs("updateFeeParams((uint16,bool))"),         abi.encode(newParams),         "fee"     );      newParams.feePercent = 137;      defaultStreamFactory.updateFeeParams(newParams);     (         uint16 feePercent,         bool feeEnabled     ) = defaultStreamFactory.feeParams();     assertEq(feePercent, 137);     assertTrue(feeEnabled); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 19:48:42 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "./utils/LockeTest.sol";



contract StreamTest is LockeTest {
    bool enteredFlashloan = false;

    function test_fundStream() public {
        // === Setup ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint112 amt = 1337;
        emit log_named_uint("blocktime", block.timestamp);
        {
            uint64 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);
            // ===   ===


            // === Failures ===
            bytes4 sig = sigs("fundStream(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
            hevm.warp(block.timestamp + 11);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(amt),
                "time"
            );
            hevm.warp(block.timestamp - 11);
            // ===   ===

            


            // === No Fees ===

            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_no_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt);
            assertEq(rewardTokenFeeAmount, 0);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
            // ===    ===
        }


        {
            // === Fees Enabled ====
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            uint256 nextStream = defaultStreamFactory.currStreamId();
            emit log_named_uint("nextStream2", nextStream);
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenA.approve(address(stream), type(uint256).max);

            uint112 feeAmt = 13; // expected fee amt
            uint256 gas_left = gasleft();
            stream.fundStream(amt);
            emit log_named_uint("gas_usage_w_fee", gas_left - gasleft());
            (uint112 rewardTokenAmount, uint112 _unused, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(rewardTokenAmount, amt - feeAmt);
            assertEq(rewardTokenFeeAmount, feeAmt);
            assertEq(testTokenA.balanceOf(address(stream)), 1337);
        }
    }

    function test_multiUserStake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream

        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 666);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 333);
    }

    function test_multiUserStakeWithWithdraw() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false
            // bytes32(0)
        );

        testTokenA.approve(address(stream), type(uint256).max);
        stream.fundStream(1000);

        alice.doStake(stream, address(testTokenB), 100);


        hevm.warp(startTime + minStreamDuration / 2); // move to half done
        
        bob.doStake(stream, address(testTokenB), 100);

        hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);

        alice.doExit(stream); 

        hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream


        alice.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(alice)), 533);
        bob.doClaimReward(stream);
        assertEq(testTokenA.balanceOf(address(bob)), 466);
    }

    function test_stake() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        testTokenB.approve(address(stream), type(uint256).max);

        {
            // Failures
            bytes4 sig = sigs("stake(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );

            // fast forward minStreamDuration
            hevm.warp(startTime + minStreamDuration);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "!stream"
            );
            hevm.warp(startTime - minStreamDuration);

            write_balanceOf(address(testTokenB), address(stream), 2**112 + 1);
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "erc"
            );
            write_balanceOf(address(testTokenB), address(stream), 0);
        }

        {
            // Successes
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            assertEq(asLERC.balanceOf(address(this)), 100);

            {
                (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
                assertEq(depositTokenAmount, 100);
            }
            

            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 100);
            }
            
            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, 0);
                assertEq(virtualBalance, 100);
                assertEq(tokens, 100);
                assertEq(lu, startTime);
            }
            

            // move forward 1/10th of sd
            // round up to next second
            hevm.warp(startTime + minStreamDuration / 10 + 1);
            uint256 rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 91);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 101);
                assertEq(tokens, 91);
                assertEq(lu, block.timestamp);
            }
            

            hevm.warp(startTime + (2*minStreamDuration) / 10 + 1);
            rewardPerToken = stream.rewardPerToken();
            stream.stake(1);
            
            {
                uint112 unstreamed = stream.unstreamed();
                assertEq(unstreamed, 82);
            }

            {
                (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
                assertEq(lastCumulativeRewardPerToken, rewardPerToken);
                assertEq(virtualBalance, 102);
                assertEq(tokens, 82);
                assertEq(lu, block.timestamp);
            }
            

        }
        {
            hevm.warp(1609459200); // jan 1, 2021          
            // Sale test
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );
            testTokenB.approve(address(stream), type(uint256).max);
            stream.stake(100);
            LockeERC20 asLERC = LockeERC20(stream);
            // no tokens wen sale
            assertEq(asLERC.balanceOf(address(this)), 0);

            (uint112 rewardTokenAmount, uint112 depositTokenAmount, uint112 rewardTokenFeeAmount, ) = stream.tokenAmounts();
            assertEq(depositTokenAmount, 100);
            (uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lu, ) = stream.tokensNotYetStreamed(address(this));
            assertEq(tokens, 100);
        }
    }

    function test_createIncentive() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);
        Stream stream = defaultStreamFactory.createStream(
            address(testTokenA),
            address(testTokenB),
            startTime,
            minStreamDuration,
            maxDepositLockDuration,
            0,
            false
            // false,
            // bytes32(0)
        );

        bytes4 sig = sigs("createIncentive(address,uint112)");
        expect_revert_with(
            address(stream),
            sig,
            abi.encode(address(testTokenA), 0),
            "inc"
        );

        uint256 bal = testTokenC.balanceOf(address(this));
        testTokenC.approve(address(stream), type(uint256).max);
        stream.createIncentive(address(testTokenC), 100);
        assertEq(stream.incentives(address(testTokenC)), 100);

        hevm.warp(startTime + minStreamDuration);
        stream.claimIncentive(address(testTokenC));
        assertEq(testTokenC.balanceOf(address(this)), bal);
    }


    function test_claimDeposit() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(0),
                "amt"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(100),
                "lock"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock);
            bytes4 sig = sigs("claimDepositTokens(uint112)");
            expect_revert(
                address(stream),
                sig,
                abi.encode(101)
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);

            hevm.warp(endDepositLock + 1);
            stream.claimDepositTokens(100);
            assertEq(testTokenB.balanceOf(address(this)), bal);
        }
    }

    function test_creatorClaimTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!sale"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "claimed"
            );
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = alice.doCreateStream(defaultStreamFactory, true);

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "!creator"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            bytes4 sig = sigs("creatorClaimSoldTokens(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                true
                // false,
                // bytes32(0)
            );

            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.approve(address(stream), type(uint256).max);

            stream.stake(100);
            hevm.warp(endStream);
            stream.creatorClaimSoldTokens(address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_claimFees() public {

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);

            bob.failClaimFees(stream);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            bytes4 sig = sigs("claimFees(address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this)),
                "stream"
            );
        }

        {
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));

            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000);
            
            uint256 feeAmt = 1000*100/10000;
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal - 1000 + feeAmt);
        }
    }

    function test_flashloan() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("flashloan(address,address,uint112,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this), 0, ""),
                "erc"
            );
            

            stream.flashloan(address(testTokenA), address(this), 1000000, abi.encode(true, testTokenA.balanceOf(address(this))));
            (,,uint112 rewardFee,) = stream.tokenAmounts();
            assertEq(rewardFee, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this), 1000000, abi.encode(false, testTokenA.balanceOf(address(this)))),
                "f4"
            );

            stream.flashloan(address(testTokenB), address(this), 1000000, abi.encode(true, testTokenB.balanceOf(address(this))));
            (,,,uint112 depositFlFees) = stream.tokenAmounts();
            assertEq(depositFlFees, 1000000 * 10 / 10000);
            assertTrue(enteredFlashloan);
            enteredFlashloan = false;

            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this), 1000000, abi.encode(false, testTokenB.balanceOf(address(this)))),
                "f1"
            );

            uint256 balA = testTokenA.balanceOf(address(this));
            uint256 balB = testTokenB.balanceOf(address(this));
            hevm.warp(endStream);
            stream.claimFees(address(this));
            assertEq(testTokenA.balanceOf(address(this)), balA + 1000000 * 10 / 10000);
            assertEq(testTokenB.balanceOf(address(this)), balB + 1000000 * 10 / 10000);
        }
    }


    function test_recoverTokens() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenB), address(this)),
                "time"
            );
            uint256 bal = testTokenB.balanceOf(address(this));
            testTokenB.transfer(address(stream), 100);
            hevm.warp(endDepositLock + 1);
            stream.recoverTokens(address(testTokenB), address(this));
            assertEq(testTokenB.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), address(this)),
                "time"
            );
            uint256 bal = testTokenA.balanceOf(address(this));
            testTokenA.transfer(address(stream), 100);
            hevm.warp(endRewardLock + 1);
            stream.recoverTokens(address(testTokenA), address(this));
            assertEq(testTokenA.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);


            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("recoverTokens(address,address)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), address(this)),
                "stream"
            );
            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream + 1);
            stream.recoverTokens(address(testTokenC), address(this));
            uint256 newbal = testTokenC.balanceOf(address(this));
            assertEq(newbal, bal);
            stream.claimIncentive(address(testTokenC));
            assertEq(testTokenC.balanceOf(address(this)), newbal + 100);
            hevm.warp(startTime - 10);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenC.transfer(address(stream), 100);
            hevm.warp(endStream);
            stream.recoverTokens(address(testTokenC), address(this));
            assertEq(testTokenC.balanceOf(address(this)), bal);
            hevm.warp(startTime - 10);
        }
    }

    function test_arbitraryCall() public {
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        uint32 startTime = uint32(block.timestamp + 10);

        uint32 endStream = startTime + minStreamDuration;
        uint32 endDepositLock = endStream + maxDepositLockDuration;
        uint32 endRewardLock = endStream + 0;
        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.approve(address(stream), type(uint256).max);
            stream.createIncentive(address(testTokenC), 100);

            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenC), ""),
                "inc"
            );
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(testTokenA), ""),
                "erc"
            );
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            testTokenC.transfer(address(stream), 100);

            bytes memory data = abi.encodePacked(sigs("transfer(address,uint256)"), abi.encode(address(this), 100));
            stream.arbitraryCall(address(testTokenC), data);
            assertEq(testTokenC.balanceOf(address(this)), bal);
        }

        {
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                startTime,
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
            );

            uint256 bal = testTokenC.balanceOf(address(this));
            testTokenA.approve(address(stream), type(uint256).max);
            stream.fundStream(1000000);
            bob.doStake(stream, address(testTokenB), 1000000);

            bytes memory data = abi.encodePacked(sigs("manualBurn(address,address)"), abi.encode(address(testTokenA), address(stream)));
            bytes4 sig = sigs("arbitraryCall(address,bytes)");
            expect_revert_with(
                address(stream),
                sig,
                abi.encode(address(this), data),
                "erc"
            );
        }
    }

    function manualBurn(address token, address who) public {
        uint256 curBal = ERC20(token).balanceOf(who);
        write_balanceOf_ts(token, who, curBal - 10);
    }

    function lockeCall(address originator, address token, uint256 amount, bytes memory data) public {
        Stream stream = Stream(msg.sender);
        (bool sendBackFee, uint112 prevBal) = abi.decode(data, (bool, uint112));
        assertEq(ERC20(token).balanceOf(address(this)), prevBal + amount);
        if (sendBackFee) {
            ERC20(token).transfer(msg.sender, amount * 10 / 10000);
        }
        ERC20(token).transfer(msg.sender, amount);
        enteredFlashloan = true;
        return;
    }
}



contract StreamFactoryTest is LockeTest {
    function test_createStream() public {

        // ===  EXPECTED FAILURES ===
        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();

        {
            // Fails
            bytes4 sig = sigs("createStream(address,address,uint32,uint32,uint32,uint32,bool)");
            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp - 10,
                    0,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "past"
            );

            if (minStreamDuration > 0) {
                expect_revert_with(
                    address(defaultStreamFactory),
                    sig,
                    abi.encode(
                        address(0),
                        address(0),
                        block.timestamp,
                        minStreamDuration - 1,
                        0,
                        0,
                        false
                        // false,
                        // bytes32(0)
                    ),
                    "stream"
                );
            }

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    maxStreamDuration + 1,
                    0,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "stream"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration + 1,
                    0,
                    false
                    // false,
                    // bytes32(0)
                ),
                "lock"
            );

            expect_revert_with(
                address(defaultStreamFactory),
                sig,
                abi.encode(
                    address(0),
                    address(0),
                    block.timestamp,
                    minStreamDuration,
                    maxDepositLockDuration,
                    maxRewardLockDuration + 1,
                    false
                    // false,
                    // bytes32(0)
                ),
                "reward"
            );
        }
        // ===   ===
        

        // === Successful ===
        {
            // No Fees
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 0);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 1);

            // token
            assertEq(stream.name(), "lockeTest Token B: 0");
            assertEq(stream.symbol(), "lockeTTB0");

            // others
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 0);
            assertTrue(!feeEnabled);
            assertTrue(!stream.isSale());
        }
        
        {
            // With Fees
            defaultStreamFactory.updateFeeParams(StreamFactory.GovernableFeeParams({
                feePercent: 100,
                feeEnabled: true
            }));
            Stream stream = defaultStreamFactory.createStream(
                address(testTokenA),
                address(testTokenB),
                uint32(block.timestamp + 10), // 10 seconds in future
                minStreamDuration,
                maxDepositLockDuration,
                0,
                false
                // false,
                // bytes32(0)
            );

            (uint16 feePercent, bool feeEnabled) = defaultStreamFactory.feeParams();

            // time stuff
            (uint32 startTime, uint32 streamDuration, uint32 depositLockDuration, uint32 rewardLockDuration) = stream.streamParams();
            assertEq(startTime, block.timestamp + 10);
            assertEq(streamDuration, minStreamDuration);
            assertEq(depositLockDuration, maxDepositLockDuration);
            assertEq(rewardLockDuration, 0);

            // tokens
            assertEq(stream.rewardToken(), address(testTokenA));
            assertEq(stream.depositToken(), address(testTokenB));

            // address
            // assertEq(address(uint160(uint(hash))), address(stream));

            // id
            assertEq(stream.streamId(), 1);

            // factory
            assertEq(defaultStreamFactory.currStreamId(), 2);

            // token
            assertEq(stream.name(), "lockeTest Token B: 1");
            assertEq(stream.symbol(), "lockeTTB1");

            // other
            (feePercent, feeEnabled) = stream.feeParams();
            assertEq(feePercent, 100);
            assertTrue(feeEnabled);
            assertTrue(!stream.isSale());
        }
        // ===   ===
    }


    function test_updateStreamParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        StreamFactory.GovernableStreamParams memory newParams = StreamFactory.GovernableStreamParams({
            maxDepositLockDuration: 1337 weeks,
            maxRewardLockDuration: 1337 weeks,
            maxStreamDuration: 1337 weeks,
            minStreamDuration: 1337 hours
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateStreamParams((uint32,uint32,uint32,uint32))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        defaultStreamFactory.updateStreamParams(newParams);

        (
            uint32 maxDepositLockDuration,
            uint32 maxRewardLockDuration,
            uint32 maxStreamDuration,
            uint32 minStreamDuration
        ) = defaultStreamFactory.streamParams();
        assertEq(maxDepositLockDuration, 1337 weeks);
        assertEq(maxRewardLockDuration, 1337 weeks);
        assertEq(maxStreamDuration, 1337 weeks);
        assertEq(minStreamDuration, 1337 hours);
    }

    function test_updateFeeParams() public {
        // set the gov to none
        write_flat(address(defaultStreamFactory), "gov()", address(0));
        
        uint16 max = 500;
        StreamFactory.GovernableFeeParams memory newParams = StreamFactory.GovernableFeeParams({
            feePercent: max + 1,
            feeEnabled: true
        });
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "!gov"
        );

        // get back gov and set and check
        write_flat(address(defaultStreamFactory), "gov()", address(this));
        
        expect_revert_with(
            address(defaultStreamFactory),
            sigs("updateFeeParams((uint16,bool))"),
            abi.encode(newParams),
            "fee"
        );

        newParams.feePercent = 137;

        defaultStreamFactory.updateFeeParams(newParams);
        (
            uint16 feePercent,
            bool feeEnabled
        ) = defaultStreamFactory.feeParams();
        assertEq(feePercent, 137);
        assertTrue(feeEnabled);
    }
}".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

