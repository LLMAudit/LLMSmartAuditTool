[2024-22-08 11:54:49 INFO] **[Preprocessing]**

**ChatDev Starts** (20240822115449)

**Timestamp**: 20240822115449

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}


**project_name**: RealWorld_BA_61_Pool

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_61_Pool_RealWord_20240822115449.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-22-08 11:54:50 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IVerification.sol';\n\n/\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    address poolFactory;\n\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n\n    /\n     * @notice used to keep track of lenders' details\n     /\n    mapping(address =&gt; LendingDetails) public lenders;\n\n    /\n     * @notice object of type PoolConstants\n     /\n    PoolConstants public poolConstants;\n\n    /\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n\n    /\n     * @notice checks if the user is pool's valid borrower\n     * @param _user address of the borrower\n     /\n    modifier onlyBorrower(address user) {\n        require(_user == poolConstants.borrower, 'OB1');\n        ;\n    }\n\n    /\n     * @notice checks if the _lender is pool's valid lender\n     * @param _lender address of the lender\n     /\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, 'IL1');\n        ;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');\n        _;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's latest repayment implementation\n     /\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');\n        _;\n    }\n\n    /\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     /\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init('Pool Tokens', 'PT');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n\n    /\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, 'DC1');\n        require(balanceOf(msg.sender) == 0, 'DC2');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     /\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     /\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n\n    /\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet\n     /\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');\n        require(balanceOf(msg.sender) == 0, 'ACMC2');\n        require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');\n\n        require(_amount != 0, 'ACMC4');\n\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n\n        if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     /\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &amp;&amp;\n                poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;\n                block.timestamp &lt; poolConstants.loanWithdrawalDeadline,\n            'WBA1'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030), 'WBA2');\n\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');\n\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(1030);\n        delete poolConstants.loanWithdrawalDeadline;\n\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n\n    /\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n\n    /\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     /\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n\n    /\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     /\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), 'TT1');\n        }\n        require(_to != poolConstants.borrower, 'TT2');\n\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');\n        }\n        require(getMarginCallEndTime(_from) == 0, 'TT3');\n        require(getMarginCallEndTime(_to) == 0, 'TT4');\n\n        //Withdraw repayments for user\n\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp &gt; _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp &gt; _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n\n    /\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n\n        if (\n            _loanStartTime &lt; block.timestamp &amp;&amp;\n            totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030)\n        ) {\n            return _cancelPool(0);\n        }\n\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n\n        if (_loanWithdrawalDeadline &gt; block.timestamp) {\n            require(msg.sender == poolConstants.borrower, 'CP2');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(1030)\n            .mul(_collateralLiquidityShare)\n            .div(1030)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n\n    /\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n\n    /\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');\n        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n\n    /\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     /\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n\n    /\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');\n\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n\n        emit PoolClosed();\n    }\n\n    /\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     /\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            'WL1'\n        );\n\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n\n    /\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     /\n\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');\n\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n\n        emit MarginCalled(msg.sender);\n    }\n\n    /\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(1030);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(1030));\n        if (_loanDurationTillNow &lt;= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(1060);\n\n        return _interestAccrued;\n    }\n\n    /\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(1030).div(_balance.add(_interest));\n    }\n\n    /\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n\n    /\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     /\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n\n    /\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n\n    /\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     /\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');\n        require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');\n\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');\n        require(balanceOf(_lender) != 0, 'CLBL5');\n    }\n\n    /\n     * @notice used to add extra liquidity shares to lender's share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     /\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n\n    /\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n\n    /\n     * @notice used to liquidate lender and burn lender's shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n\n    /\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     /\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10_decimals).mul(uint256(1030).sub(_fraction)).div(1030);\n    }\n\n    /\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     /\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n\n    /\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     /\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n\n    /\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n\n    /\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     /\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n\n        return _amountWithdrawable;\n    }\n\n    /\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     /\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n\n    /\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     /\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n\n        if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n\n    /\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     /\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n\n    /\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n\n    /\n     * @notice used to receive ethers from savings accounts\n     /\n    receive() external payable {}\n\n    /\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     /\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10_decimals);\n    }\n\n    /\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     /\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n\n    /\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     /\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:54:50 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:54:50 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-22-08 11:54:53 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:54:53 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19926
completion_tokens: 1
total_tokens: 19927
cost: $-1.000000


[2024-22-08 11:54:53 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Let's

[2024-22-08 11:54:55 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\';\nimport \'@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol\';\nimport \'../interfaces/IPoolFactory.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/IRepayment.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IPool.sol\';\nimport \'../interfaces/IExtension.sol\';\nimport \'../interfaces/IVerification.sol\';\n/\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n    address poolFactory;\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n    /\n     * @notice used to keep track of lenders\' details\n     /\n    mapping(address =&gt; LendingDetails) public lenders;\n    /\n     * @notice object of type PoolConstants\n     /\n    PoolConstants public poolConstants;\n    /\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n    /\n     * @notice checks if the user is pool\'s valid borrower\n     * @param _user address of the borrower\n     /\n    modifier onlyBorrower(address user) {\n        require(_user == poolConstants.borrower, \'OB1\');\n        ;\n    }\n    /\n     * @notice checks if the _lender is pool\'s valid lender\n     * @param _lender address of the lender\n     /\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, \'IL1\');\n        ;\n    }\n    /\n     * @notice checks if the msg.sender is pool\'s valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), \'OO1\');\n        _;\n    }\n    /\n     * @notice checks if the msg.sender is pool\'s latest repayment implementation\n     /\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), \'OR1\');\n        _;\n    }\n    /\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender\'s savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     /\n    function initialize(\n        uint256 borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init(\'Pool Tokens\', \'PT\');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n    /\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender\'s savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, \'DC1\');\n        require(balanceOf(msg.sender) == 0, \'DC2\');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n    /\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender\'s savings account, if false, it is transferred from their wallet\n     /\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), \'ID1\');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n    /\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender\'s savings account, if false, it is transferred from _sender\'s wallet\n     /\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n    /\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender\'s savings account, if false, it is transferred from _sender\'s wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool\'s savings account, if false, it is withdrawn from _sender\'s savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n    /\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower\'s savings account, if false, it is transferred from borrower\'s wallet\n     /\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, \'ACMC1\');\n        require(balanceOf(msg.sender) == 0, \'ACMC2\');\n        require(getMarginCallEndTime(_lender) &gt;= block.timestamp, \'ACMC3\');\n        require(_amount != 0, \'ACMC4\');\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n        if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n    /\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     /\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &amp;&amp;\n                poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;\n                block.timestamp &lt; poolConstants.loanWithdrawalDeadline,\n            \'WBA1\'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030), \'WBA2\');\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, \'WBA3\');\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(1030);\n        delete poolConstants.loanWithdrawalDeadline;\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n    /\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n    /\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     /\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower &amp;&amp; _borrower != msg.sender, \'L1\');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), \'L2\');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, \'L3\');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n    /\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     /\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), \'TT1\');\n        }\n        require(_to != poolConstants.borrower, \'TT2\');\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), \'TT5\');\n        }\n        require(getMarginCallEndTime(_from) == 0, \'TT3\');\n        require(getMarginCallEndTime(_to) == 0, \'TT4\');\n        //Withdraw repayments for user\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to\'s effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp &gt; _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp &gt; _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n    /\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, \'CP1\');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        if (\n            _loanStartTime &lt; block.timestamp &amp;&amp;\n            totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030)\n        ) {\n            return _cancelPool(0);\n        }\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n        if (_loanWithdrawalDeadline &gt; block.timestamp) {\n            require(msg.sender == poolConstants.borrower, \'CP2\');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(1030)\n            .mul(_collateralLiquidityShare)\n            .div(1030)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n    /\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n    /\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn\'t matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender\'s savings account. If false, liquidity transfered to lender\'s wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, \'LCP1\');\n        require(poolVariables.penaltyLiquidityAmount == 0, \'LCP2\');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n    /\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     /\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n    /\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, \'CL1\');\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n        emit PoolClosed();\n    }\n    /\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     /\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            \'WL1\'\n        );\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n    /\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     /\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, \'RMC1\');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, \'RMC2\');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), \'RMC3\');\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n        emit MarginCalled(msg.sender);\n    }\n    /\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(1030);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(1030));\n        if (_loanDurationTillNow &lt;= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(1060);\n        return _interestAccrued;\n    }\n    /\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(1030).div(_balance.add(_interest));\n    }\n    /\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n    /\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     /\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n    /\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender\'s savings account, if false, it is transferred from sender\'s wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender\'s savings account. If false, liquidity transfered to sender\'s wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, \'LP1\');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), \'LP2\');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n    /\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver\'s savings account. If false, liquidity transfered to receiver\'s wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n    /\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     /\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), \'CLBL1\');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, \'CLBL2\');\n        require(_marginCallEndTime &lt; block.timestamp, \'CLBL3\');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), \'CLBL4\');\n        require(balanceOf(_lender) != 0, \'CLBL5\');\n    }\n    /\n     * @notice used to add extra liquidity shares to lender\'s share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     /\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n    /\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender\'s savings account, if false, it is transferred from lender\'s wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n    /\n     * @notice used to liquidate lender and burn lender\'s shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender\'s savings account, if false, it is transferred from lender\'s wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver\'s savings account. If false, liquidity transfered to receiver\'s wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n    /\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     /\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10_decimals).mul(uint256(1030).sub(_fraction)).div(1030);\n    }\n    /\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     /\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n    /\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     /\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n    /\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, \'34\')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n    /\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     /\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n        return _amountWithdrawable;\n    }\n    /\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     /\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n    /\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n    /\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     /\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n    /\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     /\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n    /\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n    /\n     * @notice used to receive ethers from savings accounts\n     /\n    receive() external payable {}\n    /\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     /\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10_decimals);\n    }\n    /\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     /\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n    /\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     /\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\';\nimport \'@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol\';\nimport \'../interfaces/IPoolFactory.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/IRepayment.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IPool.sol\';\nimport \'../interfaces/IExtension.sol\';\nimport \'../interfaces/IVerification.sol\';\n/\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n    address poolFactory;\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n    /\n     * @notice used to keep track of lenders\' details\n     /\n    mapping(address =&gt; LendingDetails) public lenders;\n    /\n     * @notice object of type PoolConstants\n     /\n    PoolConstants public poolConstants;\n    /\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n    /\n     * @notice checks if the _user is pool\'s valid borrower\n     * @param _user address of the borrower\n     /\n    modifier onlyBorrower(address user) {\n        require(_user == poolConstants.borrower, \'OB1\');\n        ;\n    }\n    /\n     * @notice checks if the _lender is pool\'s valid lender\n     * @param _lender address of the lender\n     /\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, \'IL1\');\n        ;\n    }\n    /\n     * @notice checks if the msg.sender is pool\'s valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), \'OO1\');\n        _;\n    }\n    /\n     * @notice checks if the msg.sender is pool\'s latest repayment implementation\n     /\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), \'OR1\');\n        _;\n    }\n    /\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender\'s savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     /\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init(\'Pool Tokens\', \'PT\');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n    /\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender\'s savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, \'DC1\');\n        require(balanceOf(msg.sender) == 0, \'DC2\');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n    /\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender\'s savings account, if false, it is transferred from their wallet\n     /\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), \'ID1\');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n    /\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender\'s savings account, if false, it is transferred from _sender\'s wallet\n     /\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n    /\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender\'s savings account, if false, it is transferred from _sender\'s wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool\'s savings account, if false, it is withdrawn from _sender\'s savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n    /\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower\'s savings account, if false, it is transferred from borrower\'s wallet\n     /\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, \'ACMC1\');\n        require(balanceOf(msg.sender) == 0, \'ACMC2\');\n        require(getMarginCallEndTime(_lender) &gt;= block.timestamp, \'ACMC3\');\n        require(_amount != 0, \'ACMC4\');\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n        if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n    /\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     /\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &amp;&amp;\n                poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;\n                block.timestamp &lt; poolConstants.loanWithdrawalDeadline,\n            \'WBA1\'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030), \'WBA2\');\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, \'WBA3\');\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(1030);\n        delete poolConstants.loanWithdrawalDeadline;\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n    /\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n    /\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     /\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower &amp;&amp; _borrower != msg.sender, \'L1\');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), \'L2\');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, \'L3\');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n    /\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     /\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), \'TT1\');\n        }\n        require(_to != poolConstants.borrower, \'TT2\');\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), \'TT5\');\n        }\n        require(getMarginCallEndTime(_from) == 0, \'TT3\');\n        require(getMarginCallEndTime(_to) == 0, \'TT4\');\n        //Withdraw repayments for user\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to\'s effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp &gt; _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp &gt; _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n    /\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, \'CP1\');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        if (\n            _loanStartTime &lt; block.timestamp &amp;&amp;\n            totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030)\n        ) {\n            return _cancelPool(0);\n        }\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n        if (_loanWithdrawalDeadline &gt; block.timestamp) {\n            require(msg.sender == poolConstants.borrower, \'CP2\');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(1030)\n            .mul(_collateralLiquidityShare)\n            .div(1030)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n    /\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n    /\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn\'t matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender\'s savings account. If false, liquidity transfered to lender\'s wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, \'LCP1\');\n        require(poolVariables.penaltyLiquidityAmount == 0, \'LCP2\');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n    /\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     /\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n    /\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, \'CL1\');\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n        emit PoolClosed();\n    }\n    /\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     /\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            \'WL1\'\n        );\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n    /\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     /\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, \'RMC1\');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, \'RMC2\');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), \'RMC3\');\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n        emit MarginCalled(msg.sender);\n    }\n    /\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(1030);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(1030));\n        if (_loanDurationTillNow &lt;= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(1060);\n        return _interestAccrued;\n    }\n    /\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(1030).div(_balance.add(_interest));\n    }\n    /\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n    /\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     /\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n    /\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender\'s savings account, if false, it is transferred from sender\'s wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender\'s savings account. If false, liquidity transfered to sender\'s wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, \'LP1\');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), \'LP2\');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n    /\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver\'s savings account. If false, liquidity transfered to receiver\'s wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n    /\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     /\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), \'CLBL1\');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, \'CLBL2\');\n        require(_marginCallEndTime &lt; block.timestamp, \'CLBL3\');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), \'CLBL4\');\n        require(balanceOf(_lender) != 0, \'CLBL5\');\n    }\n    /\n     * @notice used to add extra liquidity shares to lender\'s share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     /\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n    /\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender\'s savings account, if false, it is transferred from lender\'s wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n    /\n     * @notice used to liquidate lender and burn lender\'s shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender\'s savings account, if false, it is transferred from lender\'s wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver\'s savings account. If false, liquidity transfered to receiver\'s wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n    /\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     /\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10_decimals).mul(uint256(1030).sub(_fraction)).div(1030);\n    }\n    /\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     /\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n    /\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     /\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n    /\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, \'34\')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n    /\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     /\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n        return _amountWithdrawable;\n    }\n    /\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     /\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n    /\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n    /\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     /\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n    /\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     /\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n    /\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n    /\n     * @notice used to receive ethers from savings accounts\n     /\n    receive() external payable {}\n    /\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     /\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10_decimals);\n    }\n    /\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     /\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n    /\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     /\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:54:55 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:54:55 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';
/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }
    address poolFactory;
    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }
    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }
    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }
    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;
    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;
    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;
    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }
    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }
    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }
    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }
    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;
        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }
    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }
    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }
    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }
    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }
    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');
        require(_amount != 0, 'ACMC4');
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);
        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);
        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }
        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }
    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');
        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');
        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);
        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;
        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);
        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);
        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }
    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);
        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;
        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }
    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }
        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }
    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');
        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');
        //Withdraw repayments for user
        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);
        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;
        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }
        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }
    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }
    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }
        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;
        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }
    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }
    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);
        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }
    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }
    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');
        poolVariables.loanStatus = LoanStatus.CLOSED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();
        emit PoolClosed();
    }
    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;
        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );
        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;
        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }
        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }
        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);
        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);
        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }
    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */
    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');
        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());
        emit MarginCalled(msg.sender);
    }
    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);
        return _interestAccrued;
    }
    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);
        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }
    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }
    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );
        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }
    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;
        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);
        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }
    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }
    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }
    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);
        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);
        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }
    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }
    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);
        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);
        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);
        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }
    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }
    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }
    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }
    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }
    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );
        return _amountWithdrawable;
    }
    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }
    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);
        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }
    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }
    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }
    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }
    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}
    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }
    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }
    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';
/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }
    address poolFactory;
    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }
    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }
    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }
    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;
    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;
    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;
    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }
    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }
    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }
    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }
    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;
        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }
    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }
    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }
    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }
    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }
    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');
        require(_amount != 0, 'ACMC4');
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);
        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);
        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }
        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }
    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');
        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');
        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);
        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;
        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);
        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);
        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }
    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);
        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;
        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }
    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }
        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }
    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');
        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');
        //Withdraw repayments for user
        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);
        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;
        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }
        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }
    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }
    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }
        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;
        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }
    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }
    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);
        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }
    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }
    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');
        poolVariables.loanStatus = LoanStatus.CLOSED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();
        emit PoolClosed();
    }
    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;
        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );
        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;
        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }
        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }
        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);
        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);
        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }
    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */
    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');
        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());
        emit MarginCalled(msg.sender);
    }
    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);
        return _interestAccrued;
    }
    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);
        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }
    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }
    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );
        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }
    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;
        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);
        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }
    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }
    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }
    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);
        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);
        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }
    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }
    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);
        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);
        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);
        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }
    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }
    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }
    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }
    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }
    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );
        return _amountWithdrawable;
    }
    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }
    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);
        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }
    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }
    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }
    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }
    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}
    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }
    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }
    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-22-08 11:54:59 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:54:59 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 29946
completion_tokens: 1
total_tokens: 29947
cost: $-1.000000


[2024-22-08 11:54:59 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Security

[2024-22-08 11:54:59 INFO] **[Seminar Conclusion]**:

 Security

[2024-22-08 11:54:59 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-22-08 11:54:59 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-22-08 11:55:00 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IVerification.sol';\n\n/\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    address poolFactory;\n\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n\n    /\n     * @notice used to keep track of lenders' details\n     /\n    mapping(address =&gt; LendingDetails) public lenders;\n\n    /\n     * @notice object of type PoolConstants\n     /\n    PoolConstants public poolConstants;\n\n    /\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n\n    /\n     * @notice checks if the user is pool's valid borrower\n     * @param _user address of the borrower\n     /\n    modifier onlyBorrower(address user) {\n        require(_user == poolConstants.borrower, 'OB1');\n        ;\n    }\n\n    /\n     * @notice checks if the _lender is pool's valid lender\n     * @param _lender address of the lender\n     /\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, 'IL1');\n        ;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');\n        _;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's latest repayment implementation\n     /\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');\n        _;\n    }\n\n    /\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     /\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init('Pool Tokens', 'PT');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n\n    /\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, 'DC1');\n        require(balanceOf(msg.sender) == 0, 'DC2');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     /\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     /\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n\n    /\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet\n     /\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');\n        require(balanceOf(msg.sender) == 0, 'ACMC2');\n        require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');\n\n        require(_amount != 0, 'ACMC4');\n\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n\n        if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     /\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &amp;&amp;\n                poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;\n                block.timestamp &lt; poolConstants.loanWithdrawalDeadline,\n            'WBA1'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030), 'WBA2');\n\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');\n\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(1030);\n        delete poolConstants.loanWithdrawalDeadline;\n\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n\n    /\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n\n    /\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     /\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n\n    /\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     /\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), 'TT1');\n        }\n        require(_to != poolConstants.borrower, 'TT2');\n\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');\n        }\n        require(getMarginCallEndTime(_from) == 0, 'TT3');\n        require(getMarginCallEndTime(_to) == 0, 'TT4');\n\n        //Withdraw repayments for user\n\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp &gt; _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp &gt; _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n\n    /\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n\n        if (\n            _loanStartTime &lt; block.timestamp &amp;&amp;\n            totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030)\n        ) {\n            return _cancelPool(0);\n        }\n\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n\n        if (_loanWithdrawalDeadline &gt; block.timestamp) {\n            require(msg.sender == poolConstants.borrower, 'CP2');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(1030)\n            .mul(_collateralLiquidityShare)\n            .div(1030)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n\n    /\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n\n    /\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');\n        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n\n    /\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     /\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n\n    /\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');\n\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n\n        emit PoolClosed();\n    }\n\n    /\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     /\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            'WL1'\n        );\n\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n\n    /\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     /\n\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');\n\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n\n        emit MarginCalled(msg.sender);\n    }\n\n    /\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(1030);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(1030));\n        if (_loanDurationTillNow &lt;= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(1060);\n\n        return _interestAccrued;\n    }\n\n    /\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(1030).div(_balance.add(_interest));\n    }\n\n    /\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n\n    /\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     /\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n\n    /\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n\n    /\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     /\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');\n        require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');\n\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');\n        require(balanceOf(_lender) != 0, 'CLBL5');\n    }\n\n    /\n     * @notice used to add extra liquidity shares to lender's share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     /\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n\n    /\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n\n    /\n     * @notice used to liquidate lender and burn lender's shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n\n    /\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     /\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10_decimals).mul(uint256(1030).sub(_fraction)).div(1030);\n    }\n\n    /\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     /\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n\n    /\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     /\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n\n    /\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n\n    /\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     /\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n\n        return _amountWithdrawable;\n    }\n\n    /\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     /\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n\n    /\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     /\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n\n        if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n\n    /\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     /\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n\n    /\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n\n    /\n     * @notice used to receive ethers from savings accounts\n     /\n    receive() external payable {}\n\n    /\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     /\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10_decimals);\n    }\n\n    /\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     /\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n\n    /\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     /\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:55:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:55:00 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 11:55:03 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:55:03 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19917
completion_tokens: 1
total_tokens: 19918
cost: $-1.000000


[2024-22-08 11:55:03 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

###

[2024-22-08 11:55:03 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 11:55:03 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-22-08 11:55:03 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:55:03 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:55:03 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 11:55:16 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:55:16 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10018
completion_tokens: 828
total_tokens: 10846
cost: $-1.000000


[2024-22-08 11:55:16 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Based on the provided smart contract code for the Pool contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `nonReentrant` modifiers in several functions, there are still areas where reentrancy could be exploited, especially in functions that involve external calls (e.g., `_withdrawRepayment`, `lend`, `liquidatePool`). Careful attention is needed to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The contract relies on certain modifiers (e.g., `onlyBorrower`, `onlyOwner`, `onlyRepaymentImpl`) to restrict access to specific functions. However, if the underlying logic for determining the owner or borrower is compromised, unauthorized access could occur. The contract should implement more robust access control mechanisms.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where potential overflow/underflow could occur if the library is not used consistently. It is crucial to ensure that all arithmetic operations are safeguarded.

4. **Improper Error Handling**:
   - The contract uses `require` statements for error handling, which is good practice. However, there are instances where the error messages are not descriptive enough (e.g., 'IL1', 'WBA1'). More informative error messages would aid in debugging and understanding the context of failures.

5. **Lack of Event Emission**:
   - Certain critical state changes (e.g., when collateral is deposited or withdrawn) do not emit events. This lack of transparency can hinder tracking and auditing of contract activities.

6. **Potential for Front-Running**:
   - Functions that involve financial transactions (e.g., lending, withdrawing) could be susceptible to front-running attacks. Implementing mechanisms to mitigate this risk, such as commit-reveal schemes, could enhance security.

7. **Gas Limit and Loops**:
   - The contract contains functions that could potentially run into gas limit issues due to loops or extensive calculations (e.g., `calculateCollateralRatio`). It is essential to ensure that these functions are optimized to prevent out-of-gas errors.

8. **Upgradeability Risks**:
   - The contract uses OpenZeppelin's upgradeable contracts. If the upgrade mechanism is not properly managed, it could lead to vulnerabilities during upgrades. Ensuring that only authorized entities can perform upgrades is critical.

### Comprehensive Analysis Report:

The Pool contract is a complex financial instrument that facilitates lending and borrowing through a decentralized mechanism. While it incorporates several security best practices, such as using `SafeMath` and `nonReentrant` modifiers, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy** remains a significant concern, especially in functions that involve external calls. It is imperative to ensure that state changes occur before any external interactions to mitigate this risk.

2. **Access control** mechanisms should be reinforced to prevent unauthorized access to critical functions. Implementing role-based access control could enhance security.

3. The contract should consistently utilize `SafeMath` for all arithmetic operations to prevent potential overflow and underflow vulnerabilities.

4. **Error handling** should be improved with more descriptive messages to facilitate easier debugging and understanding of failures.

5. The omission of event emissions for critical state changes can lead to a lack of transparency. Emitting events for all significant actions will enhance auditability.

6. **Front-running** risks should be mitigated through appropriate mechanisms to protect users from potential financial losses.

7. Functions that could run into gas limit issues should be optimized to ensure smooth execution without hitting gas limits.

8. Finally, the upgradeability of the contract must be managed carefully to prevent unauthorized upgrades that could introduce vulnerabilities.

In conclusion, while the Pool contract demonstrates a solid foundation for a decentralized lending platform, addressing the identified vulnerabilities is crucial for ensuring the security and integrity of the contract. A thorough audit and continuous monitoring of the contract post-deployment will be essential to safeguard against potential exploits.

[2024-22-08 11:55:16 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the Pool contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `nonReentrant` modifiers in several functions, there are still areas where reentrancy could be exploited, especially in functions that involve external calls (e.g., `_withdrawRepayment`, `lend`, `liquidatePool`). Careful attention is needed to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The contract relies on certain modifiers (e.g., `onlyBorrower`, `onlyOwner`, `onlyRepaymentImpl`) to restrict access to specific functions. However, if the underlying logic for determining the owner or borrower is compromised, unauthorized access could occur. The contract should implement more robust access control mechanisms.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where potential overflow/underflow could occur if the library is not used consistently. It is crucial to ensure that all arithmetic operations are safeguarded.

4. **Improper Error Handling**:
   - The contract uses `require` statements for error handling, which is good practice. However, there are instances where the error messages are not descriptive enough (e.g., 'IL1', 'WBA1'). More informative error messages would aid in debugging and understanding the context of failures.

5. **Lack of Event Emission**:
   - Certain critical state changes (e.g., when collateral is deposited or withdrawn) do not emit events. This lack of transparency can hinder tracking and auditing of contract activities.

6. **Potential for Front-Running**:
   - Functions that involve financial transactions (e.g., lending, withdrawing) could be susceptible to front-running attacks. Implementing mechanisms to mitigate this risk, such as commit-reveal schemes, could enhance security.

7. **Gas Limit and Loops**:
   - The contract contains functions that could potentially run into gas limit issues due to loops or extensive calculations (e.g., `calculateCollateralRatio`). It is essential to ensure that these functions are optimized to prevent out-of-gas errors.

8. **Upgradeability Risks**:
   - The contract uses OpenZeppelin's upgradeable contracts. If the upgrade mechanism is not properly managed, it could lead to vulnerabilities during upgrades. Ensuring that only authorized entities can perform upgrades is critical.

### Comprehensive Analysis Report:

The Pool contract is a complex financial instrument that facilitates lending and borrowing through a decentralized mechanism. While it incorporates several security best practices, such as using `SafeMath` and `nonReentrant` modifiers, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy** remains a significant concern, especially in functions that involve external calls. It is imperative to ensure that state changes occur before any external interactions to mitigate this risk.

2. **Access control** mechanisms should be reinforced to prevent unauthorized access to critical functions. Implementing role-based access control could enhance security.

3. The contract should consistently utilize `SafeMath` for all arithmetic operations to prevent potential overflow and underflow vulnerabilities.

4. **Error handling** should be improved with more descriptive messages to facilitate easier debugging and understanding of failures.

5. The omission of event emissions for critical state changes can lead to a lack of transparency. Emitting events for all significant actions will enhance auditability.

6. **Front-running** risks should be mitigated through appropriate mechanisms to protect users from potential financial losses.

7. Functions that could run into gas limit issues should be optimized to ensure smooth execution without hitting gas limits.

8. Finally, the upgradeability of the contract must be managed carefully to prevent unauthorized upgrades that could introduce vulnerabilities.

In conclusion, while the Pool contract demonstrates a solid foundation for a decentralized lending platform, addressing the identified vulnerabilities is crucial for ensuring the security and integrity of the contract. A thorough audit and continuous monitoring of the contract post-deployment will be essential to safeguard against potential exploits.

[2024-22-08 11:55:16 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-22-08 11:55:16 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IVerification.sol';\n\n/\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    address poolFactory;\n\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n\n    /\n     * @notice used to keep track of lenders' details\n     /\n    mapping(address =&gt; LendingDetails) public lenders;\n\n    /\n     * @notice object of type PoolConstants\n     /\n    PoolConstants public poolConstants;\n\n    /\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n\n    /\n     * @notice checks if the user is pool's valid borrower\n     * @param _user address of the borrower\n     /\n    modifier onlyBorrower(address user) {\n        require(_user == poolConstants.borrower, 'OB1');\n        ;\n    }\n\n    /\n     * @notice checks if the _lender is pool's valid lender\n     * @param _lender address of the lender\n     /\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, 'IL1');\n        ;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');\n        _;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's latest repayment implementation\n     /\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');\n        _;\n    }\n\n    /\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     /\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init('Pool Tokens', 'PT');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n\n    /\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, 'DC1');\n        require(balanceOf(msg.sender) == 0, 'DC2');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     /\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     /\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n\n    /\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet\n     /\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');\n        require(balanceOf(msg.sender) == 0, 'ACMC2');\n        require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');\n\n        require(_amount != 0, 'ACMC4');\n\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n\n        if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     /\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &amp;&amp;\n                poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;\n                block.timestamp &lt; poolConstants.loanWithdrawalDeadline,\n            'WBA1'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030), 'WBA2');\n\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');\n\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(1030);\n        delete poolConstants.loanWithdrawalDeadline;\n\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n\n    /\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n\n    /\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     /\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n\n    /\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     /\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), 'TT1');\n        }\n        require(_to != poolConstants.borrower, 'TT2');\n\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');\n        }\n        require(getMarginCallEndTime(_from) == 0, 'TT3');\n        require(getMarginCallEndTime(_to) == 0, 'TT4');\n\n        //Withdraw repayments for user\n\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp &gt; _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp &gt; _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n\n    /\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n\n        if (\n            _loanStartTime &lt; block.timestamp &amp;&amp;\n            totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030)\n        ) {\n            return _cancelPool(0);\n        }\n\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n\n        if (_loanWithdrawalDeadline &gt; block.timestamp) {\n            require(msg.sender == poolConstants.borrower, 'CP2');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(1030)\n            .mul(_collateralLiquidityShare)\n            .div(1030)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n\n    /\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n\n    /\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');\n        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n\n    /\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     /\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n\n    /\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');\n\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n\n        emit PoolClosed();\n    }\n\n    /\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     /\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            'WL1'\n        );\n\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n\n    /\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     /\n\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');\n\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n\n        emit MarginCalled(msg.sender);\n    }\n\n    /\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(1030);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(1030));\n        if (_loanDurationTillNow &lt;= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(1060);\n\n        return _interestAccrued;\n    }\n\n    /\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(1030).div(_balance.add(_interest));\n    }\n\n    /\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n\n    /\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     /\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n\n    /\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n\n    /\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     /\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');\n        require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');\n\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');\n        require(balanceOf(_lender) != 0, 'CLBL5');\n    }\n\n    /\n     * @notice used to add extra liquidity shares to lender's share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     /\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n\n    /\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n\n    /\n     * @notice used to liquidate lender and burn lender's shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n\n    /\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     /\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10_decimals).mul(uint256(1030).sub(_fraction)).div(1030);\n    }\n\n    /\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     /\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n\n    /\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     /\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n\n    /\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n\n    /\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     /\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n\n        return _amountWithdrawable;\n    }\n\n    /\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     /\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n\n    /\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     /\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n\n        if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n\n    /\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     /\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n\n    /\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n\n    /\n     * @notice used to receive ethers from savings accounts\n     /\n    receive() external payable {}\n\n    /\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     /\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10_decimals);\n    }\n\n    /\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     /\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n\n    /\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     /\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:55:16 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:55:16 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 11:55:19 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:55:19 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19917
completion_tokens: 1
total_tokens: 19918
cost: $-1.000000


[2024-22-08 11:55:19 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

###

[2024-22-08 11:55:19 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 11:55:19 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-22-08 11:55:19 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:55:19 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:55:19 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 11:55:31 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:55:31 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10018
completion_tokens: 811
total_tokens: 10829
cost: $-1.000000


[2024-22-08 11:55:32 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Based on the provided Solidity smart contract code for the "Pool" contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `nonReentrant` modifiers in several functions, there are still areas where reentrancy could potentially be exploited, especially in functions that involve external calls to other contracts (e.g., `_withdrawRepayment`, `_deposit`, and `_withdraw`).

2. **Access Control Issues**:
   - The contract relies on certain roles (like borrower and owner) but does not have a robust mechanism to ensure that only authorized users can execute sensitive functions. For example, the `cancelPool` function can be called by anyone if the conditions are met, which could lead to unauthorized cancellations.

3. **Lack of Input Validation**:
   - Some functions do not adequately validate input parameters. For instance, in the `initialize` function, there is no check to ensure that the provided addresses (like `_borrowAsset`, `_collateralAsset`, etc.) are valid contracts.

4. **Potential for Integer Overflow/Underflow**:
   - While the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not handled correctly, especially in calculations involving user balances and shares.

5. **Gas Limit and Loops**:
   - Functions that involve iterating over mappings or arrays (like `_beforeTokenTransfer`) could run into gas limit issues if the number of lenders or transactions grows significantly.

6. **Improper Handling of Ether**:
   - The contract has a `receive()` function to accept Ether, but there is no clear mechanism to handle or withdraw Ether, which could lead to funds being locked in the contract.

7. **Lack of Event Emission**:
   - Some critical state changes do not emit events, which can hinder tracking and debugging. For example, functions that change the loan status or modify balances should emit corresponding events.

8. **Potential for Front-Running Attacks**:
   - The contract does not implement any measures to prevent front-running, which could allow malicious actors to exploit timing differences in transactions.

9. **Inadequate Handling of Failed External Calls**:
   - The contract does not check the return values of external calls, which could lead to unexpected behavior if those calls fail.

### Comprehensive Analysis Report:

The "Pool" contract presents a complex structure with several functionalities related to lending and borrowing. However, it is crucial to address the identified vulnerabilities to ensure the security and reliability of the contract. 

1. **Reentrancy Protection**: While the use of `nonReentrant` modifiers is a good practice, further scrutiny is needed to ensure that all external calls are adequately protected against reentrancy attacks. Consider implementing checks-effects-interactions patterns.

2. **Access Control**: Implement more granular access control mechanisms, such as role-based access control (RBAC), to ensure that only authorized users can perform sensitive actions.

3. **Input Validation**: Enhance input validation to ensure that all parameters are checked for validity before processing. This includes checking for zero addresses and ensuring that amounts are positive.

4. **Gas Optimization**: Review functions for potential gas limit issues, especially those that involve loops or mappings. Consider optimizing these functions or limiting their usage.

5. **Event Emission**: Ensure that all state-changing functions emit appropriate events to facilitate tracking and auditing of contract activities.

6. **Front-Running Mitigation**: Implement measures to mitigate front-running risks, such as using commit-reveal schemes or time-locks for sensitive operations.

7. **Error Handling**: Ensure that all external calls are checked for success and handle failures gracefully to prevent unexpected contract states.

By addressing these vulnerabilities, the contract can be significantly strengthened against potential attacks and misuse, thereby enhancing its overall security posture. Regular audits and updates should also be part of the development lifecycle to adapt to evolving security threats.

[2024-22-08 11:55:32 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the "Pool" contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `nonReentrant` modifiers in several functions, there are still areas where reentrancy could potentially be exploited, especially in functions that involve external calls to other contracts (e.g., `_withdrawRepayment`, `_deposit`, and `_withdraw`).

2. **Access Control Issues**:
   - The contract relies on certain roles (like borrower and owner) but does not have a robust mechanism to ensure that only authorized users can execute sensitive functions. For example, the `cancelPool` function can be called by anyone if the conditions are met, which could lead to unauthorized cancellations.

3. **Lack of Input Validation**:
   - Some functions do not adequately validate input parameters. For instance, in the `initialize` function, there is no check to ensure that the provided addresses (like `_borrowAsset`, `_collateralAsset`, etc.) are valid contracts.

4. **Potential for Integer Overflow/Underflow**:
   - While the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not handled correctly, especially in calculations involving user balances and shares.

5. **Gas Limit and Loops**:
   - Functions that involve iterating over mappings or arrays (like `_beforeTokenTransfer`) could run into gas limit issues if the number of lenders or transactions grows significantly.

6. **Improper Handling of Ether**:
   - The contract has a `receive()` function to accept Ether, but there is no clear mechanism to handle or withdraw Ether, which could lead to funds being locked in the contract.

7. **Lack of Event Emission**:
   - Some critical state changes do not emit events, which can hinder tracking and debugging. For example, functions that change the loan status or modify balances should emit corresponding events.

8. **Potential for Front-Running Attacks**:
   - The contract does not implement any measures to prevent front-running, which could allow malicious actors to exploit timing differences in transactions.

9. **Inadequate Handling of Failed External Calls**:
   - The contract does not check the return values of external calls, which could lead to unexpected behavior if those calls fail.

### Comprehensive Analysis Report:

The "Pool" contract presents a complex structure with several functionalities related to lending and borrowing. However, it is crucial to address the identified vulnerabilities to ensure the security and reliability of the contract. 

1. **Reentrancy Protection**: While the use of `nonReentrant` modifiers is a good practice, further scrutiny is needed to ensure that all external calls are adequately protected against reentrancy attacks. Consider implementing checks-effects-interactions patterns.

2. **Access Control**: Implement more granular access control mechanisms, such as role-based access control (RBAC), to ensure that only authorized users can perform sensitive actions.

3. **Input Validation**: Enhance input validation to ensure that all parameters are checked for validity before processing. This includes checking for zero addresses and ensuring that amounts are positive.

4. **Gas Optimization**: Review functions for potential gas limit issues, especially those that involve loops or mappings. Consider optimizing these functions or limiting their usage.

5. **Event Emission**: Ensure that all state-changing functions emit appropriate events to facilitate tracking and auditing of contract activities.

6. **Front-Running Mitigation**: Implement measures to mitigate front-running risks, such as using commit-reveal schemes or time-locks for sensitive operations.

7. **Error Handling**: Ensure that all external calls are checked for success and handle failures gracefully to prevent unexpected contract states.

By addressing these vulnerabilities, the contract can be significantly strengthened against potential attacks and misuse, thereby enhancing its overall security posture. Regular audits and updates should also be part of the development lifecycle to adapt to evolving security threats.

[2024-22-08 11:55:32 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-22-08 11:55:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IVerification.sol';\n\n/\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    address poolFactory;\n\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n\n    /\n     * @notice used to keep track of lenders' details\n     /\n    mapping(address =&gt; LendingDetails) public lenders;\n\n    /\n     * @notice object of type PoolConstants\n     /\n    PoolConstants public poolConstants;\n\n    /\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n\n    /\n     * @notice checks if the user is pool's valid borrower\n     * @param _user address of the borrower\n     /\n    modifier onlyBorrower(address user) {\n        require(_user == poolConstants.borrower, 'OB1');\n        ;\n    }\n\n    /\n     * @notice checks if the _lender is pool's valid lender\n     * @param _lender address of the lender\n     /\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, 'IL1');\n        ;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');\n        _;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's latest repayment implementation\n     /\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');\n        _;\n    }\n\n    /\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     /\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init('Pool Tokens', 'PT');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n\n    /\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, 'DC1');\n        require(balanceOf(msg.sender) == 0, 'DC2');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     /\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     /\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n\n    /\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet\n     /\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');\n        require(balanceOf(msg.sender) == 0, 'ACMC2');\n        require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');\n\n        require(_amount != 0, 'ACMC4');\n\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n\n        if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     /\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &amp;&amp;\n                poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;\n                block.timestamp &lt; poolConstants.loanWithdrawalDeadline,\n            'WBA1'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030), 'WBA2');\n\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');\n\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(1030);\n        delete poolConstants.loanWithdrawalDeadline;\n\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n\n    /\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n\n    /\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     /\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n\n    /\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     /\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), 'TT1');\n        }\n        require(_to != poolConstants.borrower, 'TT2');\n\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');\n        }\n        require(getMarginCallEndTime(_from) == 0, 'TT3');\n        require(getMarginCallEndTime(_to) == 0, 'TT4');\n\n        //Withdraw repayments for user\n\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp &gt; _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp &gt; _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n\n    /\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n\n        if (\n            _loanStartTime &lt; block.timestamp &amp;&amp;\n            totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030)\n        ) {\n            return _cancelPool(0);\n        }\n\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n\n        if (_loanWithdrawalDeadline &gt; block.timestamp) {\n            require(msg.sender == poolConstants.borrower, 'CP2');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(1030)\n            .mul(_collateralLiquidityShare)\n            .div(1030)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n\n    /\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n\n    /\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');\n        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n\n    /\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     /\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n\n    /\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');\n\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n\n        emit PoolClosed();\n    }\n\n    /\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     /\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            'WL1'\n        );\n\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n\n    /\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     /\n\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');\n\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n\n        emit MarginCalled(msg.sender);\n    }\n\n    /\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(1030);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(1030));\n        if (_loanDurationTillNow &lt;= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(1060);\n\n        return _interestAccrued;\n    }\n\n    /\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(1030).div(_balance.add(_interest));\n    }\n\n    /\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n\n    /\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     /\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n\n    /\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n\n    /\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     /\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');\n        require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');\n\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');\n        require(balanceOf(_lender) != 0, 'CLBL5');\n    }\n\n    /\n     * @notice used to add extra liquidity shares to lender's share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     /\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n\n    /\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n\n    /\n     * @notice used to liquidate lender and burn lender's shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n\n    /\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     /\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10_decimals).mul(uint256(1030).sub(_fraction)).div(1030);\n    }\n\n    /\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     /\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n\n    /\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     /\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n\n    /\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n\n    /\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     /\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n\n        return _amountWithdrawable;\n    }\n\n    /\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     /\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n\n    /\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     /\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n\n        if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n\n    /\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     /\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n\n    /\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n\n    /\n     * @notice used to receive ethers from savings accounts\n     /\n    receive() external payable {}\n\n    /\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     /\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10_decimals);\n    }\n\n    /\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     /\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n\n    /\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     /\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:55:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:55:32 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 11:55:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:55:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19917
completion_tokens: 1
total_tokens: 19918
cost: $-1.000000


[2024-22-08 11:55:35 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

###

[2024-22-08 11:55:35 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 11:55:35 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-22-08 11:55:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:55:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:55:35 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 11:55:47 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:55:47 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10018
completion_tokens: 726
total_tokens: 10744
cost: $-1.000000


[2024-22-08 11:55:47 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Based on the provided smart contract code and the analysis conducted, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses nonReentrant modifiers, but there are still areas where reentrancy could be exploited, particularly in functions that involve external calls (e.g., `_withdraw`, `_deposit`, and `lend` functions). Careful attention is needed to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The contract has several modifiers (e.g., `onlyOwner`, `onlyBorrower`, `onlyRepaymentImpl`) to restrict access to certain functions. However, there may be scenarios where unauthorized users could potentially call these functions if the access checks are not robustly implemented or if the contract is upgraded without proper checks.

3. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath for arithmetic operations, there are still areas where arithmetic operations could lead to overflow or underflow if not handled properly, especially in complex calculations involving multiple variables.

4. **Improper Error Handling**:
   - The contract uses require statements for error handling, but there are instances where the error messages are not descriptive enough. This could lead to confusion for users trying to understand why a transaction failed.

5. **Gas Limit Issues**:
   - Some functions, especially those that involve loops or complex calculations, may exceed the gas limit when called with large inputs. This could lead to failed transactions and loss of funds.

6. **Lack of Input Validation**:
   - Several functions do not adequately validate inputs, which could lead to unexpected behavior or exploitation. For example, ensuring that amounts are positive and within expected ranges is crucial.

7. **Potential for Front-Running Attacks**:
   - The contract may be susceptible to front-running attacks, especially in functions that involve financial transactions. This could allow malicious actors to exploit the timing of transactions for profit.

8. **Upgradeability Risks**:
   - The contract is designed to be upgradeable, but without proper governance mechanisms in place, it could lead to unauthorized upgrades or changes in contract logic that could compromise security.

### Comprehensive Analysis Report:

The analyzed smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The presence of reentrancy vulnerabilities, access control issues, and improper error handling raises significant concerns regarding the contract's robustness. Additionally, the potential for integer overflow/underflow, gas limit issues, and lack of input validation further complicates the security landscape.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Enhance Reentrancy Protection**: Ensure that all state changes occur before any external calls, and consider using checks-effects-interactions pattern consistently.
- **Strengthen Access Control**: Review and reinforce access control mechanisms to prevent unauthorized access to sensitive functions.
- **Improve Input Validation**: Implement thorough input validation across all functions to ensure that only valid data is processed.
- **Descriptive Error Handling**: Use more descriptive error messages in require statements to aid in debugging and user understanding.
- **Gas Optimization**: Analyze and optimize functions to prevent gas limit issues, especially in loops or complex calculations.
- **Implement Governance Mechanisms**: Establish a robust governance framework for contract upgrades to prevent unauthorized changes.

In conclusion, while the contract has a solid foundation, addressing the identified vulnerabilities is crucial to ensuring its security and reliability in a production environment. Regular audits and updates should be conducted to adapt to evolving security threats in the blockchain ecosystem.

[2024-22-08 11:55:47 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code and the analysis conducted, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses nonReentrant modifiers, but there are still areas where reentrancy could be exploited, particularly in functions that involve external calls (e.g., `_withdraw`, `_deposit`, and `lend` functions). Careful attention is needed to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The contract has several modifiers (e.g., `onlyOwner`, `onlyBorrower`, `onlyRepaymentImpl`) to restrict access to certain functions. However, there may be scenarios where unauthorized users could potentially call these functions if the access checks are not robustly implemented or if the contract is upgraded without proper checks.

3. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath for arithmetic operations, there are still areas where arithmetic operations could lead to overflow or underflow if not handled properly, especially in complex calculations involving multiple variables.

4. **Improper Error Handling**:
   - The contract uses require statements for error handling, but there are instances where the error messages are not descriptive enough. This could lead to confusion for users trying to understand why a transaction failed.

5. **Gas Limit Issues**:
   - Some functions, especially those that involve loops or complex calculations, may exceed the gas limit when called with large inputs. This could lead to failed transactions and loss of funds.

6. **Lack of Input Validation**:
   - Several functions do not adequately validate inputs, which could lead to unexpected behavior or exploitation. For example, ensuring that amounts are positive and within expected ranges is crucial.

7. **Potential for Front-Running Attacks**:
   - The contract may be susceptible to front-running attacks, especially in functions that involve financial transactions. This could allow malicious actors to exploit the timing of transactions for profit.

8. **Upgradeability Risks**:
   - The contract is designed to be upgradeable, but without proper governance mechanisms in place, it could lead to unauthorized upgrades or changes in contract logic that could compromise security.

### Comprehensive Analysis Report:

The analyzed smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The presence of reentrancy vulnerabilities, access control issues, and improper error handling raises significant concerns regarding the contract's robustness. Additionally, the potential for integer overflow/underflow, gas limit issues, and lack of input validation further complicates the security landscape.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Enhance Reentrancy Protection**: Ensure that all state changes occur before any external calls, and consider using checks-effects-interactions pattern consistently.
- **Strengthen Access Control**: Review and reinforce access control mechanisms to prevent unauthorized access to sensitive functions.
- **Improve Input Validation**: Implement thorough input validation across all functions to ensure that only valid data is processed.
- **Descriptive Error Handling**: Use more descriptive error messages in require statements to aid in debugging and user understanding.
- **Gas Optimization**: Analyze and optimize functions to prevent gas limit issues, especially in loops or complex calculations.
- **Implement Governance Mechanisms**: Establish a robust governance framework for contract upgrades to prevent unauthorized changes.

In conclusion, while the contract has a solid foundation, addressing the identified vulnerabilities is crucial to ensuring its security and reliability in a production environment. Regular audits and updates should be conducted to adapt to evolving security threats in the blockchain ecosystem.

[2024-22-08 11:55:50 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '../interfaces/IYield.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/ISavingsAccount.sol';\nimport '../SavingsAccount/SavingsAccountUtil.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IExtension.sol';\nimport '../interfaces/IVerification.sol';\n\n/\n * @title Pool contract with Methods related to Pool\n * @notice Implements the functions related to Pool\n * @author Sublime\n */\ncontract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum LoanStatus {\n        COLLECTION, //denotes collection period\n        ACTIVE, // denotes the active loan\n        CLOSED, // Loan is repaid and closed\n        CANCELLED, // Cancelled by borrower\n        DEFAULTED, // Repayment defaulted by  borrower\n        TERMINATED // Pool terminated by admin\n    }\n\n    address poolFactory;\n\n    struct LendingDetails {\n        uint256 effectiveInterestWithdrawn;\n        uint256 marginCallEndTime;\n        uint256 extraLiquidityShares;\n    }\n\n    // Pool constants\n    struct PoolConstants {\n        address borrower;\n        uint256 borrowAmountRequested;\n        uint256 loanStartTime;\n        uint256 loanWithdrawalDeadline;\n        address borrowAsset;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        uint256 noOfRepaymentIntervals;\n        uint256 repaymentInterval;\n        address collateralAsset;\n        address poolSavingsStrategy; // invest contract\n        address lenderVerifier;\n    }\n\n    struct PoolVariables {\n        uint256 baseLiquidityShares;\n        uint256 extraLiquidityShares;\n        LoanStatus loanStatus;\n        uint256 penaltyLiquidityAmount;\n    }\n\n    /\n     * @notice used to keep track of lenders' details\n     /\n    mapping(address =&gt; LendingDetails) public lenders;\n\n    /\n     * @notice object of type PoolConstants\n     /\n    PoolConstants public poolConstants;\n\n    /\n     * @notice object of type PoolVariables\n     */\n    PoolVariables public poolVariables;\n\n    /\n     * @notice checks if the user is pool's valid borrower\n     * @param _user address of the borrower\n     /\n    modifier onlyBorrower(address user) {\n        require(_user == poolConstants.borrower, 'OB1');\n        ;\n    }\n\n    /\n     * @notice checks if the _lender is pool's valid lender\n     * @param _lender address of the lender\n     /\n    modifier isLender(address _lender) {\n        require(balanceOf(_lender) != 0, 'IL1');\n        ;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's valid owner\n     */\n    modifier onlyOwner() {\n        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');\n        _;\n    }\n\n    /\n     * @notice checks if the msg.sender is pool's latest repayment implementation\n     /\n    modifier onlyRepaymentImpl() {\n        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');\n        _;\n    }\n\n    /\n     * @notice initializing the pool and adding initial collateral\n     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower\n     * @param _borrower address of the borrower\n     * @param _borrowAsset address of the borrow asset\n     * @param _collateralAsset address of the collateral asset\n     * @param _idealCollateralRatio the ideal collateral ratio of the pool\n     * @param _borrowRate the borrow rate as specified by borrower\n     * @param _repaymentInterval the interval between to repayments\n     * @param _noOfRepaymentIntervals number of repayments to be done by borrower\n     * @param _poolSavingsStrategy address of the savings strategy preferred\n     * @param _collateralAmount amount of collateral to be deposited by the borrower\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset\n     * @param _collectionPeriod time interval where lender lend into the borrow pool\n     /\n    function initialize(\n        uint256 _borrowAmountRequested,\n        uint256 _borrowRate,\n        address _borrower,\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier,\n        uint256 _loanWithdrawalDuration,\n        uint256 _collectionPeriod\n    ) external payable initializer {\n        poolFactory = msg.sender;\n        poolConstants.borrowAsset = _borrowAsset;\n        poolConstants.idealCollateralRatio = _idealCollateralRatio;\n        poolConstants.collateralAsset = _collateralAsset;\n        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;\n        poolConstants.borrowAmountRequested = _borrowAmountRequested;\n        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);\n        poolConstants.borrower = _borrower;\n        poolConstants.borrowRate = _borrowRate;\n        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;\n        poolConstants.repaymentInterval = _repaymentInterval;\n        poolConstants.lenderVerifier = _lenderVerifier;\n\n        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);\n        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);\n        __ERC20_init('Pool Tokens', 'PT');\n        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {\n            _setupDecimals(_decimals);\n        } catch(bytes memory) {}\n    }\n\n    /\n     * @notice add collateral to a pool\n     * @param _amount amount of collateral to be deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     */\n    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {\n        require(_amount != 0, 'DC1');\n        require(balanceOf(msg.sender) == 0, 'DC2');\n        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice called when borrow pool is initialized to make initial collateral deposit\n     * @param _borrower address of the borrower\n     * @param _amount amount of collateral getting deposited denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet\n     /\n    function _initialDeposit(\n        address _borrower,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal {\n        uint256 _equivalentCollateral = getEquivalentTokens(\n            poolConstants.borrowAsset,\n            poolConstants.collateralAsset,\n            poolConstants.borrowAmountRequested\n        );\n        require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');\n        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);\n    }\n\n    /\n     * @notice internal function used to deposit collateral from _borrower to pool\n     * @param _depositor address transferring the collateral\n     * @param _amount amount of collateral to be transferred denominated in collateral asset\n     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     /\n    function _depositCollateral(\n        address _depositor,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) internal nonReentrant {\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            _depositor,\n            address(this)\n        );\n        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);\n        emit CollateralAdded(_depositor, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice internal function used to get amount of collateral deposited to the pool\n     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet\n     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account\n     * @param _asset address of the asset to be deposited\n     * @param _amount amount of tokens to be deposited in the pool\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _depositFrom address which makes the deposit\n     * @param _depositTo address to which the tokens are deposited\n     * @return _sharesReceived number of equivalent shares for given _asset\n     */\n    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }\n\n    /\n     * @notice used to add extra collateral deposit during margin calls\n     * @param _lender the address of the _lender who has requested for margin call\n     * @param _amount amount of tokens requested for the margin call\n     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet\n     /\n    function addCollateralInMarginCall(\n        address _lender,\n        uint256 _amount,\n        bool _transferFromSavingsAccount\n    ) external payable override nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');\n        require(balanceOf(msg.sender) == 0, 'ACMC2');\n        require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');\n\n        require(_amount != 0, 'ACMC4');\n\n        uint256 _sharesReceived = _deposit(\n            _transferFromSavingsAccount,\n            true,\n            poolConstants.collateralAsset,\n            _amount,\n            poolConstants.poolSavingsStrategy,\n            msg.sender,\n            address(this)\n        );\n\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);\n\n        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);\n\n        if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {\n            delete lenders[_lender].marginCallEndTime;\n        }\n\n        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);\n    }\n\n    /\n     * @notice used by the borrower to withdraw tokens from the pool when loan is active\n     /\n    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        uint256 _tokensLent = totalSupply();\n        require(\n            _poolStatus == LoanStatus.COLLECTION &amp;&amp;\n                poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;\n                block.timestamp &lt; poolConstants.loanWithdrawalDeadline,\n            'WBA1'\n        );\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030), 'WBA2');\n\n        poolVariables.loanStatus = LoanStatus.ACTIVE;\n        uint256 _currentCollateralRatio = getCurrentCollateralRatio();\n        require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');\n\n        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;\n        uint256 _repaymentInterval = poolConstants.repaymentInterval;\n        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(\n            _noOfRepaymentIntervals,\n            _repaymentInterval,\n            poolConstants.borrowRate,\n            poolConstants.loanStartTime,\n            poolConstants.borrowAsset\n        );\n        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();\n        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(1030);\n        delete poolConstants.loanWithdrawalDeadline;\n\n        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);\n\n        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);\n        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);\n\n        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);\n    }\n\n    /\n     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)\n     * @param _receiver address which receives all the collateral tokens\n     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled\n     */\n    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        uint256 _collateralShares = 0;\n        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {\n            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);\n        }\n        // uint256 _collateralTokens = _collateralShares;\n        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);\n\n        poolVariables.baseLiquidityShares = _penalty;\n        delete poolVariables.extraLiquidityShares;\n\n        uint256 _sharesReceived;\n        if (_collateralShares != 0) {\n            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(\n                _savingsAccount,\n                address(this),\n                _receiver,\n                _collateralTokens,\n                _collateralAsset,\n                _poolSavingsStrategy\n            );\n        }\n        emit CollateralWithdrawn(_receiver, _sharesReceived);\n    }\n\n    /\n     * @notice used by lender to supply liquidity to a borrow pool\n     * @param _lender address of the lender\n     * @param _amount amount of liquidity supplied by the _lender\n     * @param _strategy address of strategy from which tokens are lent if done from savings account, \n     *                  in case of direct deposits, zeroAddress should be used\n     /\n    function lend(\n        address _lender,\n        uint256 _amount,\n        address _strategy\n    ) external payable nonReentrant {\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        address _borrower = poolConstants.borrower;\n        require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');\n        }\n        require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');\n        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;\n        uint256 _lentAmount = totalSupply();\n        if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {\n            _amount = _borrowAmountNeeded.sub(_lentAmount);\n        }\n\n        address _borrowToken = poolConstants.borrowAsset;\n        bool _fromSavingsAccount;\n        if(_strategy != address(0)) {\n            _fromSavingsAccount = true;\n        }\n        _deposit(\n            _fromSavingsAccount,\n            false,\n            _borrowToken,\n            _amount,\n            _strategy,\n            msg.sender,\n            address(this)\n        );\n        _mint(_lender, _amount);\n        emit LiquiditySupplied(_amount, _lender);\n    }\n\n    /\n     * @notice used to transfer borrow pool tokens among lenders\n     * @param _from address of the lender who sends the borrow pool tokens\n     * @param _to addres of the lender who receives the borrow pool tokens\n     * @param _amount amount of borrow pool tokens transfered\n     /\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (_to != address(0)) {\n            require(!paused(), 'TT1');\n        }\n        require(_to != poolConstants.borrower, 'TT2');\n\n        if (_from == address(0) || _to == address(0)) {\n            return;\n        }\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _lenderVerifier = poolConstants.lenderVerifier;\n        if (_lenderVerifier != address(0)) {\n            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');\n        }\n        require(getMarginCallEndTime(_from) == 0, 'TT3');\n        require(getMarginCallEndTime(_to) == 0, 'TT4');\n\n        //Withdraw repayments for user\n\n        //We enforce pending interest withdrawals before the transfers\n        \n        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.\n        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for \n        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from\n        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated\n        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()\n        _withdrawRepayment(_from);\n        _withdrawRepayment(_to);\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n        uint256 _totalSupply = totalSupply();\n        uint256 _fromBalance = balanceOf(_from);\n        uint256 _toBalance = balanceOf(_to);\n        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);\n\n        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);\n\n        //transfer extra liquidity shares\n        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;\n        if (_liquidityShare == 0) return;\n\n        uint256 toTransfer = _liquidityShare;\n        if (_amount != _fromBalance) {\n            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);\n        }\n\n        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);\n        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);\n    }\n\n    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {\n        uint256 _penaltyTime = poolConstants.repaymentInterval;\n        if (block.timestamp &gt; _loanStartTime) {\n            uint256 _penaltyEndTime = block.timestamp;\n            if (block.timestamp &gt; _loanWithdrawalDeadline) {\n                _penaltyEndTime = _loanWithdrawalDeadline;\n            }\n            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));\n        }\n        return _penaltyTime;\n    }\n\n    /\n     * @notice used to cancel pool when the minimum borrow amount is not met\n     */\n    function cancelPool() external {\n        LoanStatus _poolStatus = poolVariables.loanStatus;\n        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');\n        uint256 _loanStartTime = poolConstants.loanStartTime;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n\n        if (\n            _loanStartTime &lt; block.timestamp &amp;&amp;\n            totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(1030)\n        ) {\n            return _cancelPool(0);\n        }\n\n        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;\n\n        if (_loanWithdrawalDeadline &gt; block.timestamp) {\n            require(msg.sender == poolConstants.borrower, 'CP2');\n        }\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;\n        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);\n        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();\n        uint256 penalty = _cancelPenaltyMultiple\n            .mul(poolConstants.borrowRate)\n            .div(1030)\n            .mul(_collateralLiquidityShare)\n            .div(1030)\n            .mul(_penaltyTime)\n            .div(365 days);\n        _cancelPool(penalty);\n    }\n\n    /\n     * @notice internal function to cancel borrow pool\n     * @param _penalty amount to be paid as penalty to cancel pool\n     */\n    function _cancelPool(uint256 _penalty) internal {\n        poolVariables.loanStatus = LoanStatus.CANCELLED;\n        _withdrawAllCollateral(poolConstants.borrower, _penalty);\n        _pause();\n        emit PoolCancelled();\n    }\n\n    /\n     * @notice used to liquidate the penalty amount when pool is calcelled\n     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true\n     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet\n     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {\n        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');\n        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        address _collateralAsset = poolConstants.collateralAsset;\n        // note: extra liquidity shares are not applicable as the loan never reaches active state\n        uint256 _collateralTokens = poolVariables.baseLiquidityShares;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);\n\n        uint256 _liquidationTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        poolVariables.penaltyLiquidityAmount = _liquidationTokens;\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));\n        _withdraw(\n            _toSavingsAccount,\n            _receiveLiquidityShare,\n            poolConstants.collateralAsset,\n            poolConstants.poolSavingsStrategy,\n            _collateralTokens\n        );\n    }\n\n    /\n     * @notice used to terminate the pool\n     * @dev kill switch for owner to terminate the pool\n     /\n    function terminatePool() external onlyOwner {\n        _withdrawAllCollateral(msg.sender, 0);\n        _pause();\n        poolVariables.loanStatus = LoanStatus.TERMINATED;\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        emit PoolTerminated();\n    }\n\n    /\n     * @notice called to close the loan after repayment of principal\n     */\n    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');\n\n        poolVariables.loanStatus = LoanStatus.CLOSED;\n\n        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();\n        _withdrawAllCollateral(poolConstants.borrower, 0);\n        _pause();\n\n        emit PoolClosed();\n    }\n\n    /\n     * @notice used to return total remaining repayments along with provided liquidity to the lender\n     * @dev burns all shares and returns total remaining repayments along with provided liquidity\n     /\n    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {\n        LoanStatus _loanStatus = poolVariables.loanStatus;\n\n        require(\n            _loanStatus == LoanStatus.CLOSED ||\n                _loanStatus == LoanStatus.CANCELLED ||\n                _loanStatus == LoanStatus.DEFAULTED ||\n                _loanStatus == LoanStatus.TERMINATED,\n            'WL1'\n        );\n\n        //gets amount through liquidity shares\n        uint256 _actualBalance = balanceOf(msg.sender);\n        uint256 _toTransfer = _actualBalance;\n\n        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {\n            uint256 _totalAsset;\n            if (poolConstants.borrowAsset != address(0)) {\n                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));\n            } else {\n                _totalAsset = address(this).balance;\n            }\n            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()\n            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());\n        }\n\n        if (_loanStatus == LoanStatus.CANCELLED) {\n            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));\n        }\n\n        if (_loanStatus == LoanStatus.CLOSED) {\n            //transfer repayment\n            _withdrawRepayment(msg.sender);\n        }\n        //to add transfer if not included in above (can be transferred with liquidity)\n        _burn(msg.sender, _actualBalance);\n\n        //transfer liquidity provided\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);\n\n        emit LiquidityWithdrawn(_toTransfer, msg.sender);\n    }\n\n    /\n     * @notice function is executed by lender to exercise margin call\n     * @dev It will revert in case collateral ratio is not below expected value\n     * or the lender has already called it.\n     /\n\n    function requestMarginCall() external isLender(msg.sender) {\n        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');\n\n        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());\n\n        emit MarginCalled(msg.sender);\n    }\n\n    /\n     * @notice used to get the interest accrued till current time in the current loan duration\n     * @return ineterest accrued till current time\n     */\n    function interestToPay() public view returns (uint256) {\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(\n            address(this)\n        );\n        uint256 _currentBlockTime = block.timestamp.mul(1030);\n        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(1030));\n        if (_loanDurationTillNow &lt;= _loanDurationCovered) {\n            return 0;\n        }\n        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(1060);\n\n        return _interestAccrued;\n    }\n\n    /\n     * @notice used to calculate the collateral ratio\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @param _balance the principal amount lent\n     * @param _liquidityShares amount of collateral tokens available\n     * @return _ratio the collateral ratio\n     */\n    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {\n        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _strategy = poolConstants.poolSavingsStrategy;\n        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);\n        _ratio = _equivalentCollateral.mul(1030).div(_balance.add(_interest));\n    }\n\n    /\n     * @notice used to get the current collateral ratio of the borrow pool\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the borrow pool\n     */\n    function getCurrentCollateralRatio() public returns (uint256 _ratio) {\n        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n\n        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);\n    }\n\n    /\n     * @notice used to get the current collateral ratio of a lender\n     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view\n     * @return _ratio the current collateral ratio of the lender\n     /\n    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {\n        uint256 _balanceOfLender = balanceOf(_lender);\n        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(\n            lenders[_lender].extraLiquidityShares\n        );\n\n        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));\n    }\n\n    /\n     * @notice used to liquidate the pool if the borrower has defaulted\n     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidatePool(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        LoanStatus _currentPoolStatus = poolVariables.loanStatus;\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');\n        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');\n        poolVariables.loanStatus = LoanStatus.DEFAULTED;\n\n        address _collateralAsset = poolConstants.collateralAsset;\n        address _borrowAsset = poolConstants.borrowAsset;\n        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        uint256 _collateralTokens = _collateralLiquidityShare;\n        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);\n\n        uint256 _poolBorrowTokens = correspondingBorrowTokens(\n            _collateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n        delete poolVariables.extraLiquidityShares;\n        delete poolVariables.baseLiquidityShares;\n\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));\n        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);\n        emit PoolLiquidated(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw tokens\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     * @param _asset address of the asset to be withdrawn\n     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit\n     * @param _amountInTokens amount of tokens to be withdrawn from the pool\n     * @return amount of equivalent shares from given asset\n     */\n    function _withdraw(\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare,\n        address _asset,\n        address _poolSavingsStrategy,\n        uint256 _amountInTokens\n    ) internal returns (uint256) {\n        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());\n        return\n            SavingsAccountUtil.depositFromSavingsAccount(\n                _savingsAccount,\n                address(this),\n                msg.sender,\n                _amountInTokens,\n                _asset,\n                _poolSavingsStrategy,\n                _recieveLiquidityShare,\n                _toSavingsAccount\n            );\n    }\n\n    /\n     * @notice used to ensure if a lender can be liquidated\n     * @param _lender address of the lender to be liquidated\n     /\n    function _canLenderBeLiquidated(address _lender) internal {\n        require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');\n        require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');\n\n        require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');\n        require(balanceOf(_lender) != 0, 'CLBL5');\n    }\n\n    /\n     * @notice used to add extra liquidity shares to lender's share\n     * @param _lender address of the lender to be liquidated\n     * @return _lenderCollateralLPShare share of the lender in collateral tokens\n     * @return _lenderBalance balance of lender in pool tokens\n     /\n    function _updateLenderSharesDuringLiquidation(address _lender)\n        internal\n        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)\n    {\n        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;\n        _lenderBalance = balanceOf(_lender);\n\n        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());\n        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;\n        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);\n        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);\n\n        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);\n    }\n\n    /\n     * @notice internal function to liquidate lender of the borrow pool\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _lender address of the lender to be liquidated\n     * @param _lenderCollateralTokens share of the lender in collateral tokens\n     */\n    function _liquidateForLender(\n        bool _fromSavingsAccount,\n        address _lender,\n        uint256 _lenderCollateralTokens\n    ) internal {\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n\n        IPoolFactory _poolFactory = IPoolFactory(poolFactory);\n        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(\n            _lenderCollateralTokens,\n            _poolFactory.priceOracle(),\n            _poolFactory.liquidatorRewardFraction()\n        );\n\n        address _borrowAsset = poolConstants.borrowAsset;\n        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);\n        _withdrawRepayment(_lender);\n    }\n\n    /\n     * @notice used to liquidate lender and burn lender's shares\n     * @param _lender address of the lender to be liquidated\n     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet\n     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet\n     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn\n     /\n    function liquidateForLender(\n        address _lender,\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        bool _recieveLiquidityShare\n    ) external payable nonReentrant {\n        _canLenderBeLiquidated(_lender);\n\n        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;\n        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);\n\n        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;\n        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);\n\n        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);\n\n        uint256 _amountReceived = _withdraw(\n            _toSavingsAccount,\n            _recieveLiquidityShare,\n            poolConstants.collateralAsset,\n            _poolSavingsStrategy,\n            _lenderCollateralTokens\n        );\n        _burn(_lender, _lenderBalance);\n        delete lenders[_lender];\n        emit LenderLiquidated(msg.sender, _lender, _amountReceived);\n    }\n\n    /\n     * @notice used to get corresponding borrow tokens for given collateral tokens\n     * @param _totalCollateralTokens amount of collateral tokens\n     * @param _priceOracle address of the pool\n     * @param _fraction Incentivizing fraction for the liquidator\n     * @return corresponding borrow tokens for collateral tokens\n     /\n    function correspondingBorrowTokens(\n        uint256 _totalCollateralTokens,\n        address _priceOracle,\n        uint256 _fraction\n    ) public view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(\n            poolConstants.collateralAsset,\n            poolConstants.borrowAsset\n        );\n        return _totalCollateralTokens.mul(_ratioOfPrices).div(10_decimals).mul(uint256(1030).sub(_fraction)).div(1030);\n    }\n\n    /\n     * @notice used to get the interest per second on the principal amount\n     * @param _principal amount of principal lent\n     * @return interest accrued on the principal in a second\n     /\n    function interestPerSecond(uint256 _principal) public view returns (uint256) {\n        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);\n        return _interest;\n    }\n\n    /\n     * @notice used to get the interest per period on the principal amount\n     * @param _balance amount of principal lent\n     * @return interest accrued on the principal in a period\n     /\n    function interestPerPeriod(uint256 _balance) external view returns (uint256) {\n        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));\n    }\n\n    /\n     * @notice used to get the current repayment period for the borrow pool\n     * @return current repayment period\n     */\n    function calculateCurrentPeriod() external view returns (uint256) {\n        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);\n        return _currentPeriod;\n    }\n\n    /\n     * @notice internal function used to get the withdrawable amount for a _lender\n     * @param _lender address of the _lender\n     * @return amount of withdrawable token from the borrow pool\n     /\n    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {\n        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));\n\n        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(\n            lenders[_lender].effectiveInterestWithdrawn\n        );\n\n        return _amountWithdrawable;\n    }\n\n    /\n     * @notice used to get the withdrawable amount of borrow token for a lender\n     /\n    function withdrawRepayment() external isLender(msg.sender) nonReentrant {\n        _withdrawRepayment(msg.sender);\n    }\n\n    /\n     * @notice internal function used to withdraw borrow asset from the pool by _lender\n     * @param _lender address of the _lender\n     */\n    function _withdrawRepayment(address _lender) internal {\n        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);\n\n        if (_amountToWithdraw == 0) {\n            return;\n        }\n        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);\n\n        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);\n    }\n\n    /\n     * @notice used to get the end time for a margin call\n     * @param _lender address of the lender who has requested a margin call\n     * @return the time at which the margin call ends\n     /\n    function getMarginCallEndTime(address _lender) public view override returns (uint256) {\n        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();\n        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;\n\n        if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {\n            _marginCallEndTime = 0;\n        }\n        return _marginCallEndTime;\n    }\n\n    /\n     * @notice used to get the balance details of a _lender\n     * @param _lender address of the _lender\n     * @return amount of pool tokens available with the _lender\n     * @return amount of pool tokens available in the pool\n     /\n    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {\n        return (balanceOf(_lender), totalSupply());\n    }\n\n    /\n     * @notice used to get the loan status of the borrow pool\n     * @return integer respresenting loan status\n     */\n    function getLoanStatus() external view override returns (uint256) {\n        return uint256(poolVariables.loanStatus);\n    }\n\n    /\n     * @notice used to receive ethers from savings accounts\n     /\n    receive() external payable {}\n\n    /\n     * @notice used to get the equivalent amount of tokens from source to target tokens\n     * @param _source address of the tokens to be converted\n     * @param _target address of target conversion token\n     * @param _amount amount of tokens to be converted\n     * @return the equivalent amount of target tokens for given source tokens\n     /\n    function getEquivalentTokens(\n        address _source,\n        address _target,\n        uint256 _amount\n    ) public view returns (uint256) {\n        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);\n        return _amount.mul(_price).div(10_decimals);\n    }\n\n    /\n     * @notice used to get the address of the borrower of the pool\n     * @return address of the borrower\n     /\n    function borrower() external view override returns (address) {\n        return poolConstants.borrower;\n    }\n\n    /\n     * @notice used to total supply of pool tokens for the pool\n     * @return total supply of pool tokens\n     /\n    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {\n        return ERC20Upgradeable.totalSupply();\n    }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-22-08 11:55:50 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; import '../interfaces/IPoolFactory.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/IRepayment.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IPool.sol'; import '../interfaces/IExtension.sol'; import '../interfaces/IVerification.sol'; /*  * @title Pool contract with Methods related to Pool  * @notice Implements the functions related to Pool  * @author Sublime  / contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum LoanStatus {     COLLECTION, //denotes collection period     ACTIVE, // denotes the active loan     CLOSED, // Loan is repaid and closed     CANCELLED, // Cancelled by borrower     DEFAULTED, // Repayment defaulted by  borrower     TERMINATED // Pool terminated by admin }  address poolFactory;  struct LendingDetails {     uint256 effectiveInterestWithdrawn;     uint256 marginCallEndTime;     uint256 extraLiquidityShares; }  // Pool constants struct PoolConstants {     address borrower;     uint256 borrowAmountRequested;     uint256 loanStartTime;     uint256 loanWithdrawalDeadline;     address borrowAsset;     uint256 idealCollateralRatio;     uint256 borrowRate;     uint256 noOfRepaymentIntervals;     uint256 repaymentInterval;     address collateralAsset;     address poolSavingsStrategy; // invest contract     address lenderVerifier; }  struct PoolVariables {     uint256 baseLiquidityShares;     uint256 extraLiquidityShares;     LoanStatus loanStatus;     uint256 penaltyLiquidityAmount; }  /**  * @notice used to keep track of lenders' details  */ mapping(address =&gt; LendingDetails) public lenders;  /**  * @notice object of type PoolConstants  */ PoolConstants public poolConstants;  /**  * @notice object of type PoolVariables  */ PoolVariables public poolVariables;  /**  * @notice checks if the _user is pool's valid borrower  * @param _user address of the borrower  */ modifier onlyBorrower(address _user) {     require(_user == poolConstants.borrower, 'OB1');     _; }  /**  * @notice checks if the _lender is pool's valid lender  * @param _lender address of the lender  */ modifier isLender(address _lender) {     require(balanceOf(_lender) != 0, 'IL1');     _; }  /**  * @notice checks if the msg.sender is pool's valid owner  */ modifier onlyOwner() {     require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');     _; }  /**  * @notice checks if the msg.sender is pool's latest repayment implementation  */ modifier onlyRepaymentImpl() {     require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');     _; }  /**  * @notice initializing the pool and adding initial collateral  * @param _borrowAmountRequested the amount of borrow asset requested by the borrower  * @param _borrower address of the borrower  * @param _borrowAsset address of the borrow asset  * @param _collateralAsset address of the collateral asset  * @param _idealCollateralRatio the ideal collateral ratio of the pool  * @param _borrowRate the borrow rate as specified by borrower  * @param _repaymentInterval the interval between to repayments  * @param _noOfRepaymentIntervals number of repayments to be done by borrower  * @param _poolSavingsStrategy address of the savings strategy preferred  * @param _collateralAmount amount of collateral to be deposited by the borrower  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset  * @param _collectionPeriod time interval where lender lend into the borrow pool  */ function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} }  /**  * @notice add collateral to a pool  * @param _amount amount of collateral to be deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {     require(_amount != 0, 'DC1');     require(balanceOf(msg.sender) == 0, 'DC2');     _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount); }  /**  * @notice called when borrow pool is initialized to make initial collateral deposit  * @param _borrower address of the borrower  * @param _amount amount of collateral getting deposited denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet  */ function _initialDeposit(     address _borrower,     uint256 _amount,     bool _transferFromSavingsAccount ) internal {     uint256 _equivalentCollateral = getEquivalentTokens(         poolConstants.borrowAsset,         poolConstants.collateralAsset,         poolConstants.borrowAmountRequested     );     require(_amount &gt;= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');     _depositCollateral(_borrower, _amount, _transferFromSavingsAccount); }  /**  * @notice internal function used to deposit collateral from _borrower to pool  * @param _depositor address transferring the collateral  * @param _amount amount of collateral to be transferred denominated in collateral asset  * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  */ function _depositCollateral(     address _depositor,     uint256 _amount,     bool _transferFromSavingsAccount ) internal nonReentrant {     uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         _depositor,         address(this)     );     poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);     emit CollateralAdded(_depositor, _amount, _sharesReceived); }  /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } }  /**  * @notice used to add extra collateral deposit during margin calls  * @param _lender the address of the _lender who has requested for margin call  * @param _amount amount of tokens requested for the margin call  * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet  */ function addCollateralInMarginCall(     address _lender,     uint256 _amount,     bool _transferFromSavingsAccount ) external payable override nonReentrant {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');     require(balanceOf(msg.sender) == 0, 'ACMC2');     require(getMarginCallEndTime(_lender) &gt;= block.timestamp, 'ACMC3');      require(_amount != 0, 'ACMC4');      uint256 _sharesReceived = _deposit(         _transferFromSavingsAccount,         true,         poolConstants.collateralAsset,         _amount,         poolConstants.poolSavingsStrategy,         msg.sender,         address(this)     );      poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);      lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);      if (getCurrentCollateralRatio(_lender) &gt;= poolConstants.idealCollateralRatio) {         delete lenders[_lender].marginCallEndTime;     }      emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived); }  /**  * @notice used by the borrower to withdraw tokens from the pool when loan is active  */ function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {     LoanStatus _poolStatus = poolVariables.loanStatus;     uint256 _tokensLent = totalSupply();     require(         _poolStatus == LoanStatus.COLLECTION &amp;&amp;             poolConstants.loanStartTime &lt; block.timestamp &amp;&amp;             block.timestamp &lt; poolConstants.loanWithdrawalDeadline,         'WBA1'     );     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_tokensLent &gt;= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');      poolVariables.loanStatus = LoanStatus.ACTIVE;     uint256 _currentCollateralRatio = getCurrentCollateralRatio();     require(_currentCollateralRatio &gt;= poolConstants.idealCollateralRatio, 'WBA3');      uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;     uint256 _repaymentInterval = poolConstants.repaymentInterval;     IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(         _noOfRepaymentIntervals,         _repaymentInterval,         poolConstants.borrowRate,         poolConstants.loanStartTime,         poolConstants.borrowAsset     );     IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);      address _borrowAsset = poolConstants.borrowAsset;     (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();     uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);     delete poolConstants.loanWithdrawalDeadline;      uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);      SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);     SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);      emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee); }  /**  * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)  * @param _receiver address which receives all the collateral tokens  * @param _penalty amount of penalty incurred by the borrower when pool is cancelled  */ function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     uint256 _collateralShares = 0;     if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) &gt; _penalty) {         _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);     }     // uint256 _collateralTokens = _collateralShares;     uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);      poolVariables.baseLiquidityShares = _penalty;     delete poolVariables.extraLiquidityShares;      uint256 _sharesReceived;     if (_collateralShares != 0) {         ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());         _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(             _savingsAccount,             address(this),             _receiver,             _collateralTokens,             _collateralAsset,             _poolSavingsStrategy         );     }     emit CollateralWithdrawn(_receiver, _sharesReceived); }  /**  * @notice used by lender to supply liquidity to a borrow pool  * @param _lender address of the lender  * @param _amount amount of liquidity supplied by the _lender  * @param _strategy address of strategy from which tokens are lent if done from savings account,   *                  in case of direct deposits, zeroAddress should be used  */ function lend(     address _lender,     uint256 _amount,     address _strategy ) external payable nonReentrant {     address _lenderVerifier = poolConstants.lenderVerifier;     address _borrower = poolConstants.borrower;     require(_lender != _borrower &amp;&amp; _borrower != msg.sender, 'L1');     if (_lenderVerifier != address(0)) {         require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');     }     require(poolVariables.loanStatus == LoanStatus.COLLECTION &amp;&amp; block.timestamp &lt; poolConstants.loanStartTime, 'L3');     uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;     uint256 _lentAmount = totalSupply();     if (_amount.add(_lentAmount) &gt; _borrowAmountNeeded) {         _amount = _borrowAmountNeeded.sub(_lentAmount);     }      address _borrowToken = poolConstants.borrowAsset;     bool _fromSavingsAccount;     if(_strategy != address(0)) {         _fromSavingsAccount = true;     }     _deposit(         _fromSavingsAccount,         false,         _borrowToken,         _amount,         _strategy,         msg.sender,         address(this)     );     _mint(_lender, _amount);     emit LiquiditySupplied(_amount, _lender); }  /**  * @notice used to transfer borrow pool tokens among lenders  * @param _from address of the lender who sends the borrow pool tokens  * @param _to addres of the lender who receives the borrow pool tokens  * @param _amount amount of borrow pool tokens transfered  */ function _beforeTokenTransfer(     address _from,     address _to,     uint256 _amount ) internal override {     if (_to != address(0)) {         require(!paused(), 'TT1');     }     require(_to != poolConstants.borrower, 'TT2');      if (_from == address(0) || _to == address(0)) {         return;     }     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _lenderVerifier = poolConstants.lenderVerifier;     if (_lenderVerifier != address(0)) {         require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');     }     require(getMarginCallEndTime(_from) == 0, 'TT3');     require(getMarginCallEndTime(_to) == 0, 'TT4');      //Withdraw repayments for user      //We enforce pending interest withdrawals before the transfers      //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.     // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for      // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from     // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated     // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()     _withdrawRepayment(_from);     _withdrawRepayment(_to);     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));     uint256 _totalSupply = totalSupply();     uint256 _fromBalance = balanceOf(_from);     uint256 _toBalance = balanceOf(_to);     lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);     lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);      IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);      //transfer extra liquidity shares     uint256 _liquidityShare = lenders[_from].extraLiquidityShares;     if (_liquidityShare == 0) return;      uint256 toTransfer = _liquidityShare;     if (_amount != _fromBalance) {         toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);     }      lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);     lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer); }  function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {     uint256 _penaltyTime = poolConstants.repaymentInterval;     if (block.timestamp &gt; _loanStartTime) {         uint256 _penaltyEndTime = block.timestamp;         if (block.timestamp &gt; _loanWithdrawalDeadline) {             _penaltyEndTime = _loanWithdrawalDeadline;         }         _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));     }     return _penaltyTime; }  /**  * @notice used to cancel pool when the minimum borrow amount is not met  */ function cancelPool() external {     LoanStatus _poolStatus = poolVariables.loanStatus;     require(_poolStatus == LoanStatus.COLLECTION, 'CP1');     uint256 _loanStartTime = poolConstants.loanStartTime;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);      if (         _loanStartTime &lt; block.timestamp &amp;&amp;         totalSupply() &lt; _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)     ) {         return _cancelPool(0);     }      uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;      if (_loanWithdrawalDeadline &gt; block.timestamp) {         require(msg.sender == poolConstants.borrower, 'CP2');     }     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;     uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);     uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();     uint256 penalty = _cancelPenaltyMultiple         .mul(poolConstants.borrowRate)         .div(10**30)         .mul(_collateralLiquidityShare)         .div(10**30)         .mul(_penaltyTime)         .div(365 days);     _cancelPool(penalty); }  /**  * @notice internal function to cancel borrow pool  * @param _penalty amount to be paid as penalty to cancel pool  */ function _cancelPool(uint256 _penalty) internal {     poolVariables.loanStatus = LoanStatus.CANCELLED;     _withdrawAllCollateral(poolConstants.borrower, _penalty);     _pause();     emit PoolCancelled(); }  /**  * @notice used to liquidate the penalty amount when pool is calcelled  * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true  * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet  * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {     require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');     require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     address _collateralAsset = poolConstants.collateralAsset;     // note: extra liquidity shares are not applicable as the loan never reaches active state     uint256 _collateralTokens = poolVariables.baseLiquidityShares;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);      uint256 _liquidationTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     poolVariables.penaltyLiquidityAmount = _liquidationTokens;     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));     _withdraw(         _toSavingsAccount,         _receiveLiquidityShare,         poolConstants.collateralAsset,         poolConstants.poolSavingsStrategy,         _collateralTokens     ); }  /**  * @notice used to terminate the pool  * @dev kill switch for owner to terminate the pool  */ function terminatePool() external onlyOwner {     _withdrawAllCollateral(msg.sender, 0);     _pause();     poolVariables.loanStatus = LoanStatus.TERMINATED;     IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     emit PoolTerminated(); }  /**  * @notice called to close the loan after repayment of principal  */ function closeLoan() external payable override nonReentrant onlyRepaymentImpl {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');      poolVariables.loanStatus = LoanStatus.CLOSED;      IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();     _withdrawAllCollateral(poolConstants.borrower, 0);     _pause();      emit PoolClosed(); }  /**  * @notice used to return total remaining repayments along with provided liquidity to the lender  * @dev burns all shares and returns total remaining repayments along with provided liquidity  */ function withdrawLiquidity() external isLender(msg.sender) nonReentrant {     LoanStatus _loanStatus = poolVariables.loanStatus;      require(         _loanStatus == LoanStatus.CLOSED ||             _loanStatus == LoanStatus.CANCELLED ||             _loanStatus == LoanStatus.DEFAULTED ||             _loanStatus == LoanStatus.TERMINATED,         'WL1'     );      //gets amount through liquidity shares     uint256 _actualBalance = balanceOf(msg.sender);     uint256 _toTransfer = _actualBalance;      if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {         uint256 _totalAsset;         if (poolConstants.borrowAsset != address(0)) {             _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));         } else {             _totalAsset = address(this).balance;         }         //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()         _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());     }      if (_loanStatus == LoanStatus.CANCELLED) {         _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));     }      if (_loanStatus == LoanStatus.CLOSED) {         //transfer repayment         _withdrawRepayment(msg.sender);     }     //to add transfer if not included in above (can be transferred with liquidity)     _burn(msg.sender, _actualBalance);      //transfer liquidity provided     SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);      emit LiquidityWithdrawn(_toTransfer, msg.sender); }  /**  * @notice function is executed by lender to exercise margin call  * @dev It will revert in case collateral ratio is not below expected value  * or the lender has already called it.  */  function requestMarginCall() external isLender(msg.sender) {     require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');     require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(msg.sender), 'RMC3');      lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());      emit MarginCalled(msg.sender); }  /**  * @notice used to get the interest accrued till current time in the current loan duration  * @return ineterest accrued till current time  */ function interestToPay() public view returns (uint256) {     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(         address(this)     );     uint256 _currentBlockTime = block.timestamp.mul(10**30);     uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));     if (_loanDurationTillNow &lt;= _loanDurationCovered) {         return 0;     }     uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);      return _interestAccrued; }  /**  * @notice used to calculate the collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _balance the principal amount lent  * @param _liquidityShares amount of collateral tokens available  * @return _ratio the collateral ratio  */ function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {     uint256 _interest = interestToPay().mul(_balance).div(totalSupply());     address _collateralAsset = poolConstants.collateralAsset;     address _strategy = poolConstants.poolSavingsStrategy;     uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);      uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);     _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest)); }  /**  * @notice used to get the current collateral ratio of the borrow pool  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the borrow pool  */ function getCurrentCollateralRatio() public returns (uint256 _ratio) {     uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);      _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares); }  /**  * @notice used to get the current collateral ratio of a lender  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @return _ratio the current collateral ratio of the lender  */ function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {     uint256 _balanceOfLender = balanceOf(_lender);     uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(         lenders[_lender].extraLiquidityShares     );      return (calculateCollateralRatio(_balanceOfLender, _liquidityShares)); }  /**  * @notice used to liquidate the pool if the borrower has defaulted  * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet  * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidatePool(     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     LoanStatus _currentPoolStatus = poolVariables.loanStatus;     IPoolFactory _poolFactory = IPoolFactory(poolFactory);     require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');     require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');     poolVariables.loanStatus = LoanStatus.DEFAULTED;      address _collateralAsset = poolConstants.collateralAsset;     address _borrowAsset = poolConstants.borrowAsset;     uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      uint256 _collateralTokens = _collateralLiquidityShare;     _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);      uint256 _poolBorrowTokens = correspondingBorrowTokens(         _collateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );     delete poolVariables.extraLiquidityShares;     delete poolVariables.baseLiquidityShares;      _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));     _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);     emit PoolLiquidated(msg.sender); }  /**  * @notice internal function used to withdraw tokens  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  * @param _asset address of the asset to be withdrawn  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _amountInTokens amount of tokens to be withdrawn from the pool  * @return amount of equivalent shares from given asset  */ function _withdraw(     bool _toSavingsAccount,     bool _recieveLiquidityShare,     address _asset,     address _poolSavingsStrategy,     uint256 _amountInTokens ) internal returns (uint256) {     ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());     return         SavingsAccountUtil.depositFromSavingsAccount(             _savingsAccount,             address(this),             msg.sender,             _amountInTokens,             _asset,             _poolSavingsStrategy,             _recieveLiquidityShare,             _toSavingsAccount         ); }  /**  * @notice used to ensure if a lender can be liquidated  * @param _lender address of the lender to be liquidated  */ function _canLenderBeLiquidated(address _lender) internal {     require((poolVariables.loanStatus == LoanStatus.ACTIVE) &amp;&amp; (block.timestamp &gt; poolConstants.loanWithdrawalDeadline), 'CLBL1');     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;     require(getMarginCallEndTime(_lender) != 0, 'CLBL2');     require(_marginCallEndTime &lt; block.timestamp, 'CLBL3');      require(poolConstants.idealCollateralRatio &gt; getCurrentCollateralRatio(_lender), 'CLBL4');     require(balanceOf(_lender) != 0, 'CLBL5'); }  /**  * @notice used to add extra liquidity shares to lender's share  * @param _lender address of the lender to be liquidated  * @return _lenderCollateralLPShare share of the lender in collateral tokens  * @return _lenderBalance balance of lender in pool tokens  */ function _updateLenderSharesDuringLiquidation(address _lender)     internal     returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) {     uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;     _lenderBalance = balanceOf(_lender);      uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());     uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;     poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);     poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);      _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares); }  /**  * @notice internal function to liquidate lender of the borrow pool  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _lender address of the lender to be liquidated  * @param _lenderCollateralTokens share of the lender in collateral tokens  */ function _liquidateForLender(     bool _fromSavingsAccount,     address _lender,     uint256 _lenderCollateralTokens ) internal {     address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;      IPoolFactory _poolFactory = IPoolFactory(poolFactory);     uint256 _lenderLiquidationTokens = correspondingBorrowTokens(         _lenderCollateralTokens,         _poolFactory.priceOracle(),         _poolFactory.liquidatorRewardFraction()     );      address _borrowAsset = poolConstants.borrowAsset;     _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);     _withdrawRepayment(_lender); }  /**  * @notice used to liquidate lender and burn lender's shares  * @param _lender address of the lender to be liquidated  * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet  * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet  * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn  */ function liquidateForLender(     address _lender,     bool _fromSavingsAccount,     bool _toSavingsAccount,     bool _recieveLiquidityShare ) external payable nonReentrant {     _canLenderBeLiquidated(_lender);      address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;     (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);      uint256 _lenderCollateralTokens = _lenderCollateralLPShare;     _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);      _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);      uint256 _amountReceived = _withdraw(         _toSavingsAccount,         _recieveLiquidityShare,         poolConstants.collateralAsset,         _poolSavingsStrategy,         _lenderCollateralTokens     );     _burn(_lender, _lenderBalance);     delete lenders[_lender];     emit LenderLiquidated(msg.sender, _lender, _amountReceived); }  /**  * @notice used to get corresponding borrow tokens for given collateral tokens  * @param _totalCollateralTokens amount of collateral tokens  * @param _priceOracle address of the pool  * @param _fraction Incentivizing fraction for the liquidator  * @return corresponding borrow tokens for collateral tokens  */ function correspondingBorrowTokens(     uint256 _totalCollateralTokens,     address _priceOracle,     uint256 _fraction ) public view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(         poolConstants.collateralAsset,         poolConstants.borrowAsset     );     return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30); }  /**  * @notice used to get the interest per second on the principal amount  * @param _principal amount of principal lent  * @return interest accrued on the principal in a second  */ function interestPerSecond(uint256 _principal) public view returns (uint256) {     uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);     return _interest; }  /**  * @notice used to get the interest per period on the principal amount  * @param _balance amount of principal lent  * @return interest accrued on the principal in a period  */ function interestPerPeriod(uint256 _balance) external view returns (uint256) {     return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval)); }  /**  * @notice used to get the current repayment period for the borrow pool  * @return current repayment period  */ function calculateCurrentPeriod() external view returns (uint256) {     uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);     return _currentPeriod; }  /**  * @notice internal function used to get the withdrawable amount for a _lender  * @param _lender address of the _lender  * @return amount of withdrawable token from the borrow pool  */ function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {     uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));      uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(         lenders[_lender].effectiveInterestWithdrawn     );      return _amountWithdrawable; }  /**  * @notice used to get the withdrawable amount of borrow token for a lender  */ function withdrawRepayment() external isLender(msg.sender) nonReentrant {     _withdrawRepayment(msg.sender); }  /**  * @notice internal function used to withdraw borrow asset from the pool by _lender  * @param _lender address of the _lender  */ function _withdrawRepayment(address _lender) internal {     uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);      if (_amountToWithdraw == 0) {         return;     }     lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);      SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender); }  /**  * @notice used to get the end time for a margin call  * @param _lender address of the lender who has requested a margin call  * @return the time at which the margin call ends  */ function getMarginCallEndTime(address _lender) public view override returns (uint256) {     uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();     uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;      if (block.timestamp &gt; _marginCallEndTime.add(_marginCallDuration.mul(2))) {         _marginCallEndTime = 0;     }     return _marginCallEndTime; }  /**  * @notice used to get the balance details of a _lender  * @param _lender address of the _lender  * @return amount of pool tokens available with the _lender  * @return amount of pool tokens available in the pool  */ function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {     return (balanceOf(_lender), totalSupply()); }  /**  * @notice used to get the loan status of the borrow pool  * @return integer respresenting loan status  */ function getLoanStatus() external view override returns (uint256) {     return uint256(poolVariables.loanStatus); }  /**  * @notice used to receive ethers from savings accounts  */ receive() external payable {}  /**  * @notice used to get the equivalent amount of tokens from source to target tokens  * @param _source address of the tokens to be converted  * @param _target address of target conversion token  * @param _amount amount of tokens to be converted  * @return the equivalent amount of target tokens for given source tokens  */ function getEquivalentTokens(     address _source,     address _target,     uint256 _amount ) public view returns (uint256) {     (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);     return _amount.mul(_price).div(10**_decimals); }  /**  * @notice used to get the address of the borrower of the pool  * @return address of the borrower  */ function borrower() external view override returns (address) {     return poolConstants.borrower; }  /**  * @notice used to total supply of pool tokens for the pool  * @return total supply of pool tokens  */ function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {     return ERC20Upgradeable.totalSupply(); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:55:50 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '../interfaces/IPoolFactory.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/IRepayment.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IPool.sol';
import '../interfaces/IExtension.sol';
import '../interfaces/IVerification.sol';

/**
 * @title Pool contract with Methods related to Pool
 * @notice Implements the functions related to Pool
 * @author Sublime
 */
contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum LoanStatus {
        COLLECTION, //denotes collection period
        ACTIVE, // denotes the active loan
        CLOSED, // Loan is repaid and closed
        CANCELLED, // Cancelled by borrower
        DEFAULTED, // Repayment defaulted by  borrower
        TERMINATED // Pool terminated by admin
    }

    address poolFactory;

    struct LendingDetails {
        uint256 effectiveInterestWithdrawn;
        uint256 marginCallEndTime;
        uint256 extraLiquidityShares;
    }

    // Pool constants
    struct PoolConstants {
        address borrower;
        uint256 borrowAmountRequested;
        uint256 loanStartTime;
        uint256 loanWithdrawalDeadline;
        address borrowAsset;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        uint256 noOfRepaymentIntervals;
        uint256 repaymentInterval;
        address collateralAsset;
        address poolSavingsStrategy; // invest contract
        address lenderVerifier;
    }

    struct PoolVariables {
        uint256 baseLiquidityShares;
        uint256 extraLiquidityShares;
        LoanStatus loanStatus;
        uint256 penaltyLiquidityAmount;
    }

    /**
     * @notice used to keep track of lenders' details
     */
    mapping(address => LendingDetails) public lenders;

    /**
     * @notice object of type PoolConstants
     */
    PoolConstants public poolConstants;

    /**
     * @notice object of type PoolVariables
     */
    PoolVariables public poolVariables;

    /**
     * @notice checks if the _user is pool's valid borrower
     * @param _user address of the borrower
     */
    modifier onlyBorrower(address _user) {
        require(_user == poolConstants.borrower, 'OB1');
        _;
    }

    /**
     * @notice checks if the _lender is pool's valid lender
     * @param _lender address of the lender
     */
    modifier isLender(address _lender) {
        require(balanceOf(_lender) != 0, 'IL1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's valid owner
     */
    modifier onlyOwner() {
        require(msg.sender == IPoolFactory(poolFactory).owner(), 'OO1');
        _;
    }

    /**
     * @notice checks if the msg.sender is pool's latest repayment implementation
     */
    modifier onlyRepaymentImpl() {
        require(msg.sender == IPoolFactory(poolFactory).repaymentImpl(), 'OR1');
        _;
    }

    /**
     * @notice initializing the pool and adding initial collateral
     * @param _borrowAmountRequested the amount of borrow asset requested by the borrower
     * @param _borrower address of the borrower
     * @param _borrowAsset address of the borrow asset
     * @param _collateralAsset address of the collateral asset
     * @param _idealCollateralRatio the ideal collateral ratio of the pool
     * @param _borrowRate the borrow rate as specified by borrower
     * @param _repaymentInterval the interval between to repayments
     * @param _noOfRepaymentIntervals number of repayments to be done by borrower
     * @param _poolSavingsStrategy address of the savings strategy preferred
     * @param _collateralAmount amount of collateral to be deposited by the borrower
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     * @param _loanWithdrawalDuration time interval for the borrower to withdraw the lent amount in borrow asset
     * @param _collectionPeriod time interval where lender lend into the borrow pool
     */
    function initialize(
        uint256 _borrowAmountRequested,
        uint256 _borrowRate,
        address _borrower,
        address _borrowAsset,
        address _collateralAsset,
        uint256 _idealCollateralRatio,
        uint256 _repaymentInterval,
        uint256 _noOfRepaymentIntervals,
        address _poolSavingsStrategy,
        uint256 _collateralAmount,
        bool _transferFromSavingsAccount,
        address _lenderVerifier,
        uint256 _loanWithdrawalDuration,
        uint256 _collectionPeriod
    ) external payable initializer {
        poolFactory = msg.sender;
        poolConstants.borrowAsset = _borrowAsset;
        poolConstants.idealCollateralRatio = _idealCollateralRatio;
        poolConstants.collateralAsset = _collateralAsset;
        poolConstants.poolSavingsStrategy = _poolSavingsStrategy;
        poolConstants.borrowAmountRequested = _borrowAmountRequested;
        _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);
        poolConstants.borrower = _borrower;
        poolConstants.borrowRate = _borrowRate;
        poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;
        poolConstants.repaymentInterval = _repaymentInterval;
        poolConstants.lenderVerifier = _lenderVerifier;

        poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);
        poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);
        __ERC20_init('Pool Tokens', 'PT');
        try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {
            _setupDecimals(_decimals);
        } catch(bytes memory) {}
    }

    /**
     * @notice add collateral to a pool
     * @param _amount amount of collateral to be deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function depositCollateral(uint256 _amount, bool _transferFromSavingsAccount) external payable override {
        require(_amount != 0, 'DC1');
        require(balanceOf(msg.sender) == 0, 'DC2');
        _depositCollateral(msg.sender, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice called when borrow pool is initialized to make initial collateral deposit
     * @param _borrower address of the borrower
     * @param _amount amount of collateral getting deposited denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from msg.sender's savings account, if false, it is transferred from their wallet
     */
    function _initialDeposit(
        address _borrower,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal {
        uint256 _equivalentCollateral = getEquivalentTokens(
            poolConstants.borrowAsset,
            poolConstants.collateralAsset,
            poolConstants.borrowAmountRequested
        );
        require(_amount >= poolConstants.idealCollateralRatio.mul(_equivalentCollateral).div(1e30), 'ID1');
        _depositCollateral(_borrower, _amount, _transferFromSavingsAccount);
    }

    /**
     * @notice internal function used to deposit collateral from _borrower to pool
     * @param _depositor address transferring the collateral
     * @param _amount amount of collateral to be transferred denominated in collateral asset
     * @param _transferFromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     */
    function _depositCollateral(
        address _depositor,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) internal nonReentrant {
        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            _depositor,
            address(this)
        );
        poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);
        emit CollateralAdded(_depositor, _amount, _sharesReceived);
    }

    /**
     * @notice internal function used to get amount of collateral deposited to the pool
     * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet
     * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account
     * @param _asset address of the asset to be deposited
     * @param _amount amount of tokens to be deposited in the pool
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _depositFrom address which makes the deposit
     * @param _depositTo address to which the tokens are deposited
     * @return _sharesReceived number of equivalent shares for given _asset
     */
    function _deposit(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        address _asset,
        uint256 _amount,
        address _poolSavingsStrategy,
        address _depositFrom,
        address _depositTo
    ) internal returns (uint256 _sharesReceived) {
        if (_fromSavingsAccount) {
            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _poolSavingsStrategy,
                true,
                _toSavingsAccount
            );
        } else {
            _sharesReceived = SavingsAccountUtil.directDeposit(
                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),
                _depositFrom,
                _depositTo,
                _amount,
                _asset,
                _toSavingsAccount,
                _poolSavingsStrategy
            );
        }
    }

    /**
     * @notice used to add extra collateral deposit during margin calls
     * @param _lender the address of the _lender who has requested for margin call
     * @param _amount amount of tokens requested for the margin call
     * @param _transferFromSavingsAccount if true, collateral is transferred from borrower's savings account, if false, it is transferred from borrower's wallet
     */
    function addCollateralInMarginCall(
        address _lender,
        uint256 _amount,
        bool _transferFromSavingsAccount
    ) external payable override nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'ACMC1');
        require(balanceOf(msg.sender) == 0, 'ACMC2');
        require(getMarginCallEndTime(_lender) >= block.timestamp, 'ACMC3');

        require(_amount != 0, 'ACMC4');

        uint256 _sharesReceived = _deposit(
            _transferFromSavingsAccount,
            true,
            poolConstants.collateralAsset,
            _amount,
            poolConstants.poolSavingsStrategy,
            msg.sender,
            address(this)
        );

        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.add(_sharesReceived);

        lenders[_lender].extraLiquidityShares = lenders[_lender].extraLiquidityShares.add(_sharesReceived);

        if (getCurrentCollateralRatio(_lender) >= poolConstants.idealCollateralRatio) {
            delete lenders[_lender].marginCallEndTime;
        }

        emit MarginCallCollateralAdded(msg.sender, _lender, _amount, _sharesReceived);
    }

    /**
     * @notice used by the borrower to withdraw tokens from the pool when loan is active
     */
    function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        uint256 _tokensLent = totalSupply();
        require(
            _poolStatus == LoanStatus.COLLECTION &&
                poolConstants.loanStartTime < block.timestamp &&
                block.timestamp < poolConstants.loanWithdrawalDeadline,
            'WBA1'
        );
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');

        poolVariables.loanStatus = LoanStatus.ACTIVE;
        uint256 _currentCollateralRatio = getCurrentCollateralRatio();
        require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');

        uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;
        uint256 _repaymentInterval = poolConstants.repaymentInterval;
        IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(
            _noOfRepaymentIntervals,
            _repaymentInterval,
            poolConstants.borrowRate,
            poolConstants.loanStartTime,
            poolConstants.borrowAsset
        );
        IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);

        address _borrowAsset = poolConstants.borrowAsset;
        (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();
        uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);
        delete poolConstants.loanWithdrawalDeadline;

        uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);

        SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);
        SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);

        emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);
    }

    /**
     * @notice internal function used to withdraw all collateral tokens from the pool (minus penalty)
     * @param _receiver address which receives all the collateral tokens
     * @param _penalty amount of penalty incurred by the borrower when pool is cancelled
     */
    function _withdrawAllCollateral(address _receiver, uint256 _penalty) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        uint256 _collateralShares = 0;
        if (poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares) > _penalty) {
            _collateralShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares).sub(_penalty);
        }
        // uint256 _collateralTokens = _collateralShares;
        uint256 _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralShares, _collateralAsset);

        poolVariables.baseLiquidityShares = _penalty;
        delete poolVariables.extraLiquidityShares;

        uint256 _sharesReceived;
        if (_collateralShares != 0) {
            ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
            _sharesReceived = SavingsAccountUtil.savingsAccountTransfer(
                _savingsAccount,
                address(this),
                _receiver,
                _collateralTokens,
                _collateralAsset,
                _poolSavingsStrategy
            );
        }
        emit CollateralWithdrawn(_receiver, _sharesReceived);
    }

    /**
     * @notice used by lender to supply liquidity to a borrow pool
     * @param _lender address of the lender
     * @param _amount amount of liquidity supplied by the _lender
     * @param _strategy address of strategy from which tokens are lent if done from savings account, 
     *                  in case of direct deposits, zeroAddress should be used
     */
    function lend(
        address _lender,
        uint256 _amount,
        address _strategy
    ) external payable nonReentrant {
        address _lenderVerifier = poolConstants.lenderVerifier;
        address _borrower = poolConstants.borrower;
        require(_lender != _borrower && _borrower != msg.sender, 'L1');
        if (_lenderVerifier != address(0)) {
            require(IVerification(IPoolFactory(poolFactory).userRegistry()).isUser(_lender, _lenderVerifier), 'L2');
        }
        require(poolVariables.loanStatus == LoanStatus.COLLECTION && block.timestamp < poolConstants.loanStartTime, 'L3');
        uint256 _borrowAmountNeeded = poolConstants.borrowAmountRequested;
        uint256 _lentAmount = totalSupply();
        if (_amount.add(_lentAmount) > _borrowAmountNeeded) {
            _amount = _borrowAmountNeeded.sub(_lentAmount);
        }

        address _borrowToken = poolConstants.borrowAsset;
        bool _fromSavingsAccount;
        if(_strategy != address(0)) {
            _fromSavingsAccount = true;
        }
        _deposit(
            _fromSavingsAccount,
            false,
            _borrowToken,
            _amount,
            _strategy,
            msg.sender,
            address(this)
        );
        _mint(_lender, _amount);
        emit LiquiditySupplied(_amount, _lender);
    }

    /**
     * @notice used to transfer borrow pool tokens among lenders
     * @param _from address of the lender who sends the borrow pool tokens
     * @param _to addres of the lender who receives the borrow pool tokens
     * @param _amount amount of borrow pool tokens transfered
     */
    function _beforeTokenTransfer(
        address _from,
        address _to,
        uint256 _amount
    ) internal override {
        if (_to != address(0)) {
            require(!paused(), 'TT1');
        }
        require(_to != poolConstants.borrower, 'TT2');

        if (_from == address(0) || _to == address(0)) {
            return;
        }
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _lenderVerifier = poolConstants.lenderVerifier;
        if (_lenderVerifier != address(0)) {
            require(IVerification(_poolFactory.userRegistry()).isUser(_to, _lenderVerifier), 'TT5');
        }
        require(getMarginCallEndTime(_from) == 0, 'TT3');
        require(getMarginCallEndTime(_to) == 0, 'TT4');

        //Withdraw repayments for user

        //We enforce pending interest withdrawals before the transfers
        
        //effectiveInterestWithdrawn stores the interest we assume addresses have withdrawn to simplify future interest withdrawals.
        // For eg, if _from has 100 pool tokens, _to has 50 pool tokens, and _amount is 50, the effectiveInterestWithdrawn for 
        // _from is done using 50 pool tokens, since future interest repayment withdrawals are done with respect to 50 tokens for _from
        // Similarly, we use 100 for _to's effectiveInterestWithdrawn calculation since their future interest withdrawals are calculated
        // based on 100 pool tokens. Refer calculateRepaymentWithdrawable()
        _withdrawRepayment(_from);
        _withdrawRepayment(_to);
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 _fromBalance = balanceOf(_from);
        uint256 _toBalance = balanceOf(_to);
        lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply);
        lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply);

        IExtension(_poolFactory.extension()).removeVotes(_from, _to, _amount);

        //transfer extra liquidity shares
        uint256 _liquidityShare = lenders[_from].extraLiquidityShares;
        if (_liquidityShare == 0) return;

        uint256 toTransfer = _liquidityShare;
        if (_amount != _fromBalance) {
            toTransfer = (_amount.mul(_liquidityShare)).div(_fromBalance);
        }

        lenders[_from].extraLiquidityShares = lenders[_from].extraLiquidityShares.sub(toTransfer);
        lenders[_to].extraLiquidityShares = lenders[_to].extraLiquidityShares.add(toTransfer);
    }

    function _calculatePenaltyTime(uint256 _loanStartTime, uint256 _loanWithdrawalDeadline) internal view returns (uint256) {
        uint256 _penaltyTime = poolConstants.repaymentInterval;
        if (block.timestamp > _loanStartTime) {
            uint256 _penaltyEndTime = block.timestamp;
            if (block.timestamp > _loanWithdrawalDeadline) {
                _penaltyEndTime = _loanWithdrawalDeadline;
            }
            _penaltyTime = _penaltyTime.add(_penaltyEndTime.sub(_loanStartTime));
        }
        return _penaltyTime;
    }

    /**
     * @notice used to cancel pool when the minimum borrow amount is not met
     */
    function cancelPool() external {
        LoanStatus _poolStatus = poolVariables.loanStatus;
        require(_poolStatus == LoanStatus.COLLECTION, 'CP1');
        uint256 _loanStartTime = poolConstants.loanStartTime;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);

        if (
            _loanStartTime < block.timestamp &&
            totalSupply() < _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30)
        ) {
            return _cancelPool(0);
        }

        uint256 _loanWithdrawalDeadline = poolConstants.loanWithdrawalDeadline;

        if (_loanWithdrawalDeadline > block.timestamp) {
            require(msg.sender == poolConstants.borrower, 'CP2');
        }
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares;
        uint256 _penaltyTime = _calculatePenaltyTime(_loanStartTime, _loanWithdrawalDeadline);
        uint256 _cancelPenaltyMultiple = _poolFactory.poolCancelPenaltyMultiple();
        uint256 penalty = _cancelPenaltyMultiple
            .mul(poolConstants.borrowRate)
            .div(10**30)
            .mul(_collateralLiquidityShare)
            .div(10**30)
            .mul(_penaltyTime)
            .div(365 days);
        _cancelPool(penalty);
    }

    /**
     * @notice internal function to cancel borrow pool
     * @param _penalty amount to be paid as penalty to cancel pool
     */
    function _cancelPool(uint256 _penalty) internal {
        poolVariables.loanStatus = LoanStatus.CANCELLED;
        _withdrawAllCollateral(poolConstants.borrower, _penalty);
        _pause();
        emit PoolCancelled();
    }

    /**
     * @notice used to liquidate the penalty amount when pool is calcelled
     * @dev _receiveLiquidityShares doesn't matter when _toSavingsAccount is true
     * @param _toSavingsAccount if true, liquidity transfered to lender's savings account. If false, liquidity transfered to lender's wallet
     * @param _receiveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateCancelPenalty(bool _toSavingsAccount, bool _receiveLiquidityShare) external nonReentrant {
        require(poolVariables.loanStatus == LoanStatus.CANCELLED, 'LCP1');
        require(poolVariables.penaltyLiquidityAmount == 0, 'LCP2');
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        address _collateralAsset = poolConstants.collateralAsset;
        // note: extra liquidity shares are not applicable as the loan never reaches active state
        uint256 _collateralTokens = poolVariables.baseLiquidityShares;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralTokens, _collateralAsset);

        uint256 _liquidationTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        poolVariables.penaltyLiquidityAmount = _liquidationTokens;
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _liquidationTokens, msg.sender, address(this));
        _withdraw(
            _toSavingsAccount,
            _receiveLiquidityShare,
            poolConstants.collateralAsset,
            poolConstants.poolSavingsStrategy,
            _collateralTokens
        );
    }

    /**
     * @notice used to terminate the pool
     * @dev kill switch for owner to terminate the pool
     */
    function terminatePool() external onlyOwner {
        _withdrawAllCollateral(msg.sender, 0);
        _pause();
        poolVariables.loanStatus = LoanStatus.TERMINATED;
        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        emit PoolTerminated();
    }

    /**
     * @notice called to close the loan after repayment of principal
     */
    function closeLoan() external payable override nonReentrant onlyRepaymentImpl {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'CL1');

        poolVariables.loanStatus = LoanStatus.CLOSED;

        IExtension(IPoolFactory(poolFactory).extension()).closePoolExtension();
        _withdrawAllCollateral(poolConstants.borrower, 0);
        _pause();

        emit PoolClosed();
    }

    /**
     * @notice used to return total remaining repayments along with provided liquidity to the lender
     * @dev burns all shares and returns total remaining repayments along with provided liquidity
     */
    function withdrawLiquidity() external isLender(msg.sender) nonReentrant {
        LoanStatus _loanStatus = poolVariables.loanStatus;

        require(
            _loanStatus == LoanStatus.CLOSED ||
                _loanStatus == LoanStatus.CANCELLED ||
                _loanStatus == LoanStatus.DEFAULTED ||
                _loanStatus == LoanStatus.TERMINATED,
            'WL1'
        );

        //gets amount through liquidity shares
        uint256 _actualBalance = balanceOf(msg.sender);
        uint256 _toTransfer = _actualBalance;

        if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {
            uint256 _totalAsset;
            if (poolConstants.borrowAsset != address(0)) {
                _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));
            } else {
                _totalAsset = address(this).balance;
            }
            //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()
            _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply());
        }

        if (_loanStatus == LoanStatus.CANCELLED) {
            _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply()));
        }

        if (_loanStatus == LoanStatus.CLOSED) {
            //transfer repayment
            _withdrawRepayment(msg.sender);
        }
        //to add transfer if not included in above (can be transferred with liquidity)
        _burn(msg.sender, _actualBalance);

        //transfer liquidity provided
        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _toTransfer, address(this), msg.sender);

        emit LiquidityWithdrawn(_toTransfer, msg.sender);
    }

    /**
     * @notice function is executed by lender to exercise margin call
     * @dev It will revert in case collateral ratio is not below expected value
     * or the lender has already called it.
     */

    function requestMarginCall() external isLender(msg.sender) {
        require(poolVariables.loanStatus == LoanStatus.ACTIVE, 'RMC1');

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(getMarginCallEndTime(msg.sender) == 0, 'RMC2');
        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(msg.sender), 'RMC3');

        lenders[msg.sender].marginCallEndTime = block.timestamp.add(_poolFactory.marginCallDuration());

        emit MarginCalled(msg.sender);
    }

    /**
     * @notice used to get the interest accrued till current time in the current loan duration
     * @return ineterest accrued till current time
     */
    function interestToPay() public view returns (uint256) {
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        (uint256 _loanDurationCovered, uint256 _interestPerSecond) = IRepayment(_poolFactory.repaymentImpl()).getInterestCalculationVars(
            address(this)
        );
        uint256 _currentBlockTime = block.timestamp.mul(10**30);
        uint256 _loanDurationTillNow = _currentBlockTime.sub(poolConstants.loanStartTime.mul(10**30));
        if (_loanDurationTillNow <= _loanDurationCovered) {
            return 0;
        }
        uint256 _interestAccrued = _interestPerSecond.mul(_loanDurationTillNow.sub(_loanDurationCovered)).div(10**60);

        return _interestAccrued;
    }

    /**
     * @notice used to calculate the collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _balance the principal amount lent
     * @param _liquidityShares amount of collateral tokens available
     * @return _ratio the collateral ratio
     */
    function calculateCollateralRatio(uint256 _balance, uint256 _liquidityShares) public returns (uint256 _ratio) {
        uint256 _interest = interestToPay().mul(_balance).div(totalSupply());
        address _collateralAsset = poolConstants.collateralAsset;
        address _strategy = poolConstants.poolSavingsStrategy;
        uint256 _currentCollateralTokens = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

        uint256 _equivalentCollateral = getEquivalentTokens(_collateralAsset, poolConstants.borrowAsset, _currentCollateralTokens);
        _ratio = _equivalentCollateral.mul(10**30).div(_balance.add(_interest));
    }

    /**
     * @notice used to get the current collateral ratio of the borrow pool
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the borrow pool
     */
    function getCurrentCollateralRatio() public returns (uint256 _ratio) {
        uint256 _liquidityShares = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);

        _ratio = calculateCollateralRatio(totalSupply(), _liquidityShares);
    }

    /**
     * @notice used to get the current collateral ratio of a lender
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @return _ratio the current collateral ratio of the lender
     */
    function getCurrentCollateralRatio(address _lender) public returns (uint256 _ratio) {
        uint256 _balanceOfLender = balanceOf(_lender);
        uint256 _liquidityShares = (poolVariables.baseLiquidityShares.mul(_balanceOfLender).div(totalSupply())).add(
            lenders[_lender].extraLiquidityShares
        );

        return (calculateCollateralRatio(_balanceOfLender, _liquidityShares));
    }

    /**
     * @notice used to liquidate the pool if the borrower has defaulted
     * @param _fromSavingsAccount if true, collateral is transferred from sender's savings account, if false, it is transferred from sender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to sender's savings account. If false, liquidity transfered to sender's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidatePool(
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        LoanStatus _currentPoolStatus = poolVariables.loanStatus;
        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        require(_currentPoolStatus == LoanStatus.ACTIVE, 'LP1');
        require(IRepayment(_poolFactory.repaymentImpl()).didBorrowerDefault(address(this)), 'LP2');
        poolVariables.loanStatus = LoanStatus.DEFAULTED;

        address _collateralAsset = poolConstants.collateralAsset;
        address _borrowAsset = poolConstants.borrowAsset;
        uint256 _collateralLiquidityShare = poolVariables.baseLiquidityShares.add(poolVariables.extraLiquidityShares);
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        uint256 _collateralTokens = _collateralLiquidityShare;
        _collateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_collateralLiquidityShare, _collateralAsset);

        uint256 _poolBorrowTokens = correspondingBorrowTokens(
            _collateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );
        delete poolVariables.extraLiquidityShares;
        delete poolVariables.baseLiquidityShares;

        _deposit(_fromSavingsAccount, false, _borrowAsset, _poolBorrowTokens, _poolFactory.noStrategyAddress(), msg.sender, address(this));
        _withdraw(_toSavingsAccount, _recieveLiquidityShare, _collateralAsset, _poolSavingsStrategy, _collateralTokens);
        emit PoolLiquidated(msg.sender);
    }

    /**
     * @notice internal function used to withdraw tokens
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     * @param _asset address of the asset to be withdrawn
     * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit
     * @param _amountInTokens amount of tokens to be withdrawn from the pool
     * @return amount of equivalent shares from given asset
     */
    function _withdraw(
        bool _toSavingsAccount,
        bool _recieveLiquidityShare,
        address _asset,
        address _poolSavingsStrategy,
        uint256 _amountInTokens
    ) internal returns (uint256) {
        ISavingsAccount _savingsAccount = ISavingsAccount(IPoolFactory(poolFactory).savingsAccount());
        return
            SavingsAccountUtil.depositFromSavingsAccount(
                _savingsAccount,
                address(this),
                msg.sender,
                _amountInTokens,
                _asset,
                _poolSavingsStrategy,
                _recieveLiquidityShare,
                _toSavingsAccount
            );
    }

    /**
     * @notice used to ensure if a lender can be liquidated
     * @param _lender address of the lender to be liquidated
     */
    function _canLenderBeLiquidated(address _lender) internal {
        require((poolVariables.loanStatus == LoanStatus.ACTIVE) && (block.timestamp > poolConstants.loanWithdrawalDeadline), 'CLBL1');
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;
        require(getMarginCallEndTime(_lender) != 0, 'CLBL2');
        require(_marginCallEndTime < block.timestamp, 'CLBL3');

        require(poolConstants.idealCollateralRatio > getCurrentCollateralRatio(_lender), 'CLBL4');
        require(balanceOf(_lender) != 0, 'CLBL5');
    }

    /**
     * @notice used to add extra liquidity shares to lender's share
     * @param _lender address of the lender to be liquidated
     * @return _lenderCollateralLPShare share of the lender in collateral tokens
     * @return _lenderBalance balance of lender in pool tokens
     */
    function _updateLenderSharesDuringLiquidation(address _lender)
        internal
        returns (uint256 _lenderCollateralLPShare, uint256 _lenderBalance)
    {
        uint256 _poolBaseLPShares = poolVariables.baseLiquidityShares;
        _lenderBalance = balanceOf(_lender);

        uint256 _lenderBaseLPShares = (_poolBaseLPShares.mul(_lenderBalance)).div(totalSupply());
        uint256 _lenderExtraLPShares = lenders[_lender].extraLiquidityShares;
        poolVariables.baseLiquidityShares = _poolBaseLPShares.sub(_lenderBaseLPShares);
        poolVariables.extraLiquidityShares = poolVariables.extraLiquidityShares.sub(_lenderExtraLPShares);

        _lenderCollateralLPShare = _lenderBaseLPShares.add(_lenderExtraLPShares);
    }

    /**
     * @notice internal function to liquidate lender of the borrow pool
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _lender address of the lender to be liquidated
     * @param _lenderCollateralTokens share of the lender in collateral tokens
     */
    function _liquidateForLender(
        bool _fromSavingsAccount,
        address _lender,
        uint256 _lenderCollateralTokens
    ) internal {
        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;

        IPoolFactory _poolFactory = IPoolFactory(poolFactory);
        uint256 _lenderLiquidationTokens = correspondingBorrowTokens(
            _lenderCollateralTokens,
            _poolFactory.priceOracle(),
            _poolFactory.liquidatorRewardFraction()
        );

        address _borrowAsset = poolConstants.borrowAsset;
        _deposit(_fromSavingsAccount, false, _borrowAsset, _lenderLiquidationTokens, _poolSavingsStrategy, msg.sender, _lender);
        _withdrawRepayment(_lender);
    }

    /**
     * @notice used to liquidate lender and burn lender's shares
     * @param _lender address of the lender to be liquidated
     * @param _fromSavingsAccount if true, collateral is transferred from lender's savings account, if false, it is transferred from lender's wallet
     * @param _toSavingsAccount if true, liquidity transfered to receiver's savings account. If false, liquidity transfered to receiver's wallet
     * @param _recieveLiquidityShare if true, equivalent liquidity tokens are withdrawn. If false, assets are withdrawn
     */
    function liquidateForLender(
        address _lender,
        bool _fromSavingsAccount,
        bool _toSavingsAccount,
        bool _recieveLiquidityShare
    ) external payable nonReentrant {
        _canLenderBeLiquidated(_lender);

        address _poolSavingsStrategy = poolConstants.poolSavingsStrategy;
        (uint256 _lenderCollateralLPShare, uint256 _lenderBalance) = _updateLenderSharesDuringLiquidation(_lender);

        uint256 _lenderCollateralTokens = _lenderCollateralLPShare;
        _lenderCollateralTokens = IYield(_poolSavingsStrategy).getTokensForShares(_lenderCollateralLPShare, poolConstants.collateralAsset);

        _liquidateForLender(_fromSavingsAccount, _lender, _lenderCollateralTokens);

        uint256 _amountReceived = _withdraw(
            _toSavingsAccount,
            _recieveLiquidityShare,
            poolConstants.collateralAsset,
            _poolSavingsStrategy,
            _lenderCollateralTokens
        );
        _burn(_lender, _lenderBalance);
        delete lenders[_lender];
        emit LenderLiquidated(msg.sender, _lender, _amountReceived);
    }

    /**
     * @notice used to get corresponding borrow tokens for given collateral tokens
     * @param _totalCollateralTokens amount of collateral tokens
     * @param _priceOracle address of the pool
     * @param _fraction Incentivizing fraction for the liquidator
     * @return corresponding borrow tokens for collateral tokens
     */
    function correspondingBorrowTokens(
        uint256 _totalCollateralTokens,
        address _priceOracle,
        uint256 _fraction
    ) public view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(_priceOracle).getLatestPrice(
            poolConstants.collateralAsset,
            poolConstants.borrowAsset
        );
        return _totalCollateralTokens.mul(_ratioOfPrices).div(10**_decimals).mul(uint256(10**30).sub(_fraction)).div(10**30);
    }

    /**
     * @notice used to get the interest per second on the principal amount
     * @param _principal amount of principal lent
     * @return interest accrued on the principal in a second
     */
    function interestPerSecond(uint256 _principal) public view returns (uint256) {
        uint256 _interest = ((_principal).mul(poolConstants.borrowRate)).div(365 days);
        return _interest;
    }

    /**
     * @notice used to get the interest per period on the principal amount
     * @param _balance amount of principal lent
     * @return interest accrued on the principal in a period
     */
    function interestPerPeriod(uint256 _balance) external view returns (uint256) {
        return (interestPerSecond(_balance).mul(poolConstants.repaymentInterval));
    }

    /**
     * @notice used to get the current repayment period for the borrow pool
     * @return current repayment period
     */
    function calculateCurrentPeriod() external view returns (uint256) {
        uint256 _currentPeriod = (block.timestamp.sub(poolConstants.loanStartTime, '34')).div(poolConstants.repaymentInterval);
        return _currentPeriod;
    }

    /**
     * @notice internal function used to get the withdrawable amount for a _lender
     * @param _lender address of the _lender
     * @return amount of withdrawable token from the borrow pool
     */
    function calculateRepaymentWithdrawable(address _lender) public view returns (uint256) {
        uint256 _totalRepaidAmount = IRepayment(IPoolFactory(poolFactory).repaymentImpl()).getTotalRepaidAmount(address(this));

        uint256 _amountWithdrawable = (balanceOf(_lender).mul(_totalRepaidAmount).div(totalSupply())).sub(
            lenders[_lender].effectiveInterestWithdrawn
        );

        return _amountWithdrawable;
    }

    /**
     * @notice used to get the withdrawable amount of borrow token for a lender
     */
    function withdrawRepayment() external isLender(msg.sender) nonReentrant {
        _withdrawRepayment(msg.sender);
    }

    /**
     * @notice internal function used to withdraw borrow asset from the pool by _lender
     * @param _lender address of the _lender
     */
    function _withdrawRepayment(address _lender) internal {
        uint256 _amountToWithdraw = calculateRepaymentWithdrawable(_lender);

        if (_amountToWithdraw == 0) {
            return;
        }
        lenders[_lender].effectiveInterestWithdrawn = lenders[_lender].effectiveInterestWithdrawn.add(_amountToWithdraw);

        SavingsAccountUtil.transferTokens(poolConstants.borrowAsset, _amountToWithdraw, address(this), _lender);
    }

    /**
     * @notice used to get the end time for a margin call
     * @param _lender address of the lender who has requested a margin call
     * @return the time at which the margin call ends
     */
    function getMarginCallEndTime(address _lender) public view override returns (uint256) {
        uint256 _marginCallDuration = IPoolFactory(poolFactory).marginCallDuration();
        uint256 _marginCallEndTime = lenders[_lender].marginCallEndTime;

        if (block.timestamp > _marginCallEndTime.add(_marginCallDuration.mul(2))) {
            _marginCallEndTime = 0;
        }
        return _marginCallEndTime;
    }

    /**
     * @notice used to get the balance details of a _lender
     * @param _lender address of the _lender
     * @return amount of pool tokens available with the _lender
     * @return amount of pool tokens available in the pool
     */
    function getBalanceDetails(address _lender) external view override returns (uint256, uint256) {
        return (balanceOf(_lender), totalSupply());
    }

    /**
     * @notice used to get the loan status of the borrow pool
     * @return integer respresenting loan status
     */
    function getLoanStatus() external view override returns (uint256) {
        return uint256(poolVariables.loanStatus);
    }

    /**
     * @notice used to receive ethers from savings accounts
     */
    receive() external payable {}

    /**
     * @notice used to get the equivalent amount of tokens from source to target tokens
     * @param _source address of the tokens to be converted
     * @param _target address of target conversion token
     * @param _amount amount of tokens to be converted
     * @return the equivalent amount of target tokens for given source tokens
     */
    function getEquivalentTokens(
        address _source,
        address _target,
        uint256 _amount
    ) public view returns (uint256) {
        (uint256 _price, uint256 _decimals) = IPriceOracle(IPoolFactory(poolFactory).priceOracle()).getLatestPrice(_source, _target);
        return _amount.mul(_price).div(10**_decimals);
    }

    /**
     * @notice used to get the address of the borrower of the pool
     * @return address of the borrower
     */
    function borrower() external view override returns (address) {
        return poolConstants.borrower;
    }

    /**
     * @notice used to total supply of pool tokens for the pool
     * @return total supply of pool tokens
     */
    function totalSupply() public view override(ERC20Upgradeable, IPool) returns (uint256) {
        return ERC20Upgradeable.totalSupply();
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

