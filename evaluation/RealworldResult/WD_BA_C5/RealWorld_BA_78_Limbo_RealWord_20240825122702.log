[2024-25-08 12:27:02 INFO] **[Preprocessing]**

**ChatDev Starts** (20240825122702)

**Timestamp**: 20240825122702

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}


**project_name**: RealWorld_BA_78_Limbo

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_78_Limbo_RealWord_20240825122702.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-25-08 12:27:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n// import "hardhat/console.sol";\nimport "./facades/LimboDAOLike.sol";\nimport "./facades/Burnable.sol";\nimport "./facades/BehodlerLike.sol";\nimport "./facades/FlanLike.sol";\nimport "./facades/UniPairLike.sol";\nimport "./facades/MigratorLike.sol";\nimport "./facades/AMMHelper.sol";\nimport "./facades/AngbandLike.sol";\nimport "./facades/LimboAddTokenToBehodlerPowerLike.sol";\nimport "./DAO/Governable.sol";\nimport "./facades/FlashGovernanceArbiterLike.sol";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, "EF");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EI");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, "E1");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, "E6");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, "E4");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, "E5");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, "ED");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EB");\n    require(soul.state == SoulState.waitingToCross, "E2");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      "EC"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 12:27:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:27:02 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-25-08 12:27:10 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:27:10 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15658
completion_tokens: 472
total_tokens: 16130
cost: $-1.000000


[2024-25-08 12:27:10 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Let's dive into the provided Solidity contract and identify potential improvements or enhancements.

1. **Security Enhancements**: 
   - **Reentrancy Guard**: Implement a reentrancy guard on critical functions such as `stake`, `unstake`, and `migrate` to prevent reentrancy attacks, especially since funds are being transferred.
   - **Input Validation**: Ensure that all external calls to other contracts (like `migrate`) have proper checks to validate the state and responses. This can prevent unexpected behaviors if the external contracts are compromised or behave unexpectedly.

2. **Gas Optimization**:
   - **Batch Processing**: Consider allowing batch staking or unstaking to reduce the number of transactions and gas costs for users. This could be particularly useful for users who want to stake multiple tokens at once.
   - **Storage Optimization**: Review the use of storage variables and consider using smaller data types where appropriate to save gas costs.

3. **User Experience Improvements**:
   - **Event Emissions**: Ensure that all significant state changes emit events. For example, emitting an event when a user stakes or unstakes tokens can help in tracking user actions more effectively.
   - **User Feedback**: Implement functions that allow users to query their pending rewards or the status of their stakes in a more user-friendly manner.

4. **Governance Improvements**:
   - **Time Lock for Governance Actions**: Introduce a time lock for governance actions to prevent malicious or rushed changes. This allows the community to react if a governance decision is deemed harmful.
   - **Multi-Signature Governance**: Implement a multi-signature mechanism for critical governance actions to enhance security and ensure that no single entity can make significant changes without consensus.

5. **Testing and Auditing**:
   - **Comprehensive Testing**: Ensure that the contract is thoroughly tested with various scenarios, including edge cases, to identify potential vulnerabilities.
   - **Formal Verification**: Consider formal verification of critical components of the contract to mathematically prove the correctness of the logic.

6. **Upgradeability**:
   - **Proxy Pattern**: Implement a proxy pattern to allow for future upgrades of the contract without losing state or requiring users to migrate to a new contract.

Which of these suggestions resonates most with you, or do you have any other ideas in mind?

[2024-25-08 12:27:10 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n// import "hardhat/console.sol";\nimport "./facades/LimboDAOLike.sol";\nimport "./facades/Burnable.sol";\nimport "./facades/BehodlerLike.sol";\nimport "./facades/FlanLike.sol";\nimport "./facades/UniPairLike.sol";\nimport "./facades/MigratorLike.sol";\nimport "./facades/AMMHelper.sol";\nimport "./facades/AngbandLike.sol";\nimport "./facades/LimboAddTokenToBehodlerPowerLike.sol";\nimport "./DAO/Governable.sol";\nimport "./facades/FlashGovernanceArbiterLike.sol";\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n  modifier enabled() {\n    require(protocolEnabled, "EF");\n    ;\n  }\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EI");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, "E1");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, "E6");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, "E4");\n    uint256 pending = getPending(user, soul);\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n    uint256 pending = getPending(user, soul);\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, "E5");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, "ED");\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EB");\n    require(soul.state == SoulState.waitingToCross, "E2");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      "EC"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n// import "hardhat/console.sol";\nimport "./facades/LimboDAOLike.sol";\nimport "./facades/Burnable.sol";\nimport "./facades/BehodlerLike.sol";\nimport "./facades/FlanLike.sol";\nimport "./facades/UniPairLike.sol";\nimport "./facades/MigratorLike.sol";\nimport "./facades/AMMHelper.sol";\nimport "./facades/AngbandLike.sol";\nimport "./facades/LimboAddTokenToBehodlerPowerLike.sol";\nimport "./DAO/Governable.sol";\nimport "./facades/FlashGovernanceArbiterLike.sol";\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n  modifier enabled() {\n    require(protocolEnabled, "EF");\n    ;\n  }\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EI");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, "E1");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, "E6");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, "E4");\n    uint256 pending = getPending(user, soul);\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n    uint256 pending = getPending(user, soul);\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, "E5");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, "ED");\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EB");\n    require(soul.state == SoulState.waitingToCross, "E2");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      "EC"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s dive into the provided Solidity contract and identify potential improvements or enhancements.\n1. Security Enhancements: \n   - Reentrancy Guard: Implement a reentrancy guard on critical functions such as stake, unstake, and migrate to prevent reentrancy attacks, especially since funds are being transferred.\n   - Input Validation: Ensure that all external calls to other contracts (like migrate) have proper checks to validate the state and responses. This can prevent unexpected behaviors if the external contracts are compromised or behave unexpectedly.\n2. Gas Optimization:\n   - Batch Processing: Consider allowing batch staking or unstaking to reduce the number of transactions and gas costs for users. This could be particularly useful for users who want to stake multiple tokens at once.\n   - Storage Optimization: Review the use of storage variables and consider using smaller data types where appropriate to save gas costs.\n3. User Experience Improvements:\n   - Event Emissions: Ensure that all significant state changes emit events. For example, emitting an event when a user stakes or unstakes tokens can help in tracking user actions more effectively.\n   - User Feedback: Implement functions that allow users to query their pending rewards or the status of their stakes in a more user-friendly manner.\n4. Governance Improvements:\n   - Time Lock for Governance Actions: Introduce a time lock for governance actions to prevent malicious or rushed changes. This allows the community to react if a governance decision is deemed harmful.\n   - Multi-Signature Governance: Implement a multi-signature mechanism for critical governance actions to enhance security and ensure that no single entity can make significant changes without consensus.\n5. Testing and Auditing:\n   - Comprehensive Testing: Ensure that the contract is thoroughly tested with various scenarios, including edge cases, to identify potential vulnerabilities.\n   - Formal Verification: Consider formal verification of critical components of the contract to mathematically prove the correctness of the logic.\n6. Upgradeability:\n   - Proxy Pattern: Implement a proxy pattern to allow for future upgrades of the contract without losing state or requiring users to migrate to a new contract.\nWhich of these suggestions resonates most with you, or do you have any other ideas in mind?', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 12:27:10 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:27:10 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";
/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.
Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.
Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.
Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.
Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler
Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.
The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.
Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}
/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/
struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}
struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}
struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}
library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}
library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);
    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;
    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}
library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);
    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));
    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));
    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;
    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }
    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");
    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);
    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}
/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;
  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);
  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);
  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);
  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }
  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;
  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;
  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;
  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;
  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;
  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;
  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }
  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }
  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }
  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));
    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;
      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }
  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }
  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }
  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }
  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }
  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );
    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }
  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];
      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }
  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }
  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }
      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));
      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }
  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }
  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }
  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");
    uint256 pending = getPending(user, soul);
    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }
  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];
    uint256 pending = getPending(user, soul);
    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }
  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");
    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);
    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");
    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;
    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");
    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);
    emit BonusPaid(token, index, msg.sender, flanBonus);
  }
  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }
  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }
  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }
  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }
  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }
  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";
/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.
Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.
Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.
Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.
Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler
Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.
The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.
Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}
/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/
struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}
struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}
struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}
library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}
library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);
    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;
    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}
library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);
    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));
    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));
    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;
    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }
    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");
    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);
    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}
/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;
  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);
  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);
  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);
  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }
  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;
  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;
  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;
  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;
  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;
  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;
  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }
  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }
  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }
  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));
    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;
      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }
  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }
  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }
  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }
  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }
  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );
    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }
  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];
      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }
  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }
  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }
      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));
      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }
  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }
  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }
  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");
    uint256 pending = getPending(user, soul);
    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }
  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];
    uint256 pending = getPending(user, soul);
    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }
  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");
    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);
    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");
    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;
    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");
    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);
    emit BonusPaid(token, index, msg.sender, flanBonus);
  }
  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }
  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }
  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }
  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }
  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }
  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's dive into the provided Solidity contract and identify potential improvements or enhancements.
1. **Security Enhancements**: 
   - **Reentrancy Guard**: Implement a reentrancy guard on critical functions such as `stake`, `unstake`, and `migrate` to prevent reentrancy attacks, especially since funds are being transferred.
   - **Input Validation**: Ensure that all external calls to other contracts (like `migrate`) have proper checks to validate the state and responses. This can prevent unexpected behaviors if the external contracts are compromised or behave unexpectedly.
2. **Gas Optimization**:
   - **Batch Processing**: Consider allowing batch staking or unstaking to reduce the number of transactions and gas costs for users. This could be particularly useful for users who want to stake multiple tokens at once.
   - **Storage Optimization**: Review the use of storage variables and consider using smaller data types where appropriate to save gas costs.
3. **User Experience Improvements**:
   - **Event Emissions**: Ensure that all significant state changes emit events. For example, emitting an event when a user stakes or unstakes tokens can help in tracking user actions more effectively.
   - **User Feedback**: Implement functions that allow users to query their pending rewards or the status of their stakes in a more user-friendly manner.
4. **Governance Improvements**:
   - **Time Lock for Governance Actions**: Introduce a time lock for governance actions to prevent malicious or rushed changes. This allows the community to react if a governance decision is deemed harmful.
   - **Multi-Signature Governance**: Implement a multi-signature mechanism for critical governance actions to enhance security and ensure that no single entity can make significant changes without consensus.
5. **Testing and Auditing**:
   - **Comprehensive Testing**: Ensure that the contract is thoroughly tested with various scenarios, including edge cases, to identify potential vulnerabilities.
   - **Formal Verification**: Consider formal verification of critical components of the contract to mathematically prove the correctness of the logic.
6. **Upgradeability**:
   - **Proxy Pattern**: Implement a proxy pattern to allow for future upgrades of the contract without losing state or requiring users to migrate to a new contract.
Which of these suggestions resonates most with you, or do you have any other ideas in mind? Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-25-08 12:27:13 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:27:13 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 24013
completion_tokens: 1
total_tokens: 24014
cost: $-1.000000


[2024-25-08 12:27:13 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

1

[2024-25-08 12:27:13 INFO] **[Seminar Conclusion]**:

 1

[2024-25-08 12:27:13 INFO] **[Seminar Conclusion]**:

 <INFO> 1

[2024-25-08 12:27:13 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-25-08 12:27:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n// import "hardhat/console.sol";\nimport "./facades/LimboDAOLike.sol";\nimport "./facades/Burnable.sol";\nimport "./facades/BehodlerLike.sol";\nimport "./facades/FlanLike.sol";\nimport "./facades/UniPairLike.sol";\nimport "./facades/MigratorLike.sol";\nimport "./facades/AMMHelper.sol";\nimport "./facades/AngbandLike.sol";\nimport "./facades/LimboAddTokenToBehodlerPowerLike.sol";\nimport "./DAO/Governable.sol";\nimport "./facades/FlashGovernanceArbiterLike.sol";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, "EF");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EI");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, "E1");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, "E6");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, "E4");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, "E5");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, "ED");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EB");\n    require(soul.state == SoulState.waitingToCross, "E2");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      "EC"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 12:27:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:27:13 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 12:27:24 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:27:24 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15650
completion_tokens: 715
total_tokens: 16365
cost: $-1.000000


[2024-25-08 12:27:24 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows users to stake and unstake tokens, which involves transferring tokens to and from the contract. If an external contract is called during the token transfer (for example, in the `migrate` function), a malicious user could exploit this to re-enter the `stake` or `unstake` functions before the first call is completed. This could lead to unexpected behavior, such as double staking or draining funds.

RECOMMENDED MITIGATION: Use the Checks-Effects-Interactions pattern. Ensure that all state changes (effects) are made before calling external contracts (interactions). Additionally, consider using a reentrancy guard modifier (e.g., OpenZeppelin's `ReentrancyGuard`) to prevent reentrant calls.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: Several functions, such as `configureCrossingConfig`, `configureSoul`, and `adjustSoul`, do not validate the input parameters thoroughly. For example, there is no check to ensure that the `crossingThreshold` is a positive value. This could lead to unintended behavior or state corruption if invalid values are passed.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that all parameters are within acceptable ranges. For instance, check that `crossingThreshold`, `initialCrossingBonus`, and `fps` are greater than zero where applicable.
```

### VULNERABILITY: Flash Loan Attack Vector
```
DETAILED DESCRIPTION: The contract allows for flash governance actions that can be executed in a single transaction. If a malicious actor takes out a flash loan to manipulate the state of the contract (e.g., changing thresholds or bonuses), they could exploit this to gain an unfair advantage or drain funds.

RECOMMENDED MITIGATION: Introduce a cooldown period or a minimum collateral requirement for governance actions to prevent flash loan attacks. Additionally, consider implementing a more robust governance mechanism that requires a majority vote from stakeholders before critical changes can be made.
```

### VULNERABILITY: Improper Error Handling
```
DETAILED DESCRIPTION: The contract uses `require` statements to enforce conditions, but some error messages are generic (e.g., "E2", "E5"). This can make it difficult to diagnose issues when they arise. Moreover, if an error occurs during a token transfer, the state may not revert correctly, leading to inconsistencies.

RECOMMENDED MITIGATION: Use descriptive error messages that provide context about the failure. Additionally, ensure that all state changes are reverted correctly in case of a failure, particularly during token transfers.
```

### VULNERABILITY: Token Transfer Failures
```
DETAILED DESCRIPTION: The contract does not handle the case where token transfers fail (e.g., due to insufficient allowance or balance). If a transfer fails, the contract may enter an inconsistent state, leading to potential loss of funds or rewards.

RECOMMENDED MITIGATION: After every token transfer, check the return value (if applicable) and revert the transaction if the transfer fails. Use `SafeERC20` from OpenZeppelin, which already handles these checks.
```

### VULNERABILITY: Governance Function Exposure
```
DETAILED DESCRIPTION: The governance functions are initially unguarded, allowing the deploying developer to make changes without community oversight. This could lead to centralization of power and potential abuse by the deployer.

RECOMMENDED MITIGATION: Implement a governance mechanism that

[2024-25-08 12:27:24 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows users to stake and unstake tokens, which involves transferring tokens to and from the contract. If an external contract is called during the token transfer (for example, in the `migrate` function), a malicious user could exploit this to re-enter the `stake` or `unstake` functions before the first call is completed. This could lead to unexpected behavior, such as double staking or draining funds.

RECOMMENDED MITIGATION: Use the Checks-Effects-Interactions pattern. Ensure that all state changes (effects) are made before calling external contracts (interactions). Additionally, consider using a reentrancy guard modifier (e.g., OpenZeppelin's `ReentrancyGuard`) to prevent reentrant calls.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: Several functions, such as `configureCrossingConfig`, `configureSoul`, and `adjustSoul`, do not validate the input parameters thoroughly. For example, there is no check to ensure that the `crossingThreshold` is a positive value. This could lead to unintended behavior or state corruption if invalid values are passed.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that all parameters are within acceptable ranges. For instance, check that `crossingThreshold`, `initialCrossingBonus`, and `fps` are greater than zero where applicable.
```

### VULNERABILITY: Flash Loan Attack Vector
```
DETAILED DESCRIPTION: The contract allows for flash governance actions that can be executed in a single transaction. If a malicious actor takes out a flash loan to manipulate the state of the contract (e.g., changing thresholds or bonuses), they could exploit this to gain an unfair advantage or drain funds.

RECOMMENDED MITIGATION: Introduce a cooldown period or a minimum collateral requirement for governance actions to prevent flash loan attacks. Additionally, consider implementing a more robust governance mechanism that requires a majority vote from stakeholders before critical changes can be made.
```

### VULNERABILITY: Improper Error Handling
```
DETAILED DESCRIPTION: The contract uses `require` statements to enforce conditions, but some error messages are generic (e.g., "E2", "E5"). This can make it difficult to diagnose issues when they arise. Moreover, if an error occurs during a token transfer, the state may not revert correctly, leading to inconsistencies.

RECOMMENDED MITIGATION: Use descriptive error messages that provide context about the failure. Additionally, ensure that all state changes are reverted correctly in case of a failure, particularly during token transfers.
```

### VULNERABILITY: Token Transfer Failures
```
DETAILED DESCRIPTION: The contract does not handle the case where token transfers fail (e.g., due to insufficient allowance or balance). If a transfer fails, the contract may enter an inconsistent state, leading to potential loss of funds or rewards.

RECOMMENDED MITIGATION: After every token transfer, check the return value (if applicable) and revert the transaction if the transfer fails. Use `SafeERC20` from OpenZeppelin, which already handles these checks.
```

### VULNERABILITY: Governance Function Exposure
```
DETAILED DESCRIPTION: The governance functions are initially unguarded, allowing the deploying developer to make changes without community oversight. This could lead to centralization of power and potential abuse by the deployer.

RECOMMENDED MITIGATION: Implement a governance mechanism that

[2024-25-08 12:27:24 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-25-08 12:27:24 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 12:27:24 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:27:24 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 12:27:34 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:27:34 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7884
completion_tokens: 780
total_tokens: 8664
cost: $-1.000000


[2024-25-08 12:27:34 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Based on the provided smart contract code for the Limbo staking contract, the following security vulnerabilities and concerns have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**: 
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or call external contracts (like `migrate`, `claimReward`, and `unstake`) could be vulnerable to reentrancy attacks, where an attacker could exploit the contract's state before it is updated.

2. **Lack of Input Validation**:
   - Several functions do not adequately validate inputs, such as ensuring that the `amount` for staking or unstaking is greater than zero. This could lead to unexpected behavior or state changes.

3. **Flash Loan Vulnerability**:
   - The contract mentions the need for forced delays to mitigate flash loan attacks, but it does not implement specific mechanisms to enforce these delays. This could allow attackers to exploit the contract during migration or staking phases.

4. **Governance Risks**:
   - The governance functions are initially unguarded, allowing the deploying developer to make rapid changes without community oversight. This could lead to malicious governance actions if the deployer retains control.

5. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, there are still areas where arithmetic operations could lead to unexpected results, particularly in reward calculations and state transitions.

6. **Token Approval Risks**:
   - The `approveUnstake` function allows third-party contracts to have permission to migrate token balances. If not properly managed, this could lead to unauthorized access or token theft.

7. **Protocol Disablement**:
   - The ability to disable the protocol can be exploited if a malicious actor gains governance control. This could halt all operations and lock user funds.

8. **Potential for Excessive SCX Burning**:
   - The mechanism for burning excess SCX relies on external contract behavior (Behodler). If the external contract has vulnerabilities or behaves unexpectedly, it could lead to excessive burning or loss of funds.

9. **Inadequate Handling of Edge Cases**:
   - There are scenarios where the contract may not handle edge cases properly, such as when a user attempts to stake or unstake during state transitions, potentially leading to locked funds or failed transactions.

### Comprehensive Analysis Report:

The Limbo smart contract exhibits several security vulnerabilities that could be exploited by malicious actors. The lack of reentrancy guards, insufficient input validation, and the potential for governance risks are significant concerns that need to be addressed. Additionally, the contract's reliance on external contracts for critical operations introduces further risks, particularly regarding token burning and migration processes.

To enhance the security of the Limbo contract, the following recommendations are proposed:

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to protect functions that modify state and transfer tokens.

2. **Enhance Input Validation**: Ensure that all inputs are validated, particularly in functions that involve token transfers and state changes.

3. **Establish Flash Loan Protections**: Implement mechanisms to enforce delays between critical operations to mitigate flash loan attacks.

4. **Strengthen Governance Mechanisms**: Introduce multi-signature requirements or time-locks for governance actions to prevent malicious changes.

5. **Conduct Thorough Testing and Audits**: Regularly test the contract for edge cases and conduct comprehensive audits to identify and address potential vulnerabilities.

6. **Monitor External Dependencies**: Keep track of the behavior of external contracts (like Behodler) to ensure they do not introduce vulnerabilities into the Limbo contract.

By addressing these vulnerabilities and implementing the recommended measures, the security and reliability of the Limbo smart contract can be significantly improved, thereby protecting user funds and maintaining trust in the protocol.

[2024-25-08 12:27:34 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the Limbo staking contract, the following security vulnerabilities and concerns have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**: 
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or call external contracts (like `migrate`, `claimReward`, and `unstake`) could be vulnerable to reentrancy attacks, where an attacker could exploit the contract's state before it is updated.

2. **Lack of Input Validation**:
   - Several functions do not adequately validate inputs, such as ensuring that the `amount` for staking or unstaking is greater than zero. This could lead to unexpected behavior or state changes.

3. **Flash Loan Vulnerability**:
   - The contract mentions the need for forced delays to mitigate flash loan attacks, but it does not implement specific mechanisms to enforce these delays. This could allow attackers to exploit the contract during migration or staking phases.

4. **Governance Risks**:
   - The governance functions are initially unguarded, allowing the deploying developer to make rapid changes without community oversight. This could lead to malicious governance actions if the deployer retains control.

5. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow/underflow protection, there are still areas where arithmetic operations could lead to unexpected results, particularly in reward calculations and state transitions.

6. **Token Approval Risks**:
   - The `approveUnstake` function allows third-party contracts to have permission to migrate token balances. If not properly managed, this could lead to unauthorized access or token theft.

7. **Protocol Disablement**:
   - The ability to disable the protocol can be exploited if a malicious actor gains governance control. This could halt all operations and lock user funds.

8. **Potential for Excessive SCX Burning**:
   - The mechanism for burning excess SCX relies on external contract behavior (Behodler). If the external contract has vulnerabilities or behaves unexpectedly, it could lead to excessive burning or loss of funds.

9. **Inadequate Handling of Edge Cases**:
   - There are scenarios where the contract may not handle edge cases properly, such as when a user attempts to stake or unstake during state transitions, potentially leading to locked funds or failed transactions.

### Comprehensive Analysis Report:

The Limbo smart contract exhibits several security vulnerabilities that could be exploited by malicious actors. The lack of reentrancy guards, insufficient input validation, and the potential for governance risks are significant concerns that need to be addressed. Additionally, the contract's reliance on external contracts for critical operations introduces further risks, particularly regarding token burning and migration processes.

To enhance the security of the Limbo contract, the following recommendations are proposed:

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to protect functions that modify state and transfer tokens.

2. **Enhance Input Validation**: Ensure that all inputs are validated, particularly in functions that involve token transfers and state changes.

3. **Establish Flash Loan Protections**: Implement mechanisms to enforce delays between critical operations to mitigate flash loan attacks.

4. **Strengthen Governance Mechanisms**: Introduce multi-signature requirements or time-locks for governance actions to prevent malicious changes.

5. **Conduct Thorough Testing and Audits**: Regularly test the contract for edge cases and conduct comprehensive audits to identify and address potential vulnerabilities.

6. **Monitor External Dependencies**: Keep track of the behavior of external contracts (like Behodler) to ensure they do not introduce vulnerabilities into the Limbo contract.

By addressing these vulnerabilities and implementing the recommended measures, the security and reliability of the Limbo smart contract can be significantly improved, thereby protecting user funds and maintaining trust in the protocol.

[2024-25-08 12:27:34 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-25-08 12:27:34 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n// import "hardhat/console.sol";\nimport "./facades/LimboDAOLike.sol";\nimport "./facades/Burnable.sol";\nimport "./facades/BehodlerLike.sol";\nimport "./facades/FlanLike.sol";\nimport "./facades/UniPairLike.sol";\nimport "./facades/MigratorLike.sol";\nimport "./facades/AMMHelper.sol";\nimport "./facades/AngbandLike.sol";\nimport "./facades/LimboAddTokenToBehodlerPowerLike.sol";\nimport "./DAO/Governable.sol";\nimport "./facades/FlashGovernanceArbiterLike.sol";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, "EF");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EI");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, "E1");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, "E6");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, "E4");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, "E5");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, "ED");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EB");\n    require(soul.state == SoulState.waitingToCross, "E2");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      "EC"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 12:27:34 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:27:34 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 12:27:45 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:27:45 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15650
completion_tokens: 715
total_tokens: 16365
cost: $-1.000000


[2024-25-08 12:27:45 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards, particularly in functions that involve transferring tokens or minting rewards (e.g., `stake`, `unstake`, `migrate`, and `claimReward`). This could allow a malicious contract to re-enter these functions before the state changes are completed, leading to unexpected behavior, such as draining funds or minting excessive rewards.

RECOMMENDED MITIGATION: Implement a reentrancy guard using a mutex pattern or the OpenZeppelin `ReentrancyGuard` modifier to prevent reentrant calls. For example, wrap critical sections of the code that involve external calls with a nonReentrant modifier.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: The contract does not validate the input parameters in several functions, such as `configureCrossingConfig`, `adjustSoul`, and `configureSoul`. This could lead to unexpected behavior if invalid or malicious data is passed, potentially allowing governance manipulation or incorrect configurations.

RECOMMENDED MITIGATION: Add input validation checks to ensure that parameters are within expected ranges and types. For example, check that `crossingThreshold` is greater than zero and that `soulType` is valid before proceeding with the function logic.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: Functions that involve iterating over mappings or arrays (e.g., `claimReward`, `claimBonus`) could potentially run into gas limit issues if the number of entries is large. This could lead to denial of service for users trying to claim rewards.

RECOMMENDED MITIGATION: Consider implementing pagination or batch processing for functions that may iterate over large datasets. This will help ensure that users can always interact with the contract without hitting gas limits.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The contract uses governance-approved modifiers, but there are functions (like `disableProtocol` and `enableProtocol`) that can be called without sufficient checks on the governance mechanism. If the governance mechanism is compromised, it could lead to the protocol being disabled or enabled maliciously.

RECOMMENDED MITIGATION: Ensure that all governance-related functions are protected by robust access control mechanisms. Implement checks to verify that the caller has the appropriate governance rights and consider using a multi-signature wallet for critical functions.
```

### VULNERABILITY: Token Transfer Failures
```
DETAILED DESCRIPTION: The contract does not handle cases where token transfers fail (e.g., `IERC20(token).safeTransferFrom` and `IERC20(token).safeTransfer`). If a transfer fails, the state of the contract may become inconsistent, leading to loss of funds or rewards.

RECOMMENDED MITIGATION: Use the `SafeERC20` library for all token transfers, which already includes checks for transfer success. Additionally, ensure that the contract state is only updated after successful transfers.
```

### VULNERABILITY: Flash Loan Vulnerability
```
DETAILED DESCRIPTION: The contract allows for governance actions to be executed in a single transaction without sufficient checks against flash loan attacks. A malicious actor could take out a flash loan to manipulate governance votes or parameters.

RECOMMENDED MITIGATION: Implement checks to ensure that governance actions cannot be executed if the caller has recently taken out a flash loan. This could involve tracking the state of the contract and the timing of actions to prevent manipulation.
```



[2024-25-08 12:27:45 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement any reentrancy guards, particularly in functions that involve transferring tokens or minting rewards (e.g., `stake`, `unstake`, `migrate`, and `claimReward`). This could allow a malicious contract to re-enter these functions before the state changes are completed, leading to unexpected behavior, such as draining funds or minting excessive rewards.

RECOMMENDED MITIGATION: Implement a reentrancy guard using a mutex pattern or the OpenZeppelin `ReentrancyGuard` modifier to prevent reentrant calls. For example, wrap critical sections of the code that involve external calls with a nonReentrant modifier.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: The contract does not validate the input parameters in several functions, such as `configureCrossingConfig`, `adjustSoul`, and `configureSoul`. This could lead to unexpected behavior if invalid or malicious data is passed, potentially allowing governance manipulation or incorrect configurations.

RECOMMENDED MITIGATION: Add input validation checks to ensure that parameters are within expected ranges and types. For example, check that `crossingThreshold` is greater than zero and that `soulType` is valid before proceeding with the function logic.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: Functions that involve iterating over mappings or arrays (e.g., `claimReward`, `claimBonus`) could potentially run into gas limit issues if the number of entries is large. This could lead to denial of service for users trying to claim rewards.

RECOMMENDED MITIGATION: Consider implementing pagination or batch processing for functions that may iterate over large datasets. This will help ensure that users can always interact with the contract without hitting gas limits.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The contract uses governance-approved modifiers, but there are functions (like `disableProtocol` and `enableProtocol`) that can be called without sufficient checks on the governance mechanism. If the governance mechanism is compromised, it could lead to the protocol being disabled or enabled maliciously.

RECOMMENDED MITIGATION: Ensure that all governance-related functions are protected by robust access control mechanisms. Implement checks to verify that the caller has the appropriate governance rights and consider using a multi-signature wallet for critical functions.
```

### VULNERABILITY: Token Transfer Failures
```
DETAILED DESCRIPTION: The contract does not handle cases where token transfers fail (e.g., `IERC20(token).safeTransferFrom` and `IERC20(token).safeTransfer`). If a transfer fails, the state of the contract may become inconsistent, leading to loss of funds or rewards.

RECOMMENDED MITIGATION: Use the `SafeERC20` library for all token transfers, which already includes checks for transfer success. Additionally, ensure that the contract state is only updated after successful transfers.
```

### VULNERABILITY: Flash Loan Vulnerability
```
DETAILED DESCRIPTION: The contract allows for governance actions to be executed in a single transaction without sufficient checks against flash loan attacks. A malicious actor could take out a flash loan to manipulate governance votes or parameters.

RECOMMENDED MITIGATION: Implement checks to ensure that governance actions cannot be executed if the caller has recently taken out a flash loan. This could involve tracking the state of the contract and the timing of actions to prevent manipulation.
```



[2024-25-08 12:27:45 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-25-08 12:27:45 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 12:27:45 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:27:45 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 12:27:54 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:27:54 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7884
completion_tokens: 795
total_tokens: 8679
cost: $-1.000000


[2024-25-08 12:27:54 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Based on the provided smart contract code for the Limbo staking contract, the following security vulnerabilities and concerns have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**: 
   - The contract does not implement checks to prevent reentrancy attacks, particularly in functions that involve transferring tokens or updating user balances. This could allow malicious actors to exploit the contract by recursively calling functions.

2. **Lack of Input Validation**: 
   - Several functions do not adequately validate input parameters, such as ensuring that amounts are greater than zero or that the state of the soul is appropriate for the action being taken. This could lead to unexpected behaviors or state inconsistencies.

3. **Flash Loan Vulnerability**:
   - The contract's reliance on governance actions that can be executed in a single transaction may expose it to flash loan attacks. Malicious actors could manipulate governance parameters to their advantage before the community can react.

4. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, the contract still relies on external libraries and calculations that may not be safe. Care should be taken to ensure that all arithmetic operations are safe and do not lead to unexpected results.

5. **Improper Access Control**:
   - Certain functions, especially those related to governance and configuration, lack proper access control mechanisms. This could allow unauthorized users to modify critical parameters or states of the contract.

6. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. For instance, if a transfer fails, the contract should revert the transaction to prevent state inconsistencies.

7. **Potential for Denial of Service (DoS)**:
   - The contract could be susceptible to DoS attacks if certain conditions are not met, such as failing to receive tokens or rewards. This could lock users out of their funds or prevent them from participating in staking.

8. **Governance Manipulation**:
   - The governance model allows for rapid changes without sufficient checks, which could lead to governance manipulation or malicious actions by a small group of users.

### Comprehensive Analysis Report:

The Limbo smart contract presents a complex staking mechanism that integrates with the Behodler ecosystem. While the design aims to provide innovative staking and migration features, several security vulnerabilities have been identified that could compromise the integrity and functionality of the contract.

1. **Reentrancy and Flash Loan Vulnerabilities**: The absence of reentrancy guards and the potential for flash loan attacks highlight a critical area of concern. Implementing checks such as the "checks-effects-interactions" pattern and ensuring that governance actions are time-locked or require multi-signature approval could mitigate these risks.

2. **Input Validation and Access Control**: Strengthening input validation across all functions and ensuring that only authorized users can execute sensitive actions will enhance the contract's security posture. Utilizing OpenZeppelin's access control mechanisms can help enforce these restrictions.

3. **Error Handling**: The contract should implement robust error handling for token transfers and other critical operations. Utilizing `require` statements effectively and ensuring that all state changes are reverted in case of failure will help maintain consistency.

4. **Governance Mechanism Review**: The governance model should be reviewed to ensure that it cannot be easily manipulated. Introducing mechanisms such as quorum requirements for proposals and time delays for critical changes can help protect against malicious governance actions.

5. **Testing and Auditing**: Comprehensive testing, including unit tests and integration tests, should be conducted to identify edge cases and potential vulnerabilities. Additionally, a third-party audit by a reputable firm specializing in smart contract security is highly recommended.

In conclusion, while the Limbo contract offers a unique approach to staking and liquidity management, it must address the identified vulnerabilities to ensure the security and trust of its users. Implementing the recommended changes will significantly enhance the contract's resilience against potential attacks and misuse.

[2024-25-08 12:27:54 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the Limbo staking contract, the following security vulnerabilities and concerns have been identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**: 
   - The contract does not implement checks to prevent reentrancy attacks, particularly in functions that involve transferring tokens or updating user balances. This could allow malicious actors to exploit the contract by recursively calling functions.

2. **Lack of Input Validation**: 
   - Several functions do not adequately validate input parameters, such as ensuring that amounts are greater than zero or that the state of the soul is appropriate for the action being taken. This could lead to unexpected behaviors or state inconsistencies.

3. **Flash Loan Vulnerability**:
   - The contract's reliance on governance actions that can be executed in a single transaction may expose it to flash loan attacks. Malicious actors could manipulate governance parameters to their advantage before the community can react.

4. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, the contract still relies on external libraries and calculations that may not be safe. Care should be taken to ensure that all arithmetic operations are safe and do not lead to unexpected results.

5. **Improper Access Control**:
   - Certain functions, especially those related to governance and configuration, lack proper access control mechanisms. This could allow unauthorized users to modify critical parameters or states of the contract.

6. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. For instance, if a transfer fails, the contract should revert the transaction to prevent state inconsistencies.

7. **Potential for Denial of Service (DoS)**:
   - The contract could be susceptible to DoS attacks if certain conditions are not met, such as failing to receive tokens or rewards. This could lock users out of their funds or prevent them from participating in staking.

8. **Governance Manipulation**:
   - The governance model allows for rapid changes without sufficient checks, which could lead to governance manipulation or malicious actions by a small group of users.

### Comprehensive Analysis Report:

The Limbo smart contract presents a complex staking mechanism that integrates with the Behodler ecosystem. While the design aims to provide innovative staking and migration features, several security vulnerabilities have been identified that could compromise the integrity and functionality of the contract.

1. **Reentrancy and Flash Loan Vulnerabilities**: The absence of reentrancy guards and the potential for flash loan attacks highlight a critical area of concern. Implementing checks such as the "checks-effects-interactions" pattern and ensuring that governance actions are time-locked or require multi-signature approval could mitigate these risks.

2. **Input Validation and Access Control**: Strengthening input validation across all functions and ensuring that only authorized users can execute sensitive actions will enhance the contract's security posture. Utilizing OpenZeppelin's access control mechanisms can help enforce these restrictions.

3. **Error Handling**: The contract should implement robust error handling for token transfers and other critical operations. Utilizing `require` statements effectively and ensuring that all state changes are reverted in case of failure will help maintain consistency.

4. **Governance Mechanism Review**: The governance model should be reviewed to ensure that it cannot be easily manipulated. Introducing mechanisms such as quorum requirements for proposals and time delays for critical changes can help protect against malicious governance actions.

5. **Testing and Auditing**: Comprehensive testing, including unit tests and integration tests, should be conducted to identify edge cases and potential vulnerabilities. Additionally, a third-party audit by a reputable firm specializing in smart contract security is highly recommended.

In conclusion, while the Limbo contract offers a unique approach to staking and liquidity management, it must address the identified vulnerabilities to ensure the security and trust of its users. Implementing the recommended changes will significantly enhance the contract's resilience against potential attacks and misuse.

[2024-25-08 12:27:54 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-25-08 12:27:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n// import "hardhat/console.sol";\nimport "./facades/LimboDAOLike.sol";\nimport "./facades/Burnable.sol";\nimport "./facades/BehodlerLike.sol";\nimport "./facades/FlanLike.sol";\nimport "./facades/UniPairLike.sol";\nimport "./facades/MigratorLike.sol";\nimport "./facades/AMMHelper.sol";\nimport "./facades/AngbandLike.sol";\nimport "./facades/LimboAddTokenToBehodlerPowerLike.sol";\nimport "./DAO/Governable.sol";\nimport "./facades/FlashGovernanceArbiterLike.sol";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, "EF");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EI");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, "E1");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, "E6");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, "E4");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, "E5");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, "ED");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EB");\n    require(soul.state == SoulState.waitingToCross, "E2");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      "EC"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 12:27:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:27:54 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 12:28:05 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:28:05 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15650
completion_tokens: 715
total_tokens: 16365
cost: $-1.000000


[2024-25-08 12:28:05 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows users to stake and unstake tokens, which involves transferring tokens to and from the contract. If an external contract is called during the transfer process (e.g., in the `migrate` function), it could potentially call back into the Limbo contract before the state is updated, leading to unexpected behavior or loss of funds.

POTENTIAL IMPACT: An attacker could exploit this vulnerability to repeatedly call the `unstake` or `migrate` functions, draining funds from the contract or manipulating the state in their favor.

RECOMMENDED MITIGATION: Implement the Checks-Effects-Interactions pattern. Ensure that all state changes are made before any external calls (like token transfers). Additionally, consider using a reentrancy guard modifier (e.g., `nonReentrant`) from OpenZeppelin's ReentrancyGuard contract.
```

### VULNERABILITY: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where arithmetic operations could lead to unexpected results, especially with user-defined calculations (e.g., in the `getPending` function).

POTENTIAL IMPACT: If any arithmetic operation were to exceed the maximum or minimum value for a uint256, it could lead to incorrect calculations of rewards or staked amounts, potentially allowing users to claim more tokens than they are entitled to.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are carefully checked, and consider using SafeMath for clarity, even though Solidity 0.8.x handles this natively. Explicitly check for conditions that could lead to underflow or overflow before performing calculations.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The contract uses governance-approved modifiers for critical functions, but there is a risk that governance can be compromised or manipulated, allowing unauthorized users to call sensitive functions.

POTENTIAL IMPACT: If governance is compromised, an attacker could disable the protocol, adjust parameters, or manipulate token migrations, leading to potential loss of funds or exploitation of the contract.

RECOMMENDED MITIGATION: Implement a multi-signature wallet for governance actions to ensure that no single entity can control the contract. Additionally, consider implementing time-locks on sensitive governance actions to allow the community to react to potential malicious activities.
```

### VULNERABILITY: Flash Loan Attack
```
DETAILED DESCRIPTION: The contract allows for flash governance actions that can be executed in a single transaction. If an attacker can manipulate the state of the contract through a flash loan, they could potentially exploit the system for profit.

POTENTIAL IMPACT: An attacker could use a flash loan to manipulate governance parameters or exploit the migration process, leading to financial loss for the protocol and its users.

RECOMMENDED MITIGATION: Introduce a minimum collateral requirement for flash governance actions to ensure that the cost of executing a malicious action outweighs the potential profit. Additionally, implement a cooldown period for governance changes to prevent rapid exploitation.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: The contract does not perform thorough input validation on critical parameters in functions like `configureCrossingConfig`, `configureSoul`, and others. This could lead to invalid states or unexpected behavior.

POTENTIAL IMPACT: Invalid inputs could cause the contract to enter an inconsistent state, leading to potential loss of funds or inability

[2024-25-08 12:28:05 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows users to stake and unstake tokens, which involves transferring tokens to and from the contract. If an external contract is called during the transfer process (e.g., in the `migrate` function), it could potentially call back into the Limbo contract before the state is updated, leading to unexpected behavior or loss of funds.

POTENTIAL IMPACT: An attacker could exploit this vulnerability to repeatedly call the `unstake` or `migrate` functions, draining funds from the contract or manipulating the state in their favor.

RECOMMENDED MITIGATION: Implement the Checks-Effects-Interactions pattern. Ensure that all state changes are made before any external calls (like token transfers). Additionally, consider using a reentrancy guard modifier (e.g., `nonReentrant`) from OpenZeppelin's ReentrancyGuard contract.
```

### VULNERABILITY: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where arithmetic operations could lead to unexpected results, especially with user-defined calculations (e.g., in the `getPending` function).

POTENTIAL IMPACT: If any arithmetic operation were to exceed the maximum or minimum value for a uint256, it could lead to incorrect calculations of rewards or staked amounts, potentially allowing users to claim more tokens than they are entitled to.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are carefully checked, and consider using SafeMath for clarity, even though Solidity 0.8.x handles this natively. Explicitly check for conditions that could lead to underflow or overflow before performing calculations.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The contract uses governance-approved modifiers for critical functions, but there is a risk that governance can be compromised or manipulated, allowing unauthorized users to call sensitive functions.

POTENTIAL IMPACT: If governance is compromised, an attacker could disable the protocol, adjust parameters, or manipulate token migrations, leading to potential loss of funds or exploitation of the contract.

RECOMMENDED MITIGATION: Implement a multi-signature wallet for governance actions to ensure that no single entity can control the contract. Additionally, consider implementing time-locks on sensitive governance actions to allow the community to react to potential malicious activities.
```

### VULNERABILITY: Flash Loan Attack
```
DETAILED DESCRIPTION: The contract allows for flash governance actions that can be executed in a single transaction. If an attacker can manipulate the state of the contract through a flash loan, they could potentially exploit the system for profit.

POTENTIAL IMPACT: An attacker could use a flash loan to manipulate governance parameters or exploit the migration process, leading to financial loss for the protocol and its users.

RECOMMENDED MITIGATION: Introduce a minimum collateral requirement for flash governance actions to ensure that the cost of executing a malicious action outweighs the potential profit. Additionally, implement a cooldown period for governance changes to prevent rapid exploitation.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: The contract does not perform thorough input validation on critical parameters in functions like `configureCrossingConfig`, `configureSoul`, and others. This could lead to invalid states or unexpected behavior.

POTENTIAL IMPACT: Invalid inputs could cause the contract to enter an inconsistent state, leading to potential loss of funds or inability

[2024-25-08 12:28:05 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-25-08 12:28:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 12:28:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:28:05 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 12:28:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:28:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7884
completion_tokens: 792
total_tokens: 8676
cost: $-1.000000


[2024-25-08 12:28:15 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

### Summary of Security Vulnerabilities in the Limbo Smart Contract

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards, which could allow an attacker to exploit functions that transfer tokens or modify state variables, potentially leading to unexpected behavior or loss of funds.

2. **Lack of Input Validation**: 
   - Functions that accept parameters (e.g., `stake`, `unstake`, `configureSoul`) do not sufficiently validate input values. For instance, there is no check to ensure that the `amount` is greater than zero before proceeding with transfers.

3. **Potential for Integer Overflow/Underflow**: 
   - Although Solidity 0.8.x has built-in overflow and underflow protection, the contract uses arithmetic operations that could still lead to unexpected results if not handled properly, especially when dealing with user balances and rewards.

4. **Improper Access Control**: 
   - Some functions, particularly those related to governance and configuration, lack strict access control mechanisms. For example, the `configureCrossingConfig` and `adjustSoul` functions could potentially be called by unauthorized users if governance checks are not properly enforced.

5. **Delayed Migration Risks**: 
   - The contract allows for a migration delay (`crossingMigrationDelay`) which could be exploited by malicious actors to manipulate the state of the contract or the underlying assets during this window.

6. **Flash Governance Risks**: 
   - The flash governance mechanism, while designed to allow quick changes, could be abused if not properly monitored. The requirement for a large EYE deposit does not fully mitigate the risk of malicious governance actions.

7. **Token Transfer Failures**: 
   - The contract does not handle potential failures in token transfers (e.g., `IERC20(token).safeTransferFrom`). If a transfer fails, the contract may enter an inconsistent state, leading to loss of funds or rewards.

8. **Unclaimed Rewards and State Management**: 
   - The management of user rewards and state transitions (e.g., from `staking` to `waitingToCross`) could lead to scenarios where users are unable to claim their rewards or where the contract state becomes inconsistent.

9. **Lack of Emergency Mechanisms**: 
   - Although there are functions to disable the protocol, the process for re-enabling it is cumbersome and relies on formal proposals, which may not be timely in the event of an emergency.

### Comprehensive Analysis Report

The Limbo smart contract presents several security vulnerabilities that could be exploited by malicious actors, leading to potential loss of funds and compromise of the contract's integrity. The absence of reentrancy guards and insufficient input validation are critical issues that need immediate attention. Furthermore, the governance mechanisms, while designed for flexibility, introduce risks that could be exploited if not properly monitored.

To enhance the security posture of the contract, the following recommendations are proposed:

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to protect critical functions from reentrancy attacks.

2. **Enhance Input Validation**: Ensure all input parameters are validated before processing, particularly in functions that modify state or transfer tokens.

3. **Review Access Control**: Strengthen access control mechanisms to ensure that only authorized users can call sensitive functions.

4. **Monitor Flash Governance**: Establish a monitoring system for flash governance actions to prevent abuse and ensure community oversight.

5. **Handle Token Transfer Failures**: Implement error handling for token transfers to maintain contract consistency and prevent loss of funds.

6. **Establish Emergency Protocols**: Create a more efficient mechanism for re-enabling the protocol after it has been disabled, allowing for rapid response to emergencies.

By addressing these vulnerabilities, the Limbo smart contract can significantly improve its security and reliability, fostering greater trust among users and stakeholders in the Behodler ecosystem.

[2024-25-08 12:28:15 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Limbo Smart Contract

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards, which could allow an attacker to exploit functions that transfer tokens or modify state variables, potentially leading to unexpected behavior or loss of funds.

2. **Lack of Input Validation**: 
   - Functions that accept parameters (e.g., `stake`, `unstake`, `configureSoul`) do not sufficiently validate input values. For instance, there is no check to ensure that the `amount` is greater than zero before proceeding with transfers.

3. **Potential for Integer Overflow/Underflow**: 
   - Although Solidity 0.8.x has built-in overflow and underflow protection, the contract uses arithmetic operations that could still lead to unexpected results if not handled properly, especially when dealing with user balances and rewards.

4. **Improper Access Control**: 
   - Some functions, particularly those related to governance and configuration, lack strict access control mechanisms. For example, the `configureCrossingConfig` and `adjustSoul` functions could potentially be called by unauthorized users if governance checks are not properly enforced.

5. **Delayed Migration Risks**: 
   - The contract allows for a migration delay (`crossingMigrationDelay`) which could be exploited by malicious actors to manipulate the state of the contract or the underlying assets during this window.

6. **Flash Governance Risks**: 
   - The flash governance mechanism, while designed to allow quick changes, could be abused if not properly monitored. The requirement for a large EYE deposit does not fully mitigate the risk of malicious governance actions.

7. **Token Transfer Failures**: 
   - The contract does not handle potential failures in token transfers (e.g., `IERC20(token).safeTransferFrom`). If a transfer fails, the contract may enter an inconsistent state, leading to loss of funds or rewards.

8. **Unclaimed Rewards and State Management**: 
   - The management of user rewards and state transitions (e.g., from `staking` to `waitingToCross`) could lead to scenarios where users are unable to claim their rewards or where the contract state becomes inconsistent.

9. **Lack of Emergency Mechanisms**: 
   - Although there are functions to disable the protocol, the process for re-enabling it is cumbersome and relies on formal proposals, which may not be timely in the event of an emergency.

### Comprehensive Analysis Report

The Limbo smart contract presents several security vulnerabilities that could be exploited by malicious actors, leading to potential loss of funds and compromise of the contract's integrity. The absence of reentrancy guards and insufficient input validation are critical issues that need immediate attention. Furthermore, the governance mechanisms, while designed for flexibility, introduce risks that could be exploited if not properly monitored.

To enhance the security posture of the contract, the following recommendations are proposed:

1. **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to protect critical functions from reentrancy attacks.

2. **Enhance Input Validation**: Ensure all input parameters are validated before processing, particularly in functions that modify state or transfer tokens.

3. **Review Access Control**: Strengthen access control mechanisms to ensure that only authorized users can call sensitive functions.

4. **Monitor Flash Governance**: Establish a monitoring system for flash governance actions to prevent abuse and ensure community oversight.

5. **Handle Token Transfer Failures**: Implement error handling for token transfers to maintain contract consistency and prevent loss of funds.

6. **Establish Emergency Protocols**: Create a more efficient mechanism for re-enabling the protocol after it has been disabled, allowing for rapid response to emergencies.

By addressing these vulnerabilities, the Limbo smart contract can significantly improve its security and reliability, fostering greater trust among users and stakeholders in the Behodler ecosystem.

[2024-25-08 12:28:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n// import "hardhat/console.sol";\nimport "./facades/LimboDAOLike.sol";\nimport "./facades/Burnable.sol";\nimport "./facades/BehodlerLike.sol";\nimport "./facades/FlanLike.sol";\nimport "./facades/UniPairLike.sol";\nimport "./facades/MigratorLike.sol";\nimport "./facades/AMMHelper.sol";\nimport "./facades/AngbandLike.sol";\nimport "./facades/LimboAddTokenToBehodlerPowerLike.sol";\nimport "./DAO/Governable.sol";\nimport "./facades/FlashGovernanceArbiterLike.sol";\n\n/\nContract: LIMBO is the main staking contract. It corresponds conceptually to Sushi\'s Masterchef and takes design inspiration from Masterchef.\nContext: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.\nPurpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. \n         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). \n         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. \nSecondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.\nTypes of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.\nPrimary incentive: users staking on Limbo receive the perpetually minted Flan token. \nEconomics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. \n           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.\n           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list\n           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra \n           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.\n           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional \n           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will\n           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates \n           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).\nNomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.\n          1. A token listed on Limbo is a Soul\n          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.\n          3. A token crosses over when the TVL on Limbo exceeds a threshold.\n          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.\n\nSecurity note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.\n\nBasic staking incentives:\nFor both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.\n\nLate stakers considerations:\nSuppose you\'re the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.\nIn this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading\nto a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly \ninflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:\n1. provide sufficient incentive for later arrivals.\n2. Not punish early stakers and ideally reward them for being early.\n3. Not disproportionately inflate the supply of flan.\n\nCrossing incentives:\nAfter a crossing, stakers are no longer able to withdraw their tokens as they\'ll now be sent to Behodler. They\'ll therefore need to be compensated for loss of tokens. \nGovernance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:\n1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.\n2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to\nthe point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token.\nThe ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.\nThis means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler.\nThis is in addition to any Flan their received during the staking phase.\nNote: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. \nFor negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.\nA negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)\nStates of migration:\n1. calibration\nNo staking/unstaking.\n2. Staking\nStaking/unstaking. If type is threshold, take threshold into account\n3. WaitingToCross\nCan claim rewards. Can\'t unstake.\n4. CrossedOver\nInjected into Behodler\n\nFlash governance:\nSince there might be many souls staking, we don\'t want to have to go through long-to-confirm proposals.\nInstead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.\nTo protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up\nthan the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.\n\nThe community can then decide if their governance action was in accord with the wellbeing of Limbo.\nIf it isn\'t, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.\nEg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.\nA malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user\'s staked EYE.\nThe community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.\n\nRectangle of Fairness:\nWhen new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler\'s bonding curve, the \ncurrent value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up\nthe liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the \nmarket with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it\'s usually desirable to hold back a bit more than 25 for 2 reasons:\n1. SCX burns on transfer so that after all open market operations are complete, we\'d have less than 25 remaining. \n2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution \n/\nenum SoulState {\n  calibration,\n  staking,\n  waitingToCross,\n  crossedOver\n}\nenum SoulType {\n  uninitialized,\n  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler\n  perpetual //the type of staking pool most people are familiar with.\n}\n\n/\nError string legend:\ntoken not recognized as valid soul.\t           E1\ninvalid state\t                                 E2\nunstaking locked\t                             E3\nbalance exceeded\t                             E4\nbonus already claimed.\t                       E5\ncrossing bonus arithmetic invariant.\t         E6\ntoken accounted for.\t                         E7\nburning excess SCX failed.\t                   E8\nInvocation reward failed.\t                     E9\nonly threshold souls can be migrated           EB\nnot enough time between crossing and migration EC\nbonus must be positive                         ED\nUnauthorized call                              EE\nProtocol disabled                              EF\nReserve divergence tolerance exceeded          EG\nnot enough time between reserve stamps         EH\nMinimum APY only applicable to threshold souls EI\nGovernance action failed.                      EJ\nAccess Denied                                  EK\nERC20 Transfer Failed                          EL\nIncorrect SCX transfer to AMMHelper            EM\n/\n\nstruct Soul {\n  uint256 lastRewardTimestamp;\n  uint256 accumulatedFlanPerShare;\n  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler\n  SoulType soulType;\n  SoulState state;\n  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps\n}\n\nstruct CrossingParameters {\n  uint256 stakingBeginsTimestamp; //to calculate bonus\n  uint256 stakingEndsTimestamp;\n  int256 crossingBonusDelta; //change in teraFlanPerToken per second\n  uint256 initialCrossingBonus; //measured in teraFlanPerToken\n  bool burnable;\n}\n\nstruct CrossingConfig {\n  address behodler;\n  uint256 SCX_fee;\n  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.\n  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations\n  address morgothPower;\n  address angband;\n  address ammHelper;\n  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back\n}\n\nlibrary SoulLib {\n  function set(\n    Soul storage soul,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 fps\n  ) external {\n    soul.crossingThreshold = crossingThreshold;\n    soul.flanPerSecond = fps;\n    soul.state = SoulState(state);\n    soul.soulType = SoulType(soulType);\n  }\n}\n\nlibrary CrossingLib {\n  function set(\n    CrossingParameters storage params,\n    FlashGovernanceArbiterLike flashGoverner,\n    Soul storage soul,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) external {\n    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);\n    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n    params.burnable = burnable;\n\n    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);\n    soul.crossingThreshold = crossingThreshold;\n  }\n}\n\nlibrary MigrationLib {\n  function migrate(\n    address token,\n    LimboAddTokenToBehodlerPowerLike power,\n    CrossingParameters memory crossingParams,\n    CrossingConfig memory crossingConfig,\n    FlanLike flan,\n    uint256 RectangleOfFairness,\n    Soul storage soul\n  ) external returns (uint256, uint256) {\n    power.parameterize(token, crossingParams.burnable);\n\n    //invoke Angband execute on power that migrates token type to Behodler\n    uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);\n    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));\n\n    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));\n\n    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;\n\n    //for top up or exotic high value migrations.\n    if (scxMinted &lt;= adjustedRectangle) {\n      adjustedRectangle = scxMinted / 2;\n    }\n\n    //burn SCX - rectangle\n    uint256 excessSCX = scxMinted - adjustedRectangle;\n    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");\n\n    //use remaining scx to buy flan and pool it on an external AMM\n    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);\n    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);\n\n    //reward caller and update soul state\n    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");\n    soul.state = SoulState.crossedOver;\n    return (tokenBalance, lpMinted);\n  }\n}\n\n/// @title Limbo\n/// @author Justin Goro\n/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).\n/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.\ncontract Limbo is Governable {\n  using SafeERC20 for IERC20;\n  using SoulLib for Soul;\n  using MigrationLib for address;\n  using CrossingLib for CrossingParameters;\n\n  event SoulUpdated(address soul, uint256 fps);\n  event Staked(address staker, address soul, uint256 amount);\n  event Unstaked(address staker, address soul, uint256 amount);\n  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);\n\n  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);\n\n  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);\n\n  struct User {\n    uint256 stakedAmount;\n    uint256 rewardDebt;\n    bool bonusPaid;\n  }\n\n  uint256 constant TERA = 1E12;\n  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.\n  bool protocolEnabled = true;\n\n  ///@notice protocol settings for migrating threshold tokens to Behodler\n  CrossingConfig public crossingConfig;\n\n  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.\n  ///@dev tokenAddress-&gt;index-&gt;stakingInfo\n  mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls;\n\n  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate\n  mapping(address =&gt; uint256) public latestIndex;\n\n  ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo\n  mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;\n  ///@dev token-&gt;index-&gt;data\n  mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters;\n\n  ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount\n  mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;\n  FlanLike Flan;\n\n  modifier enabled() {\n    require(protocolEnabled, "EF");\n    _;\n  }\n\n  ///@notice helper function for approximating a total dollar value APY for a threshold soul.\n  ///@param token threshold soul\n  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY\n  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.\n  function attemptToTargetAPY(\n    address token,\n    uint256 desiredAPY,\n    uint256 daiThreshold\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EI");\n    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n  }\n\n  ///@notice refreshes current state of soul.\n  function updateSoul(address token) public {\n    Soul storage s = currentSoul(token);\n    updateSoul(token, s);\n  }\n\n  function updateSoul(address token, Soul storage soul) internal {\n    require(soul.soulType != SoulType.uninitialized, "E1");\n    uint256 finalTimeStamp = block.timestamp;\n    if (soul.state != SoulState.staking) {\n      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;\n    }\n    uint256 balance = IERC20(token).balanceOf(address(this));\n\n    if (balance &gt; 0) {\n      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;\n\n      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);\n    }\n    soul.lastRewardTimestamp = finalTimeStamp;\n  }\n\n  constructor(address flan, address limboDAO) Governable(limboDAO) {\n    Flan = FlanLike(flan);\n  }\n\n  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration\n  function configureCrossingConfig(\n    address behodler,\n    address angband,\n    address ammHelper,\n    address morgothPower,\n    uint256 migrationInvocationReward,\n    uint256 crossingMigrationDelay,\n    uint16 rectInflationFactor //0 to 100\n  ) public onlySuccessfulProposal {\n    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);\n    crossingConfig.behodler = behodler;\n    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;\n    crossingConfig.angband = angband;\n    crossingConfig.ammHelper = ammHelper;\n    crossingConfig.morgothPower = morgothPower;\n    require(rectInflationFactor &lt;= 10000, "E6");\n    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;\n  }\n\n  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly\n  function disableProtocol() public governanceApproved(true) {\n    protocolEnabled = false;\n  }\n\n  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.\n  function enableProtocol() public onlySuccessfulProposal {\n    protocolEnabled = true;\n  }\n\n  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly\n  ///@param token Soul to calibrate\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param fps Flan Per Second staked.\n  function adjustSoul(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    uint256 fps\n  ) public governanceApproved(false) {\n    Soul storage soul = currentSoul(token);\n    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);\n    soul.flanPerSecond = fps;\n\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n\n    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);\n    flashGoverner.enforceTolerance(\n      uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),\n      uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta)\n    );\n\n    params.initialCrossingBonus = initialCrossingBonus;\n    params.crossingBonusDelta = crossingBonusDelta;\n  }\n\n  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.\n  ///@dev Unlike with flash governance, variable movements are unguarded\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  ///@param soulType Indicates whether the soul is perpetual or threshold\n  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.\n  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour\n  function configureSoul(\n    address token,\n    uint256 crossingThreshold,\n    uint256 soulType,\n    uint256 state,\n    uint256 index,\n    uint256 fps\n  ) public onlySoulUpdateProposal {\n    {\n      latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];\n\n      Soul storage soul = currentSoul(token);\n      bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;\n      soul.set(crossingThreshold, soulType, state, fps);\n      if (SoulState(state) == SoulState.staking) {\n        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;\n      }\n      if(fallingBack){\n         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n    emit SoulUpdated(token, fps);\n  }\n\n  ///@notice We need to know how to handle threshold souls at the point of crossing\n  ///@param token The soul to configure\n  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component\n  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state\n  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken\n  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state\n  function configureCrossingParameters(\n    address token,\n    uint256 initialCrossingBonus,\n    int256 crossingBonusDelta,\n    bool burnable,\n    uint256 crossingThreshold\n  ) public governanceApproved(false) {\n    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];\n    Soul storage soul = currentSoul(token);\n    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);\n  }\n\n  ///@notice User facing stake function for handling both types of souls\n  ///@param token The soul to stake\n  ///@param amount The amount of tokens to stake\n  /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.\n   The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing\n   broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.\n   Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn\'t required to anticipate every attack vector.\n   /\n  function stake(address token, uint256 amount) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    uint256 currentIndex = latestIndex[token];\n    User storage user = userInfo[token][msg.sender][currentIndex];\n    if (amount &gt; 0) {\n      //dish out accumulated rewards.\n      uint256 pending = getPending(user, soul);\n      if (pending &gt; 0) {\n        Flan.mint(msg.sender, pending);\n      }\n\n      //Balance checking accounts for FOT discrepencies\n      uint256 oldBalance = IERC20(token).balanceOf(address(this));\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n      uint256 newBalance = IERC20(token).balanceOf(address(this));\n\n      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens\n      if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {\n        soul.state = SoulState.waitingToCross;\n        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;\n      }\n    }\n\n    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;\n    emit Staked(msg.sender, token, user.stakedAmount);\n  }\n\n  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.\n  ///@param token The soul to unstake\n  ///@param amount The amount of tokens to unstake\n  function unstake(address token, uint256 amount) public enabled {\n    _unstake(token, amount, msg.sender, msg.sender);\n  }\n\n  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)\n  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.\n  function unstakeFor(\n    address token,\n    uint256 amount,\n    address holder\n  ) public {\n    _unstake(token, amount, msg.sender, holder);\n  }\n\n  function _unstake(\n    address token,\n    uint256 amount,\n    address unstaker,\n    address holder\n  ) internal {\n    if (unstaker != holder) {\n      unstakeApproval[token][holder][unstaker] -= amount;\n    }\n    Soul storage soul = currentSoul(token);\n    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");\n    updateSoul(token, soul);\n    User storage user = userInfo[token][holder][latestIndex[token]];\n    require(user.stakedAmount &gt;= amount, "E4");\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0 &amp;&amp; amount &gt; 0) {\n      user.stakedAmount = user.stakedAmount - amount;\n      IERC20(token).safeTransfer(address(unstaker), amount);\n      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);\n      emit Unstaked(unstaker, token, amount);\n    }\n  }\n\n  ///@notice accumulated flan rewards from staking can be claimed\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have unclaimed rewards.\n  function claimReward(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    updateSoul(token, soul);\n    User storage user = userInfo[token][msg.sender][index];\n\n    uint256 pending = getPending(user, soul);\n\n    if (pending &gt; 0) {\n      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);\n      emit ClaimedReward(msg.sender, token, index, pending);\n    }\n  }\n\n  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus\n  ///@param token The soul for which to claim rewards\n  ///@param index souls no longer listed may still have an unclaimed bonus.\n  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.\n  function claimBonus(address token, uint256 index) public enabled {\n    Soul storage soul = souls[token][index];\n    CrossingParameters storage crossing = tokenCrossingParameters[token][index];\n    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");\n\n    User storage user = userInfo[token][msg.sender][index];\n    require(!user.bonusPaid, "E5");\n    user.bonusPaid = true;\n    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *\n      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);\n\n    //assert signs are the same\n    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");\n\n    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;\n\n    uint256 flanBonus = 0;\n    require(finalFlanPerTeraToken &gt; 0, "ED");\n\n    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;\n    Flan.mint(msg.sender, flanBonus);\n\n    emit BonusPaid(token, index, msg.sender, flanBonus);\n  }\n\n  /@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,\n  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM\n  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize \n  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.\n  /\n  function claimSecondaryRewards(address token) public {\n    SoulState state = currentSoul(token).state;\n    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");\n    uint256 balance = IERC20(token).balanceOf(address(this));\n    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);\n    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);\n  }\n\n  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure\n  /@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list\n   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted\n   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.\n   /\n  function migrate(address token) public enabled {\n    Soul storage soul = currentSoul(token);\n    require(soul.soulType == SoulType.threshold, "EB");\n    require(soul.state == SoulState.waitingToCross, "E2");\n    require(\n      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;\n        crossingConfig.crossingMigrationDelay,\n      "EC"\n    );\n    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(\n      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),\n      tokenCrossingParameters[token][latestIndex[token]],\n      crossingConfig,\n      Flan,\n      RectangleOfFairness,\n      soul\n    );\n    emit TokenListed(token, tokenBalance, lpMinted);\n  }\n\n  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo\n  function approveUnstake(\n    address soul,\n    address unstaker,\n    uint256 amount\n  ) external {\n    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount\n  }\n\n  function rewardAdjustDebt(\n    address recipient,\n    uint256 pending,\n    uint256 accumulatedFlanPerShare,\n    User storage user\n  ) internal {\n    Flan.mint(recipient, pending);\n    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;\n  }\n\n  function currentSoul(address token) internal view returns (Soul storage) {\n    return souls[token][latestIndex[token]];\n  }\n\n  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {\n    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;\n  }\n}\n', 'ideas': ' 1', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-25-08 12:28:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.8.4; import "@openzeppelin/contracts/access/Ownable.sol"; import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"; // import "hardhat/console.sol"; import "./facades/LimboDAOLike.sol"; import "./facades/Burnable.sol"; import "./facades/BehodlerLike.sol"; import "./facades/FlanLike.sol"; import "./facades/UniPairLike.sol"; import "./facades/MigratorLike.sol"; import "./facades/AMMHelper.sol"; import "./facades/AngbandLike.sol"; import "./facades/LimboAddTokenToBehodlerPowerLike.sol"; import "./DAO/Governable.sol"; import "./facades/FlashGovernanceArbiterLike.sol"; /* Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef. Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM. Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens.           In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB).           The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold.  Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens. Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual. Primary incentive: users staking on Limbo receive the perpetually minted Flan token.  Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan.             Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.            This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list            $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra             $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.            In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional             runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will            lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates             additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining). Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.           1. A token listed on Limbo is a Soul           2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.           3. A token crosses over when the TVL on Limbo exceeds a threshold.           4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls. Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors. Basic staking incentives: For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers. Late stakers considerations: Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked. In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly  inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to: 1. provide sufficient incentive for later arrivals. 2. Not punish early stakers and ideally reward them for being early. 3. Not disproportionately inflate the supply of flan. Crossing incentives: After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens.  Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold: 1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer. 2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 210000 = 20000 Flan per token. The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token. This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 320010 = 60030 Flan as reward for having their T migrated to Behodler. This is in addition to any Flan their received during the staking phase. Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins.  For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists. A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting) States of migration: 1. calibration No staking/unstaking. 2. Staking Staking/unstaking. If type is threshold, take threshold into account 3. WaitingToCross Can claim rewards. Can't unstake. 4. CrossedOver Injected into Behodler Flash governance: Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals. Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction. To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on. The community can then decide if their governance action was in accord with the wellbeing of Limbo. If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day. Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value. A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE. The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker. Rectangle of Fairness: When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the  current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the  market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons: 1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining.  2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution  */ enum SoulState {   calibration,   staking,   waitingToCross,   crossedOver } enum SoulType {   uninitialized,   threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler   perpetual //the type of staking pool most people are familiar with. } / Error string legend: token not recognized as valid soul.            E1 invalid state                                    E2 unstaking locked                                 E3 balance exceeded                                 E4 bonus already claimed.                         E5 crossing bonus arithmetic invariant.             E6 token accounted for.                             E7 burning excess SCX failed.                     E8 Invocation reward failed.                        E9 only threshold souls can be migrated           EB not enough time between crossing and migration EC bonus must be positive                         ED Unauthorized call                              EE Protocol disabled                              EF Reserve divergence tolerance exceeded          EG not enough time between reserve stamps         EH Minimum APY only applicable to threshold souls EI Governance action failed.                      EJ Access Denied                                  EK ERC20 Transfer Failed                          EL Incorrect SCX transfer to AMMHelper            EM / struct Soul {   uint256 lastRewardTimestamp;   uint256 accumulatedFlanPerShare;   uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler   SoulType soulType;   SoulState state;   uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps } struct CrossingParameters {   uint256 stakingBeginsTimestamp; //to calculate bonus   uint256 stakingEndsTimestamp;   int256 crossingBonusDelta; //change in teraFlanPerToken per second   uint256 initialCrossingBonus; //measured in teraFlanPerToken   bool burnable; } struct CrossingConfig {   address behodler;   uint256 SCX_fee;   uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.   uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations   address morgothPower;   address angband;   address ammHelper;   uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back } library SoulLib {   function set(     Soul storage soul,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 fps   ) external {     soul.crossingThreshold = crossingThreshold;     soul.flanPerSecond = fps;     soul.state = SoulState(state);     soul.soulType = SoulType(soulType);   } } library CrossingLib {   function set(     CrossingParameters storage params,     FlashGovernanceArbiterLike flashGoverner,     Soul storage soul,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) external {     flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);     flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta); params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta; params.burnable = burnable;  flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold); soul.crossingThreshold = crossingThreshold;  } } library MigrationLib {   function migrate(     address token,     LimboAddTokenToBehodlerPowerLike power,     CrossingParameters memory crossingParams,     CrossingConfig memory crossingConfig,     FlanLike flan,     uint256 RectangleOfFairness,     Soul storage soul   ) external returns (uint256, uint256) {     power.parameterize(token, crossingParams.burnable); //invoke Angband execute on power that migrates token type to Behodler uint256 tokenBalance = IERC20(token).balanceOf(address(this)); IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance); AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));  uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));  uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;  //for top up or exotic high value migrations. if (scxMinted &lt;= adjustedRectangle) {   adjustedRectangle = scxMinted / 2; }  //burn SCX - rectangle uint256 excessSCX = scxMinted - adjustedRectangle; require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");  //use remaining scx to buy flan and pool it on an external AMM IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle); uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);  //reward caller and update soul state require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9"); soul.state = SoulState.crossedOver; return (tokenBalance, lpMinted);  } } /// @title Limbo /// @author Justin Goro /// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold). /// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action. contract Limbo is Governable {   using SafeERC20 for IERC20;   using SoulLib for Soul;   using MigrationLib for address;   using CrossingLib for CrossingParameters; event SoulUpdated(address soul, uint256 fps);   event Staked(address staker, address soul, uint256 amount);   event Unstaked(address staker, address soul, uint256 amount);   event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted); event ClaimedReward(address staker, address soul, uint256 index, uint256 amount); event BonusPaid(address token, uint256 index, address recipient, uint256 bonus); struct User {     uint256 stakedAmount;     uint256 rewardDebt;     bool bonusPaid;   } uint256 constant TERA = 1E12;   uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.   bool protocolEnabled = true; ///@notice protocol settings for migrating threshold tokens to Behodler   CrossingConfig public crossingConfig; ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.   ///@dev tokenAddress-&gt;index-&gt;stakingInfo   mapping(address =&gt; mapping(uint256 =&gt; Soul)) public souls; ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate   mapping(address =&gt; uint256) public latestIndex; ///@dev tokenAddress-&gt;userAddress-&gt;soulIndex-&gt;Userinfo   mapping(address =&gt; mapping(address =&gt; mapping(uint256 =&gt; User))) public userInfo;   ///@dev token-&gt;index-&gt;data   mapping(address =&gt; mapping(uint256 =&gt; CrossingParameters)) public tokenCrossingParameters; ///@dev soul-&gt;owner-&gt;unstaker-&gt;amount   mapping(address =&gt; mapping(address =&gt; mapping(address =&gt; uint256))) unstakeApproval;   FlanLike Flan; modifier enabled() {     require(protocolEnabled, "EF");     _;   } ///@notice helper function for approximating a total dollar value APY for a threshold soul.   ///@param token threshold soul   ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY   ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.   function attemptToTargetAPY(     address token,     uint256 desiredAPY,     uint256 daiThreshold   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EI");     uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps;   } ///@notice refreshes current state of soul.   function updateSoul(address token) public {     Soul storage s = currentSoul(token);     updateSoul(token, s);   } function updateSoul(address token, Soul storage soul) internal {     require(soul.soulType != SoulType.uninitialized, "E1");     uint256 finalTimeStamp = block.timestamp;     if (soul.state != SoulState.staking) {       finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;     }     uint256 balance = IERC20(token).balanceOf(address(this)); if (balance &gt; 0) {   uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;    soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance); } soul.lastRewardTimestamp = finalTimeStamp;  } constructor(address flan, address limboDAO) Governable(limboDAO) {     Flan = FlanLike(flan);   } ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration   function configureCrossingConfig(     address behodler,     address angband,     address ammHelper,     address morgothPower,     uint256 migrationInvocationReward,     uint256 crossingMigrationDelay,     uint16 rectInflationFactor //0 to 100   ) public onlySuccessfulProposal {     crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);     crossingConfig.behodler = behodler;     crossingConfig.crossingMigrationDelay = crossingMigrationDelay;     crossingConfig.angband = angband;     crossingConfig.ammHelper = ammHelper;     crossingConfig.morgothPower = morgothPower;     require(rectInflationFactor &lt;= 10000, "E6");     crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;   } ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly   function disableProtocol() public governanceApproved(true) {     protocolEnabled = false;   } ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.   function enableProtocol() public onlySuccessfulProposal {     protocolEnabled = true;   } ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly   ///@param token Soul to calibrate   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param fps Flan Per Second staked.   function adjustSoul(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     uint256 fps   ) public governanceApproved(false) {     Soul storage soul = currentSoul(token);     flashGoverner.enforceTolerance(soul.flanPerSecond, fps);     soul.flanPerSecond = fps; CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];  flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus); flashGoverner.enforceTolerance(   uint256(params.crossingBonusDelta &lt; 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),   uint256(crossingBonusDelta &lt; 0 ? crossingBonusDelta * -1 : crossingBonusDelta) );  params.initialCrossingBonus = initialCrossingBonus; params.crossingBonusDelta = crossingBonusDelta;  } ///@notice Configuration of soul through formal proposal. Should only be called infrequently.   ///@dev Unlike with flash governance, variable movements are unguarded   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   ///@param soulType Indicates whether the soul is perpetual or threshold   ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.   ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour   function configureSoul(     address token,     uint256 crossingThreshold,     uint256 soulType,     uint256 state,     uint256 index,     uint256 fps   ) public onlySoulUpdateProposal {     {       latestIndex[token] = index &gt; latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];   Soul storage soul = currentSoul(token);   bool fallingBack = soul.state != SoulState.calibration &amp;&amp; SoulState(state) == SoulState.calibration;   soul.set(crossingThreshold, soulType, state, fps);   if (SoulState(state) == SoulState.staking) {     tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;   }   if(fallingBack){      tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } } emit SoulUpdated(token, fps);  } ///@notice We need to know how to handle threshold souls at the point of crossing   ///@param token The soul to configure   ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component   ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state   ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken   ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state   function configureCrossingParameters(     address token,     uint256 initialCrossingBonus,     int256 crossingBonusDelta,     bool burnable,     uint256 crossingThreshold   ) public governanceApproved(false) {     CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];     Soul storage soul = currentSoul(token);     params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);   } ///@notice User facing stake function for handling both types of souls   ///@param token The soul to stake   ///@param amount The amount of tokens to stake   /@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.    The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing    broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.    Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.    /   function stake(address token, uint256 amount) public enabled {     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     uint256 currentIndex = latestIndex[token];     User storage user = userInfo[token][msg.sender][currentIndex];     if (amount &gt; 0) {       //dish out accumulated rewards.       uint256 pending = getPending(user, soul);       if (pending &gt; 0) {         Flan.mint(msg.sender, pending);       }   //Balance checking accounts for FOT discrepencies   uint256 oldBalance = IERC20(token).balanceOf(address(this));   IERC20(token).safeTransferFrom(msg.sender, address(this), amount);   uint256 newBalance = IERC20(token).balanceOf(address(this));    user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens   if (soul.soulType == SoulType.threshold &amp;&amp; newBalance &gt; soul.crossingThreshold) {     soul.state = SoulState.waitingToCross;     tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;   } }  user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA; emit Staked(msg.sender, token, user.stakedAmount);  } ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.   ///@param token The soul to unstake   ///@param amount The amount of tokens to unstake   function unstake(address token, uint256 amount) public enabled {     _unstake(token, amount, msg.sender, msg.sender);   } ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)   ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.   function unstakeFor(     address token,     uint256 amount,     address holder   ) public {     _unstake(token, amount, msg.sender, holder);   } function _unstake(     address token,     uint256 amount,     address unstaker,     address holder   ) internal {     if (unstaker != holder) {       unstakeApproval[token][holder][unstaker] -= amount;     }     Soul storage soul = currentSoul(token);     require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");     updateSoul(token, soul);     User storage user = userInfo[token][holder][latestIndex[token]];     require(user.stakedAmount &gt;= amount, "E4"); uint256 pending = getPending(user, soul);  if (pending &gt; 0 &amp;&amp; amount &gt; 0) {   user.stakedAmount = user.stakedAmount - amount;   IERC20(token).safeTransfer(address(unstaker), amount);   rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);   emit Unstaked(unstaker, token, amount); }  } ///@notice accumulated flan rewards from staking can be claimed   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have unclaimed rewards.   function claimReward(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     updateSoul(token, soul);     User storage user = userInfo[token][msg.sender][index]; uint256 pending = getPending(user, soul);  if (pending &gt; 0) {   rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);   emit ClaimedReward(msg.sender, token, index, pending); }  } ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus   ///@param token The soul for which to claim rewards   ///@param index souls no longer listed may still have an unclaimed bonus.   ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.   function claimBonus(address token, uint256 index) public enabled {     Soul storage soul = souls[token][index];     CrossingParameters storage crossing = tokenCrossingParameters[token][index];     require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2"); User storage user = userInfo[token][msg.sender][index]; require(!user.bonusPaid, "E5"); user.bonusPaid = true; int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *   int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);  //assert signs are the same require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta &gt;= 0, "E6");  int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;  uint256 flanBonus = 0; require(finalFlanPerTeraToken &gt; 0, "ED");  flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA; Flan.mint(msg.sender, flanBonus);  emit BonusPaid(token, index, msg.sender, flanBonus);  } /*@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,   the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM   this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize    flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.   /   function claimSecondaryRewards(address token) public {     SoulState state = currentSoul(token).state;     require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");     uint256 balance = IERC20(token).balanceOf(address(this));     IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);     AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);   } ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure   /*@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list    * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted    * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.    /   function migrate(address token) public enabled {     Soul storage soul = currentSoul(token);     require(soul.soulType == SoulType.threshold, "EB");     require(soul.state == SoulState.waitingToCross, "E2");     require(       block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp &gt;         crossingConfig.crossingMigrationDelay,       "EC"     );     (uint256 tokenBalance, uint256 lpMinted) = token.migrate(       LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),       tokenCrossingParameters[token][latestIndex[token]],       crossingConfig,       Flan,       RectangleOfFairness,       soul     );     emit TokenListed(token, tokenBalance, lpMinted);   } ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo   function approveUnstake(     address soul,     address unstaker,     uint256 amount   ) external {     unstakeApproval[soul][msg.sender][unstaker] = amount; //soul-&gt;owner-&gt;unstaker-&gt;amount   } function rewardAdjustDebt(     address recipient,     uint256 pending,     uint256 accumulatedFlanPerShare,     User storage user   ) internal {     Flan.mint(recipient, pending);     user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;   } function currentSoul(address token) internal view returns (Soul storage) {     return souls[token][latestIndex[token]];   } function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {     return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;   } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 12:28:18 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-25-08 12:28:21 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 12:28:21 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15877
completion_tokens: 1
total_tokens: 15878
cost: $0.047635


[2024-25-08 12:28:21 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// import "hardhat/console.sol";
import "./facades/LimboDAOLike.sol";
import "./facades/Burnable.sol";
import "./facades/BehodlerLike.sol";
import "./facades/FlanLike.sol";
import "./facades/UniPairLike.sol";
import "./facades/MigratorLike.sol";
import "./facades/AMMHelper.sol";
import "./facades/AngbandLike.sol";
import "./facades/LimboAddTokenToBehodlerPowerLike.sol";
import "./DAO/Governable.sol";
import "./facades/FlashGovernanceArbiterLike.sol";

/*
Contract: LIMBO is the main staking contract. It corresponds conceptually to Sushi's Masterchef and takes design inspiration from Masterchef.
Context: Limbo is a part of the Behodler ecosystem. All dapps within the Behodler ecosystem either support or are supported by the Behodler AMM.
Purpose: As a single contract store of liquidity, Behodler AMM requires new tokens be initiated with the a TVL equal to the average TVL of existing tokens. 
         In Behodler nomenclature, the total value of all tokens in the AMM is the total value bonded (TVB) and the value of individual tokens is the average value bonded (AVB). 
         The primary goal of Limbo is to raise capital for prospective AMM tokens in order to meet the AVB threshold. 
Secondary goals: since Limbo possesses staking mechanics, a secondary goal is to encourage lockup of protocol tokens.
Types of staking: Staked tokens are either for migration to Behodler or for lockup. The former pools are threshold and the latter are perpetual.
Primary incentive: users staking on Limbo receive the perpetually minted Flan token. 
Economics: When the staked value of a threshold token is migrated to Behodler, SCX is generated. The SCX is used via an external AMM such as Uniswap to prop up the liquidity and value of Flan. 
           Rather than being used to purchase Flan on the open market, the generated SCX is paired with newly minted Flan in a ratio that steers the price of Flan toward parity with Dai.
           This mechanism of pairing and steering the price through minting is known in Behodler as price tilting and effectively doubles the liquidity raised. For instance, suppose we list
           $10000 of a new token on Behodler. We then take $10000 worth of SCX and pair it with $10000 of newly minted Flan, adding $20000 of token liquidity to an external AMM. The extra 
           $10000 will form the price support for newly minted Flan which can be used to encourage future migrations.
           In addition to migration driven liquidity growth, Flan will be rewarded for token lockup. For lockup of Flan, the price support pressure of reduced circulating supply will provide additional 
           runway from which to mint more Flan. For external AMM pair contracts involving SCX or Pyrotokens, the lockup will raise liquidity for those pairs which will promote arbitrage trading of the pairs which will
           lead to additional burning of those tokens. For direct lockup of SCX, additional minting of SCX corresponds algorithmically to increased liquidity on Behodler and an increased SCX price. This raises the AVB of Behodler which creates 
           additional liquidity for Flan during the next migration. Flan therefore has 4 supporting vectors: SCX from migration, price support for SCX via lockup, price support via PyroFlan and indirect price support of Flan and SCX via trading on external pairs (automining).
Nomenclature: Since words like token are incredibly generic, we need to provide context through naming. Sticking to an overall metaphor, to paraphrase MakerDao documentation, reduces code smells.
          1. A token listed on Limbo is a Soul
          2. When a token lists on Behodler, we say the soul is crossing over. The event is a crossing.
          3. A token crosses over when the TVL on Limbo exceeds a threshold.
          4. Tokens which do not cross over such as existing tokens listed on Behodler or the protocol tokens are perpetual souls.

Security note: Since the migration steps generate value transfers between protocols, forced delays should be instituted to close any flash loan or dominant miner ttack vectors.

Basic staking incentives:
For both perpatual and threshold souls, a flan per second statistic is divided proportionately amongst the existing stakers.

Late stakers considerations:
Suppose you're the last person to stake on a threshold soul. That is, your stake takes the soul over the crossing threshold and the soul is locked.
In this instance, you would have earned no Flan, creating a declining incentive for stakers to arrive and in the extreme leading
to a situation of never crossing the threshold for any soul. This is a tragedy of the commons situation that leads to an overly 
inflated and essentially worthless Flan. We need a strategy to ameliorate this. The strategy needs to:
1. provide sufficient incentive for later arrivals.
2. Not punish early stakers and ideally reward them for being early.
3. Not disproportionately inflate the supply of flan.

Crossing incentives:
After a crossing, stakers are no longer able to withdraw their tokens as they'll now be sent to Behodler. They'll therefore need to be compensated for loss of tokens. 
Governance can calibrate two variables on a soul to encourage prospective stakers in threshold souls to breach the threshold:
1. Initial crossing bonus (ICB) is the Flan per token paid to all stakers and is a positive integer.
2. Crossing bonus delta (CBD) is the Flan per token for every second the soul is live. For instance suppose the CBD is 2. From the very first token staked to
the point at which the threshold was crossed, the soul records 10000 seconds passing. This amounts to 2*10000 = 20000 Flan per token.
The ICB and CBD are combined to forma Total Flan Per Token (TF) and the individual user balance is multiplied by TF. For instance, using the example above, suppose the ICB is 10 Flan per token.
This means the total Flan per token paid out is 10 + 20000 = 20010 Flan per token. If a user has 3 T staked, they receive 3*20010 = 60030 Flan as reward for having their T migrated to Behodler.
This is in addition to any Flan their received during the staking phase.
Note: CBD can be negative. This creates a situation where the initial bonus per token is at its highest when the staking round begins. 
For negative CBD, the intent is to create a sense of urgency amongst prospective stakers to push the pool over the threshold. For positive CBD, the intent is to draw marginal stakers into the soul in a desire to receive the crossing bonus while the opportunity still exists.
A negative CBD benefits from strong communal coordination. For instance, if the token listed has a large, active and well heeled community, a negative CBD might act as a rallying cry to ape in. A positive CBD benefits from individually uncoordinated motivations (classical market setting)
States of migration:
1. calibration
No staking/unstaking.
2. Staking
Staking/unstaking. If type is threshold, take threshold into account
3. WaitingToCross
Can claim rewards. Can't unstake.
4. CrossedOver
Injected into Behodler

Flash governance:
Since there might be many souls staking, we don't want to have to go through long-to-confirm proposals.
Instead, we want to have the opportunity to flash a governance action quickly. Flash governance happens in the span of 1 transaction.
To protect the community and the integrity of the DAO, all flash governance decisions must be accompanied by a large EYE deposit that presumably is more costly to give up
than the most profitable attack vector. The deposit is locked for a duration long enough for a long form burn proposal to be voted on.

The community can then decide if their governance action was in accord with the wellbeing of Limbo.
If it isn't, they can slash the deposit by betwen 1 and 100%. Flash gov can only move a variable some percentage per day.
Eg. suppose we vote on snapshot to raise the threshold for Sushi to 1200 Sushi from 1180, 1.69%. Some chosen community member flash sets the threshold to the new value.
A malicious flash staker then sets the threshold down to 1150. The community believes that the latter user was acting against the will of the community and a formal proposal is deployed onchain which slashes the user's staked EYE.
The community votes on the proposal and the EYE is slashed. After a fixed timeout, the EYE belonging to the original flash staker.

Rectangle of Fairness:
When new lquidity is added to Behodler, SCX is generated. The fully undiluted price of the new quantity of SCX far exceeds the value of the tokens migrated. Because of the dynamics of Behodler's bonding curve, the 
current value of the AVB is always equal to about 25 SCX. If the AVB increases, the increase shows up as in increase in the SCX price so that the 25 SCX metric still holds. For this reason, only 25 SCX is used to prop up
the liquidity of Flan. The surplus SCX generated is burnt. Because multiplying 25 SCX by the current market price gives us a value equal to the AVB and because we wish to strike a balance between boosting Flan and not over diluting the 
market with too much SCX, this value is known as the Rectangle of Fairness. While 25 SCX is the value of AVB, it's usually desirable to hold back a bit more than 25 for 2 reasons:
1. SCX burns on transfer so that after all open market operations are complete, we'd have less than 25 remaining. 
2. CPMMs such as Uniswap impose hyperbolic price slippage so that trying to withdraw the full balance of SCX results in paying an assymptotically high Flan price. As such we can deploy a bit more than 25 SCX per migrations without worrying about added dilution 
*/
enum SoulState {
  calibration,
  staking,
  waitingToCross,
  crossedOver
}
enum SoulType {
  uninitialized,
  threshold, //the default soul type is staked and when reaching a threshold, migrates to Behodler
  perpetual //the type of staking pool most people are familiar with.
}

/*
Error string legend:
token not recognized as valid soul.	           E1
invalid state	                                 E2
unstaking locked	                             E3
balance exceeded	                             E4
bonus already claimed.	                       E5
crossing bonus arithmetic invariant.	         E6
token accounted for.	                         E7
burning excess SCX failed.	                   E8
Invocation reward failed.	                     E9
only threshold souls can be migrated           EB
not enough time between crossing and migration EC
bonus must be positive                         ED
Unauthorized call                              EE
Protocol disabled                              EF
Reserve divergence tolerance exceeded          EG
not enough time between reserve stamps         EH
Minimum APY only applicable to threshold souls EI
Governance action failed.                      EJ
Access Denied                                  EK
ERC20 Transfer Failed                          EL
Incorrect SCX transfer to AMMHelper            EM
*/

struct Soul {
  uint256 lastRewardTimestamp;
  uint256 accumulatedFlanPerShare;
  uint256 crossingThreshold; //the value at which this soul is elligible to cross over to Behodler
  SoulType soulType;
  SoulState state;
  uint256 flanPerSecond; // fps: we use a helper function to convert min APY into fps
}

struct CrossingParameters {
  uint256 stakingBeginsTimestamp; //to calculate bonus
  uint256 stakingEndsTimestamp;
  int256 crossingBonusDelta; //change in teraFlanPerToken per second
  uint256 initialCrossingBonus; //measured in teraFlanPerToken
  bool burnable;
}

struct CrossingConfig {
  address behodler;
  uint256 SCX_fee;
  uint256 migrationInvocationReward; //calling migrate is expensive. The caller should be rewarded in Flan.
  uint256 crossingMigrationDelay; // this ensures that if Flan is successfully attacked, governance will have time to lock Limbo and prevent bogus migrations
  address morgothPower;
  address angband;
  address ammHelper;
  uint16 rectangleOfFairnessInflationFactor; //0-100: if the community finds the requirement to be too strict, they can inflate how much SCX to hold back
}

library SoulLib {
  function set(
    Soul storage soul,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 fps
  ) external {
    soul.crossingThreshold = crossingThreshold;
    soul.flanPerSecond = fps;
    soul.state = SoulState(state);
    soul.soulType = SoulType(soulType);
  }
}

library CrossingLib {
  function set(
    CrossingParameters storage params,
    FlashGovernanceArbiterLike flashGoverner,
    Soul storage soul,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) external {
    flashGoverner.enforceTolerance(initialCrossingBonus, params.initialCrossingBonus);
    flashGoverner.enforceToleranceInt(crossingBonusDelta, params.crossingBonusDelta);

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
    params.burnable = burnable;

    flashGoverner.enforceTolerance(crossingThreshold, soul.crossingThreshold);
    soul.crossingThreshold = crossingThreshold;
  }
}

library MigrationLib {
  function migrate(
    address token,
    LimboAddTokenToBehodlerPowerLike power,
    CrossingParameters memory crossingParams,
    CrossingConfig memory crossingConfig,
    FlanLike flan,
    uint256 RectangleOfFairness,
    Soul storage soul
  ) external returns (uint256, uint256) {
    power.parameterize(token, crossingParams.burnable);

    //invoke Angband execute on power that migrates token type to Behodler
    uint256 tokenBalance = IERC20(token).balanceOf(address(this));
    IERC20(token).transfer(address(crossingConfig.morgothPower), tokenBalance);
    AngbandLike(crossingConfig.angband).executePower(address(crossingConfig.morgothPower));

    uint256 scxMinted = IERC20(address(crossingConfig.behodler)).balanceOf(address(this));

    uint256 adjustedRectangle = ((crossingConfig.rectangleOfFairnessInflationFactor) * RectangleOfFairness) / 100;

    //for top up or exotic high value migrations.
    if (scxMinted <= adjustedRectangle) {
      adjustedRectangle = scxMinted / 2;
    }

    //burn SCX - rectangle
    uint256 excessSCX = scxMinted - adjustedRectangle;
    require(BehodlerLike(crossingConfig.behodler).burn(excessSCX), "E8");

    //use remaining scx to buy flan and pool it on an external AMM
    IERC20(crossingConfig.behodler).transfer(crossingConfig.ammHelper, adjustedRectangle);
    uint256 lpMinted = AMMHelper(crossingConfig.ammHelper).stabilizeFlan(adjustedRectangle);

    //reward caller and update soul state
    require(flan.mint(msg.sender, crossingConfig.migrationInvocationReward), "E9");
    soul.state = SoulState.crossedOver;
    return (tokenBalance, lpMinted);
  }
}

/// @title Limbo
/// @author Justin Goro
/// @notice Tokens are either staked for locking (perpetual) or for migration to the Behodler AMM (threshold).
/// @dev The governance functions are initially unguarded to allow the deploying dev to rapidly set up without having to endure governance imposed time limits on proposals. Ending the config period is a irreversible action.
contract Limbo is Governable {
  using SafeERC20 for IERC20;
  using SoulLib for Soul;
  using MigrationLib for address;
  using CrossingLib for CrossingParameters;

  event SoulUpdated(address soul, uint256 fps);
  event Staked(address staker, address soul, uint256 amount);
  event Unstaked(address staker, address soul, uint256 amount);
  event TokenListed(address token, uint256 amount, uint256 scxfln_LP_minted);

  event ClaimedReward(address staker, address soul, uint256 index, uint256 amount);

  event BonusPaid(address token, uint256 index, address recipient, uint256 bonus);

  struct User {
    uint256 stakedAmount;
    uint256 rewardDebt;
    bool bonusPaid;
  }

  uint256 constant TERA = 1E12;
  uint256 constant RectangleOfFairness = 30 ether; //MP = 1/t. Rect = tMP = t(1/t) = 1. 25 is the result of scaling factors on Behodler.
  bool protocolEnabled = true;

  ///@notice protocol settings for migrating threshold tokens to Behodler
  CrossingConfig public crossingConfig;

  ///@notice Since a token can be listed more than once on Behodler, we index each listing to separate the rewards from each staking event.
  ///@dev tokenAddress->index->stakingInfo
  mapping(address => mapping(uint256 => Soul)) public souls;

  ///@notice Each token maintains its own index to allow Limbo to keep rewards for each staking event separate
  mapping(address => uint256) public latestIndex;

  ///@dev tokenAddress->userAddress->soulIndex->Userinfo
  mapping(address => mapping(address => mapping(uint256 => User))) public userInfo;
  ///@dev token->index->data
  mapping(address => mapping(uint256 => CrossingParameters)) public tokenCrossingParameters;

  ///@dev soul->owner->unstaker->amount
  mapping(address => mapping(address => mapping(address => uint256))) unstakeApproval;
  FlanLike Flan;

  modifier enabled() {
    require(protocolEnabled, "EF");
    _;
  }

  ///@notice helper function for approximating a total dollar value APY for a threshold soul.
  ///@param token threshold soul
  ///@param desiredAPY because values may be out of sync with the market, this function can only ever approximate an APY
  ///@param daiThreshold user can select a Behodler AVB in Dai. 0 indicates the migration oracle value for AVB should be used.
  function attemptToTargetAPY(
    address token,
    uint256 desiredAPY,
    uint256 daiThreshold
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EI");
    uint256 fps = AMMHelper(crossingConfig.ammHelper).minAPY_to_FPS(desiredAPY, daiThreshold);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;
  }

  ///@notice refreshes current state of soul.
  function updateSoul(address token) public {
    Soul storage s = currentSoul(token);
    updateSoul(token, s);
  }

  function updateSoul(address token, Soul storage soul) internal {
    require(soul.soulType != SoulType.uninitialized, "E1");
    uint256 finalTimeStamp = block.timestamp;
    if (soul.state != SoulState.staking) {
      finalTimeStamp = tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp;
    }
    uint256 balance = IERC20(token).balanceOf(address(this));

    if (balance > 0) {
      uint256 flanReward = (finalTimeStamp - soul.lastRewardTimestamp) * soul.flanPerSecond;

      soul.accumulatedFlanPerShare = soul.accumulatedFlanPerShare + ((flanReward * TERA) / balance);
    }
    soul.lastRewardTimestamp = finalTimeStamp;
  }

  constructor(address flan, address limboDAO) Governable(limboDAO) {
    Flan = FlanLike(flan);
  }

  ///@notice configure global migration settings such as the address of Behodler and the minumum delay between end of staking and migration
  function configureCrossingConfig(
    address behodler,
    address angband,
    address ammHelper,
    address morgothPower,
    uint256 migrationInvocationReward,
    uint256 crossingMigrationDelay,
    uint16 rectInflationFactor //0 to 100
  ) public onlySuccessfulProposal {
    crossingConfig.migrationInvocationReward = migrationInvocationReward * (1 ether);
    crossingConfig.behodler = behodler;
    crossingConfig.crossingMigrationDelay = crossingMigrationDelay;
    crossingConfig.angband = angband;
    crossingConfig.ammHelper = ammHelper;
    crossingConfig.morgothPower = morgothPower;
    require(rectInflationFactor <= 10000, "E6");
    crossingConfig.rectangleOfFairnessInflationFactor = rectInflationFactor;
  }

  ///@notice if an exploit in any part of Limbo or its souls is detected, anyone with sufficient EYE balance can disable the protocol instantly
  function disableProtocol() public governanceApproved(true) {
    protocolEnabled = false;
  }

  ///@notice Once disabled, the only way to reenable is via a formal proposal. This forces the community to deliberate on the legitimacy of the disabling that lead to this state. A malicious call to disable can have its EYE slashed.
  function enableProtocol() public onlySuccessfulProposal {
    protocolEnabled = true;
  }

  ///@notice Governance function for rapidly calibrating a soul. Useful for responding to large price movements quickly
  ///@param token Soul to calibrate
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param fps Flan Per Second staked.
  function adjustSoul(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    uint256 fps
  ) public governanceApproved(false) {
    Soul storage soul = currentSoul(token);
    flashGoverner.enforceTolerance(soul.flanPerSecond, fps);
    soul.flanPerSecond = fps;

    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];

    flashGoverner.enforceTolerance(params.initialCrossingBonus, initialCrossingBonus);
    flashGoverner.enforceTolerance(
      uint256(params.crossingBonusDelta < 0 ? params.crossingBonusDelta * -1 : params.crossingBonusDelta),
      uint256(crossingBonusDelta < 0 ? crossingBonusDelta * -1 : crossingBonusDelta)
    );

    params.initialCrossingBonus = initialCrossingBonus;
    params.crossingBonusDelta = crossingBonusDelta;
  }

  ///@notice Configuration of soul through formal proposal. Should only be called infrequently.
  ///@dev Unlike with flash governance, variable movements are unguarded
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  ///@param soulType Indicates whether the soul is perpetual or threshold
  ///@param state a threshold soul can be either staking, waitingToCross, or CrossedOver. Both soul types can be in calibration state.
  ///@param index a token could be initially liste as a threshold soul and then later added as perpetual. An index helps distinguish these two events so that user late to claim rewards have no artificial time constraints imposed on their behaviour
  function configureSoul(
    address token,
    uint256 crossingThreshold,
    uint256 soulType,
    uint256 state,
    uint256 index,
    uint256 fps
  ) public onlySoulUpdateProposal {
    {
      latestIndex[token] = index > latestIndex[token] ? latestIndex[token] + 1 : latestIndex[token];

      Soul storage soul = currentSoul(token);
      bool fallingBack = soul.state != SoulState.calibration && SoulState(state) == SoulState.calibration;
      soul.set(crossingThreshold, soulType, state, fps);
      if (SoulState(state) == SoulState.staking) {
        tokenCrossingParameters[token][latestIndex[token]].stakingBeginsTimestamp = block.timestamp;
      }
      if(fallingBack){
         tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }
    emit SoulUpdated(token, fps);
  }

  ///@notice We need to know how to handle threshold souls at the point of crossing
  ///@param token The soul to configure
  ///@param initialCrossingBonus Of the crossing bonus flan payout, this represents the fixed Flan per token component
  ///@param crossingBonusDelta Of the crossing bonus flan payout, this represents the payout per flan per second that the soul is in staking state
  ///@param burnable For listing on Behodler, is this token going to burn on trade or does it get its own Pyrotoken
  ///@param crossingThreshold The token balance on Behodler that triggers the soul to enter into waitingToCross state
  function configureCrossingParameters(
    address token,
    uint256 initialCrossingBonus,
    int256 crossingBonusDelta,
    bool burnable,
    uint256 crossingThreshold
  ) public governanceApproved(false) {
    CrossingParameters storage params = tokenCrossingParameters[token][latestIndex[token]];
    Soul storage soul = currentSoul(token);
    params.set(flashGoverner, soul, initialCrossingBonus, crossingBonusDelta, burnable, crossingThreshold);
  }

  ///@notice User facing stake function for handling both types of souls
  ///@param token The soul to stake
  ///@param amount The amount of tokens to stake
  /**@dev Can handle fee on transfer tokens but for more exotic tokens such as rebase tokens, use a proxy wrapper. See the TokenProxyRegistry for logistics.
   *The purpose of balance checking before and after transfer of tokens is to account for fee-on-transfer discrepencies so that tokens like SCX can be listed without inducing
   *broken states. The community is encouraged to use proxy wrappers for tokens which may open up Limbo or Beholer exploit vulnerabilities.
   *Security enforcement of tokens listed on Limbo is offloaded to governance so that Limbo isn't required to anticipate every attack vector.
   */
  function stake(address token, uint256 amount) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    uint256 currentIndex = latestIndex[token];
    User storage user = userInfo[token][msg.sender][currentIndex];
    if (amount > 0) {
      //dish out accumulated rewards.
      uint256 pending = getPending(user, soul);
      if (pending > 0) {
        Flan.mint(msg.sender, pending);
      }

      //Balance checking accounts for FOT discrepencies
      uint256 oldBalance = IERC20(token).balanceOf(address(this));
      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
      uint256 newBalance = IERC20(token).balanceOf(address(this));

      user.stakedAmount = user.stakedAmount + newBalance - oldBalance; //adding true difference accounts for FOT tokens
      if (soul.soulType == SoulType.threshold && newBalance > soul.crossingThreshold) {
        soul.state = SoulState.waitingToCross;
        tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp = block.timestamp;
      }
    }

    user.rewardDebt = (user.stakedAmount * soul.accumulatedFlanPerShare) / TERA;
    emit Staked(msg.sender, token, user.stakedAmount);
  }

  ///@notice User facing unstake function for handling both types of souls. For threshold souls, can only be called during staking phase.
  ///@param token The soul to unstake
  ///@param amount The amount of tokens to unstake
  function unstake(address token, uint256 amount) public enabled {
    _unstake(token, amount, msg.sender, msg.sender);
  }

  ///@notice Allows for Limbo to be upgraded 1 user at a time without introducing a system wide security risk. Anticipates moving tokens to Limbo2 (wen Limbo2??)
  ///@dev similar to ERC20.transferFrom, this function allows a user to approve an upgrade contract migrate their staked tokens safely.
  function unstakeFor(
    address token,
    uint256 amount,
    address holder
  ) public {
    _unstake(token, amount, msg.sender, holder);
  }

  function _unstake(
    address token,
    uint256 amount,
    address unstaker,
    address holder
  ) internal {
    if (unstaker != holder) {
      unstakeApproval[token][holder][unstaker] -= amount;
    }
    Soul storage soul = currentSoul(token);
    require(soul.state == SoulState.calibration || soul.state == SoulState.staking, "E2");
    updateSoul(token, soul);
    User storage user = userInfo[token][holder][latestIndex[token]];
    require(user.stakedAmount >= amount, "E4");

    uint256 pending = getPending(user, soul);

    if (pending > 0 && amount > 0) {
      user.stakedAmount = user.stakedAmount - amount;
      IERC20(token).safeTransfer(address(unstaker), amount);
      rewardAdjustDebt(unstaker, pending, soul.accumulatedFlanPerShare, user);
      emit Unstaked(unstaker, token, amount);
    }
  }

  ///@notice accumulated flan rewards from staking can be claimed
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have unclaimed rewards.
  function claimReward(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    updateSoul(token, soul);
    User storage user = userInfo[token][msg.sender][index];

    uint256 pending = getPending(user, soul);

    if (pending > 0) {
      rewardAdjustDebt(msg.sender, pending, soul.accumulatedFlanPerShare, user);
      emit ClaimedReward(msg.sender, token, index, pending);
    }
  }

  ///@notice for threshold souls only, claiming the compensation for migration tokens known as the Crossing Bonus
  ///@param token The soul for which to claim rewards
  ///@param index souls no longer listed may still have an unclaimed bonus.
  ///@dev The tera factor is to handle fixed point calculations without significant loss of precision.
  function claimBonus(address token, uint256 index) public enabled {
    Soul storage soul = souls[token][index];
    CrossingParameters storage crossing = tokenCrossingParameters[token][index];
    require(soul.state == SoulState.crossedOver || soul.state == SoulState.waitingToCross, "E2");

    User storage user = userInfo[token][msg.sender][index];
    require(!user.bonusPaid, "E5");
    user.bonusPaid = true;
    int256 accumulatedFlanPerTeraToken = crossing.crossingBonusDelta *
      int256(crossing.stakingEndsTimestamp - crossing.stakingBeginsTimestamp);

    //assert signs are the same
    require(accumulatedFlanPerTeraToken * crossing.crossingBonusDelta >= 0, "E6");

    int256 finalFlanPerTeraToken = int256(crossing.initialCrossingBonus) + accumulatedFlanPerTeraToken;

    uint256 flanBonus = 0;
    require(finalFlanPerTeraToken > 0, "ED");

    flanBonus = uint256((int256(user.stakedAmount) * finalFlanPerTeraToken)) / TERA;
    Flan.mint(msg.sender, flanBonus);

    emit BonusPaid(token, index, msg.sender, flanBonus);
  }

  /**@notice some tokens may be sent to Limbo by mistake or unhandled in some manner. For instance, if a Pooltogether token is listed and Limbo wins,
  the reward token may not have relevance on Limbo. If the token exists as a pair with Flan on the external AMM
  this function buys Flan from the AMM and burns it. A small percentage of the purchased Flan is sent to the caller to incentivize 
  flushing Limbo of stuck tokens. A secondary incentive exists to create new pairs for Flan.
  */
  function claimSecondaryRewards(address token) public {
    SoulState state = currentSoul(token).state;
    require(state == SoulState.calibration || state == SoulState.crossedOver, "E7");
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(crossingConfig.ammHelper, balance);
    AMMHelper(crossingConfig.ammHelper).buyFlanAndBurn(token, balance, msg.sender);
  }

  ///@notice migrates threshold token from Limbo to Behodler and orchestrates Flan boosting mechanics. Callers of this function are rewared to compensate for gas expenditure
  /**@dev this function depends on a Morgoth Power. For those unfamiliar, a power is similar to a spell on other DAOs. Morgoth owns Behodler and so the only way to list
   * a token on Behodler is via a Morgoth Power. Permission mapping is handled on Morgoth side. Calling this function assumes that the power has been calibrated and than Limbo has been granted
   * permission on Morgoth to execute migrations to Behodler. The other big depenency is the AMM helper which contains the bulk of the migration logic.
   */
  function migrate(address token) public enabled {
    Soul storage soul = currentSoul(token);
    require(soul.soulType == SoulType.threshold, "EB");
    require(soul.state == SoulState.waitingToCross, "E2");
    require(
      block.timestamp - tokenCrossingParameters[token][latestIndex[token]].stakingEndsTimestamp >
        crossingConfig.crossingMigrationDelay,
      "EC"
    );
    (uint256 tokenBalance, uint256 lpMinted) = token.migrate(
      LimboAddTokenToBehodlerPowerLike(crossingConfig.morgothPower),
      tokenCrossingParameters[token][latestIndex[token]],
      crossingConfig,
      Flan,
      RectangleOfFairness,
      soul
    );
    emit TokenListed(token, tokenBalance, lpMinted);
  }

  ///@notice analogous to ERC20 approve, this function gives third party contracts permission to migrate token balances on Limbo. Useful for both upgrades and third party integrations into Limbo
  function approveUnstake(
    address soul,
    address unstaker,
    uint256 amount
  ) external {
    unstakeApproval[soul][msg.sender][unstaker] = amount; //soul->owner->unstaker->amount
  }

  function rewardAdjustDebt(
    address recipient,
    uint256 pending,
    uint256 accumulatedFlanPerShare,
    User storage user
  ) internal {
    Flan.mint(recipient, pending);
    user.rewardDebt = (user.stakedAmount * accumulatedFlanPerShare) / TERA;
  }

  function currentSoul(address token) internal view returns (Soul storage) {
    return souls[token][latestIndex[token]];
  }

  function getPending(User memory user, Soul memory soul) internal pure returns (uint256) {
    return ((user.stakedAmount * soul.accumulatedFlanPerShare) / TERA) - user.rewardDebt;
  }
}
.]

###

[2024-25-08 12:28:21 INFO] **[Seminar Conclusion]**:

 ###

[2024-25-08 12:28:21 INFO] **[Post Info]**

Software Info: 

**cost**=$0.000000

**version_updates**=1.0

**num_code_files**=0

**num_png_files**=0

**num_doc_files**=5

**code_lines**=0

**env_lines**=-1

**manual_lines**=-1

**num_utterances**=18

**num_self_reflections**=1

**num_prompt_tokens**=126150

**num_completion_tokens**=4986

**num_total_tokens**=131136

**duration**=79.00s

ChatDev Starts (20240825122702)

ChatDev Ends (20240825122821)



